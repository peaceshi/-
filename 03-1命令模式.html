<!DOCTYPE HTML>
<html lang="cmn-Hans" class="sidebar-visible no-js rust">

<head>
	<!-- Book generated using mdBook -->
	<meta charset="UTF-8">
	<title>命令模式 - 游戏编程模式</title>
	

	<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
	<meta name="description" content="游戏编程模式">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#ffffff" />

	<link rel="manifest" href="manifest.json">
	<link href='https://storage.googleapis.com/' rel='preconnect' crossorigin>
	<link href='https://cdn.jsdelivr.net/' rel='preconnect' crossorigin>
	<link href='https://play.rust-lang.org' rel='preconnect' crossorigin>
	<link href='https://cdn.staticfile.org/' rel='preconnect' crossorigin>
	<link href='https://peaceshi.github.io/' rel='preconnect' crossorigin>
	<link rel="shortcut icon"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/favicon.png">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/css/variables.css" as="style">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/css/variables.css">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/css/general.css" as="style">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/css/general.css">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/css/chrome.css" as="style">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/css/chrome.css">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/css/print.css" media="print">
	<!-- Fonts -->
	<link rel="preload" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" as="style"
		crossorigin>
	<link rel='stylesheet' href='https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css' type='text/css'
		crossorigin>
	<!-- Highlight.js Stylesheets -->
	<link rel="preload" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css" as="style"
		crossorigin>
	<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css" type='text/css'
		crossorigin>
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/ayu-highlight.css" crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/ayu-highlight.css"
		as="style" crossorigin>
		<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/highlight.css" crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/highlight.css"
		as="style" crossorigin>
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/tomorrow-night.css" crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/tomorrow-night.css"
		as="style" crossorigin>

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/theme/theme.css"
		crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/theme/theme.css"
		as="style" crossorigin>
	<!-- Custom theme stylesheets -->
	
	
	
	
</head>

<body>
	<!-- Provide site root to javascript -->
	<script type="text/javascript">
		var path_to_root = "";
		var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
	</script>

	<!-- Work around some values being stored in localStorage wrapped in quotes -->
	<script type="text/javascript">
		try {
			var theme = localStorage.getItem('mdbook-theme');
			var sidebar = localStorage.getItem('mdbook-sidebar');

			if (theme.startsWith('"') && theme.endsWith('"')) {
				localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
			}

			if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
				localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
			}
		} catch (e) { }
	</script>

	<!-- Set the theme before any content is loaded, prevents flash -->
	<script type="text/javascript">
		var theme;
		try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
		if (theme === null || theme === undefined) { theme = default_theme; }
		var html = document.querySelector('html');
		html.classList.remove('no-js')
		html.classList.remove('rust')
		html.classList.add(theme);
		html.classList.add('js');
	</script>

	<!-- Hide / unhide sidebar before it is displayed -->
	<script type="text/javascript">
		var html = document.querySelector('html');
		var sidebar = 'hidden';
		if (document.body.clientWidth >= 1080) {
			try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
			sidebar = sidebar || 'visible';
		}
		html.classList.remove('sidebar-visible');
		html.classList.add("sidebar-" + sidebar);
	</script>
	<nav id="sidebar" class="sidebar" aria-label="Table of contents">
		<div id="sidebar-scrollbox" class="sidebar-scrollbox">
			<ol class="chapter"><li class="expanded affix "><a href="0说明.html">说明</a></li><li class="expanded affix "><a href="00致谢.html">致谢</a></li><li class="expanded affix "><a href="01序.html">作者序</a></li><li class="expanded affix "><a href="02架构，性能和游戏.html">架构，性能和游戏</a></li><li class="expanded "><a href="03重返设计模式.html"><strong aria-hidden="true">1.</strong> 重返设计模式</a></li><li><ol class="section"><li class="expanded "><a href="03-1命令模式.html" class="active"><strong aria-hidden="true">1.1.</strong> 命令模式</a></li><li class="expanded "><a href="03-2享元模式.html"><strong aria-hidden="true">1.2.</strong> 享元模式</a></li><li class="expanded "><a href="03-3观察者模式.html"><strong aria-hidden="true">1.3.</strong> 观察者模式</a></li><li class="expanded "><a href="03-4原型模式.html"><strong aria-hidden="true">1.4.</strong> 原型模式</a></li><li class="expanded "><a href="03-5单例模式.html"><strong aria-hidden="true">1.5.</strong> 单例模式</a></li><li class="expanded "><a href="03-6状态模式.html"><strong aria-hidden="true">1.6.</strong> 状态模式</a></li></ol></li><li class="expanded "><a href="04序列模式.html"><strong aria-hidden="true">2.</strong> 序列模式</a></li><li><ol class="section"><li class="expanded "><a href="04-1双缓冲模式.html"><strong aria-hidden="true">2.1.</strong> 双缓冲模式</a></li><li class="expanded "><a href="04-2游戏循环.html"><strong aria-hidden="true">2.2.</strong> 游戏循环</a></li><li class="expanded "><a href="04-3更新方法.html"><strong aria-hidden="true">2.3.</strong> 更新方法</a></li></ol></li><li class="expanded "><a href="05行为模式.html"><strong aria-hidden="true">3.</strong> 行为模式</a></li><li><ol class="section"><li class="expanded "><a href="05-1字节码.html"><strong aria-hidden="true">3.1.</strong> 字节码</a></li><li class="expanded "><a href="05-2子类沙箱.html"><strong aria-hidden="true">3.2.</strong> 子类沙箱</a></li><li class="expanded "><a href="05-3类型对象.html"><strong aria-hidden="true">3.3.</strong> 类型对象</a></li></ol></li><li class="expanded "><a href="06解耦模式.html"><strong aria-hidden="true">4.</strong> 解耦模式</a></li><li><ol class="section"><li class="expanded "><a href="06-1组件模式.html"><strong aria-hidden="true">4.1.</strong> 组件模式</a></li><li class="expanded "><a href="06-2事件队列.html"><strong aria-hidden="true">4.2.</strong> 事件队列</a></li><li class="expanded "><a href="06-3服务定位器.html"><strong aria-hidden="true">4.3.</strong> 服务定位器</a></li></ol></li><li class="expanded "><a href="07优化模式.html"><strong aria-hidden="true">5.</strong> 优化模式</a></li><li><ol class="section"><li class="expanded "><a href="07-1数据局部性.html"><strong aria-hidden="true">5.1.</strong> 数据局部性</a></li><li class="expanded "><a href="07-2脏标识模式.html"><strong aria-hidden="true">5.2.</strong> 脏标识模式</a></li><li class="expanded "><a href="07-3对象池模式.html"><strong aria-hidden="true">5.3.</strong> 对象池模式</a></li><li class="expanded "><a href="07-3空间分区.html"><strong aria-hidden="true">5.4.</strong> 空间分区</a></li></ol></li><li class="expanded "><a href="附录一.html">附录一</a></li></ol>
		</div>
		<div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
	</nav>

	<div id="page-wrapper" class="page-wrapper">

		<div class="page">
			
			<div id="menu-bar" class="menu-bar">
				<div id="menu-bar-sticky-container">
					<div class="left-buttons">
						<button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
							aria-label="Toggle Table of Contents" aria-controls="sidebar">
							<i class="fa fa-bars"></i>
						</button>
						<button id="theme-toggle" class="icon-button" type="button" title="Change theme"
							aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
							aria-controls="theme-list">
							<i class="fa fa-paint-brush"></i>
						</button>
						<ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
							<li role="none"><button role="menuitem" class="theme"
									id="light">Light</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="rust">Rust (default)</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="coal">Coal</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="navy">Navy</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="ayu">Ayu</button></li>
						</ul>
						
					</div>

					<h1 class="menu-title">游戏编程模式</h1>

					<div class="right-buttons">
						<a href="print.html" title="Print this book" aria-label="Print this book">
							<i id="print-button" class="fa fa-print"></i>
						</a>
						
						<a href="https://github.com/peaceshi/GameProgrammingPatterns" title="Git repository" aria-label="Git repository">
							<i id="git-repository-button" class="fa fa-github"></i>
						</a>
						
					</div>
				</div>
			</div>

			

			<!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
			<script type="text/javascript">
				document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
				document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
				Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
					link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
				});
			</script>

			<div id="content" class="content">
				<main>
					<h1><a class="header" href="#命令模式" id="命令模式">命令模式</a></h1>
<p>命令模式是我最喜欢的模式之一。
大多数我写的游戏或者别的什么之类的大型程序，都会在某处用到它。
当在正确的地方使用时，它可以将复杂的代码清理干净。
对于这样一个了不起的模式，不出所料地，GoF 有个深奥的定义：</p>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；
对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>我想你也会觉得这个句子晦涩难懂。
第一，它的比喻难以理解。
在词语可以指代任何事物的狂野软件世界之外，“客户”是一个<strong>人</strong>——那些和你做生意的人。
据我查证，人类不能被“参数化”。</p>
<p>然后，句子余下的部分介绍了可能会使用这个模式的场景。
如果你的场景不在这个列表中，那么这对你就没什么用处。
<strong>我的</strong>命令模式精简定义为：</p>
<blockquote>
<blockquote>
<blockquote>
<p>命令是具现化的方法调用。</p>
</blockquote>
<p>A command is a reified method call.</p>
</blockquote>
<p>“Reify（具现化）”来自于拉丁语“res”，意为“thing”（事物），加上英语后缀“-fy”。
所以它意为“thingify”，没准用“thingify”更合适。</p>
</blockquote>
<p>当然，“精简”往往意味着着“缺少必要信息”，所以这可能没有太大的改善。
让我扩展一下。如果你没有听说过“具现化”的话，它的意思是“实例化，对象化”。
具现化的另外一种解释方式是将某事物作为“第一公民”对待。</p>
<blockquote>
<p>在某些语言中的<strong>反射</strong>允许你在程序运行时命令式地和类型交互。
你可以获得类的类型对象，可以与其交互看看这个类型能做什么。换言之，反射是<strong>具现化类型的系统</strong>。</p>
</blockquote>
<p>两种术语都意味着将<strong>概念</strong>变成<strong>数据</strong>
——一个对象——可以存储在变量中，传给函数。
所以称命令模式为“具现化方法调用”，意思是方法调用被存储在对象中。</p>
<p>这听起来有些像“回调”，“第一公民函数”，“函数指针”，“闭包”，“偏函数”，
取决于你在学哪种语言，事实上大致上是同一个东西。GoF 随后说：</p>
<blockquote>
<p>命令模式是一种回调的面向对象实现。</p>
</blockquote>
<p>这是一种对命令模式更好的解释。</p>
<p>但这些都既抽象又模糊。我喜欢用实际的东西作为章节的开始，不好意思，搞砸了。
作为弥补，从这里开始都是命令模式能出色应用的例子。</p>
<h2><a class="header" href="#配置输入" id="配置输入">配置输入</a></h2>
<p>在每个游戏中都有一块代码读取用户的输入——按钮按下，键盘敲击，鼠标点击，诸如此类。
这块代码会获取用户的输入，然后将其变为游戏中有意义的行为：</p>
<p><img src="https://gpp.tkchu.me/images/command-buttons-one.png" alt="配置输入" /></p>
<p>下面是一种简单的实现：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) lurchIneffectively();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>专家建议：不要太经常地按 B。</p>
</blockquote>
<p>这个函数通常在<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>中每帧调用一次，我确信你可以理解它做了什么。
在我们想将用户的输入和程序行为硬编码在一起时，这段代码可以正常工作，但是许多游戏允许玩家<strong>配置</strong>按键的功能。</p>
<p>为了支持这点，需要将这些对<code>jump()</code>和<code>fireGun()</code>的直接调用转化为可以变换的东西。
“变换”听起来有点像变量干的事，因此我们需要表示游戏行为的<strong>对象</strong>。进入：命令模式。</p>
<p>我们定义了一个基类代表可触发的游戏行为：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>当你有接口只包含一个没有返回值的方法时，很可能你可以使用命令模式。</p>
</blockquote>
<p>然后我们为不同的游戏行为定义相应的子类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class JumpCommand : public Command
{
public:
  virtual void execute() { jump(); }
};

class FireCommand : public Command
{
public:
  virtual void execute() { fireGun(); }
};

// 你知道思路了吧
<span class="boring">}
</span></code></pre></pre>
<p>在代码的输入处理部分，为每个按键存储一个指向命令的指针。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class InputHandler
{
public:
  void handleInput();

  // 绑定命令的方法……

private:
  Command** buttonX_;
  Command** buttonY_;
  Command** buttonA_;
  Command** buttonB_;
};
<span class="boring">}
</span></code></pre></pre>
<p>现在输入处理部分这样处理：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) buttonX_-&gt;execute();
  else if (isPressed(BUTTON_Y)) buttonY_-&gt;execute();
  else if (isPressed(BUTTON_A)) buttonA_-&gt;execute();
  else if (isPressed(BUTTON_B)) buttonB_-&gt;execute();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意在这里没有检测<code>NULL</code>了吗？这假设每个按键都与<strong>某些</strong>命令相连。</p>
<p>如果想支持不做任何事情的按键又不想显式检测<code>NULL</code>，我们可以定义一个命令类，它的<code>execute()</code>什么也不做。
这样，某些按键处理器不必设为<code>NULL</code>，只需指向这个类。这种模式被称为<a href="http://en.wikipedia.org/wiki/Null_Object_pattern">空对象</a>。</p>
</blockquote>
<p>以前每个输入直接调用函数，现在会有一层间接寻址：</p>
<p><img src="https://gpp.tkchu.me/images/command-buttons-two.png" alt="间接寻址" /></p>
<p>这是命令模式的简短介绍。如果你能够看出它的好处，就把这章剩下的部分作为奖励吧。</p>
<h2><a class="header" href="#角色说明" id="角色说明">角色说明</a></h2>
<p>我们刚才定义的类可以在之前的例子上正常工作，但有很大的局限。
问题在于假设了顶层的<code>jump()</code>, <code>fireGun()</code>之类的函数可以找到玩家角色，然后像木偶一样操纵它。</p>
<p>这些假定的耦合限制了这些命令的用处。<code>JumpCommand</code><em>只能</em> 让玩家的角色跳跃。让我们放松这个限制。
不让函数去找它们控制的角色，我们将函数控制的角色对象<strong>传进去</strong>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute(GameActor&amp; actor) = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p>这里的<code>GameActor</code>是代表游戏世界中角色的“游戏对象”类。
我们将其传给<code>execute()</code>，这样命令类的子类就可以调用所选游戏对象上的方法，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class JumpCommand : public Command
{
public:
  virtual void execute(GameActor&amp; actor)
  {
    actor.jump();
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们可以使用这个类让游戏中的任何角色跳来跳去了。
在输入控制部分和在对象上调用命令部分之间，我们还缺了一块代码。
第一，我们修改<code>handleInput()</code>，让它可以<strong>返回</strong>命令：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) return buttonX_;
  if (isPressed(BUTTON_Y)) return buttonY_;
  if (isPressed(BUTTON_A)) return buttonA_;
  if (isPressed(BUTTON_B)) return buttonB_;

  // 没有按下任何按键，就什么也不做
  return NULL;
}
<span class="boring">}
</span></code></pre></pre>
<p>这里不能立即执行，因为还不知道哪个角色会传进来。
这里我们享受了命令是具体调用的好处——<code>延迟</code>到调用执行时再知道。</p>
<p>然后，需要一些接受命令的代码，作用在玩家角色上。像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** command = inputHandler.handleInput();
if (command)
{
  command-&gt;execute(actor);
}
<span class="boring">}
</span></code></pre></pre>
<p>将<code>actor</code>视为玩家角色的引用，它会正确地按着玩家的输入移动，
所以我们赋予了角色和前面例子中相同的行为。
通过在命令和角色间增加了一层重定向，
我们获得了一个灵巧的功能：<em>我们可以让玩家控制游戏中的任何角色，只需向命令传入不同的角色。</em></p>
<p>在实践中，这个特性并不经常使用，但是<strong>经常</strong>会有类似的用例跳出来。
到目前为止，我们只考虑了玩家控制的角色，但是游戏中的其他角色呢？
它们被游戏 AI 控制。我们可以在 AI 和角色之间使用相同的命令模式；AI 代码只需生成<code>Command</code>对象。</p>
<p>在选择命令的 AI 和展现命令的游戏角色间解耦给了我们很大的灵活度。
我们可以对不同的角色使用不同的 AI，或者为了不同的行为而混合 AI。
想要一个更加有攻击性的对手？插入一个更加有攻击性的 AI 为其生成命令。
事实上，我们甚至可以为<strong>玩家角色</strong>加上 AI，
在展示阶段，游戏需要自动演示时，这是很有用的。</p>
<p>把控制角色的命令变为第一公民对象，去除直接方法调用中严厉的束缚。
将其视为命令队列，或者是命令流：</p>
<blockquote>
<p>队列能为你做的更多事情，请看<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">事件队列</a>。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/command-stream.png" alt="一条连接AI到角色的管道" /></p>
<blockquote>
<p>为什么我觉得需要为你画一幅“流”的图像？又是为什么它看上去像是管道？</p>
</blockquote>
<p>一些代码（输入控制器或者 AI）产生一系列命令放入流中。
另一些代码（调度器或者角色自身）调用并消耗命令。
通过在中间加入队列，我们解耦了消费者和生产者。</p>
<blockquote>
<p>如果将这些指令<strong>序列化</strong>，我们可以通过网络流传输它们。
我们可以接受玩家的输入，将其通过网络发送到另外一台机器上，然后重现之。这是网络多人游戏的基础。</p>
</blockquote>
<h2><a class="header" href="#撤销和重做" id="撤销和重做">撤销和重做</a></h2>
<p>最后的这个例子是这种模式最广为人知的使用情况。
如果一个命令对象可以<strong>做</strong>一件事，那么它亦可以<strong>撤销</strong>这件事。
在一些策略游戏中使用撤销，这样你就可以回滚那些你不喜欢的操作。
它是<strong>创造</strong>游戏时<strong>必不可少的</strong>工具。
一个不能撤销误操作导致的错误的编辑器，肯定会让游戏设计师恨你。</p>
<blockquote>
<p>这是经验之谈。</p>
</blockquote>
<p>没有了命令模式，实现撤销非常困难，有了它，就是小菜一碟。
假设我们在制作单人回合制游戏，想让玩家能撤销移动，这样他们就可以集中注意力在策略上而不是猜测上。</p>
<p>我们已经使用了命令来抽象输入控制，所以每个玩家的举动都已经被封装其中。
举个例子，移动一个单位的代码可能如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit** unit, int x, int y)
  : unit_(unit),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    unit_-&gt;moveTo(x_, y_);
  }

private:
  Unit** unit_;
  int x_, y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意这和前面的命令有些许不同。
在前面的例子中，我们需要从修改的角色那里<strong>抽象</strong>命令。
在这个例子中，我们将命令<strong>绑定</strong>到要移动的单位上。
这条命令的实例不是通用的“移动某物”命令；而是游戏回合中特殊的一次移动。</p>
<p>这展现了命令模式应用时的一种情形。
就像之前的例子，指令在某些情形中是可重用的对象，代表了<strong>可执行的事件</strong>。
我们早期的输入控制器将其实现为一个命令对象，然后在按键按下时调用其<code>execute()</code>方法。</p>
<p>这里的命令更加特殊。它们代表了特定时间点能做的特定事件。
这意味着输入控制代码可以在玩家下决定时<strong>创造</strong>一个实例。就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** handleInput()
{
  Unit** unit = getSelectedUnit();

  if (isPressed(BUTTON_UP)) {
    // 向上移动单位
    int destY = unit-&gt;y() - 1;
    return new MoveUnitCommand(unit, unit-&gt;x(), destY);
  }

  if (isPressed(BUTTON_DOWN)) {
    // 向下移动单位
    int destY = unit-&gt;y() + 1;
    return new MoveUnitCommand(unit, unit-&gt;x(), destY);
  }

  // 其他的移动……

  return NULL;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>当然，在像 C++这样没有垃圾回收的语言中，这意味着执行命令的代码也要负责释放内存。</p>
</blockquote>
<p>命令的一次性为我们很快地赢得了一个优点。
为了让指令可被取消，我们为每个类定义另一个需要实现的方法：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
  virtual void undo() = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p><code>undo()</code>方法回滚了<code>execute()</code>方法造成的游戏状态改变。
这里是添加了撤销功能后的移动命令：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit** unit, int x, int y)
  : unit_(unit),
    xBefore_(0),
    yBefore_(0),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    // 保存移动之前的位置
    // 这样之后可以复原。

    xBefore_ = unit_-&gt;x();
    yBefore_ = unit_-&gt;y();

    unit_-&gt;moveTo(x_, y_);
  }

  virtual void undo()
  {
    unit_-&gt;moveTo(xBefore_, yBefore_);
  }

private:
  Unit** unit_;
  int xBefore_, yBefore_;
  int x_, y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意我们为类添加了更多的状态。
当单位移动时，它忘记了它之前是什么样的。
如果我们想要撤销这个移动，我们需要记得单位之前的状态，也就是<code>xBefore_</code>和<code>yBefore_</code>的作用。</p>
<blockquote>
<p>这看上去是<a href="http://en.wikipedia.org/wiki/Memento_pattern">备忘录</a>模式使用的地方，它从来没有有效地工作过。
由于命令趋向于修改对象状态的一小部分，对数据其他部分的快照就是浪费内存。手动内存管理的消耗更小。</p>
<p><a href="http://en.wikipedia.org/wiki/Persistent_data_structure"><strong>持久化数据结构</strong></a>是另一个选项。
使用它，每次修改对象都返回一个新对象，保持原来的对象不变。巧妙的实现下，这些新对象与之前的对象共享数据，所以比克隆整个对象开销更小。</p>
<p>使用持久化数据结构，每条命令都存储了命令执行之前对象的引用，而撤销只是切换回之前的对象。</p>
</blockquote>
<p>为了让玩家撤销移动，我们记录了执行的最后命令。当他们按下<code>control + z</code>时，我们调用命令的<code>undo()</code>方法。
（如果他们已经撤销了，那么就变成了“重做”，我们会再一次执行命令。）</p>
<p>支持多重的撤销也不太难。
我们不单单记录最后一条指令，还要记录指令列表，然后用一个引用指向“当前”的那个。
当玩家执行一条命令，我们将其添加到列表，然后将代表“当前”的指针指向它。</p>
<p><img src="https://gpp.tkchu.me/images/command-undo.png" alt="多重撤销" /></p>
<p>当玩家选择“撤销”，我们撤销现在的命令，将代表当前的指针往后退。
当他们选择“重做”，我们将代表当前的指针往前进，执行该指令。
如果在撤销后选择了新命令，那么清除命令列表中当前的指针所指命令之后的全部命令。</p>
<p>第一次在关卡编辑器中实现这点时，我觉得自己简直就是个天才。
我惊讶于它如此的简明有效。
你需要约束自己，保证每个数据修改都通过命令完成，一旦你做到了，余下的都很简单。</p>
<blockquote>
<p>重做在游戏中并不常见，但重<strong>放</strong>常见。
一种简单的重放实现是记录游戏每帧的状态，这样它可以回放，但那会消耗太多的内存。</p>
<p>相反，很多游戏记录每个实体每帧运行的命令。
为了重放游戏，引擎只需要正常运行游戏，执行之前存储的命令。</p>
</blockquote>
<h2><a class="header" href="#用类还是用函数" id="用类还是用函数">用类还是用函数</a></h2>
<p>早些时候，我说过命令与第一公民函数或者闭包类似，
但是在这里展现的每个例子都是通过类完成的。
如果你更熟悉函数式编程，你也许会疑惑函数都在哪里。</p>
<p>我用这种方式写例子是因为 C++ 对第一公民函数支持非常有限。
函数指针没有状态，函子很奇怪而且仍然需要定义类，
在 C++11 中的 lambda 演算需要大量的人工记忆辅助才能使用。</p>
<p>这并<strong>不是</strong>说你在其他语言中不可以用函数来完成命令模式。
如果你使用的语言支持闭包，不管怎样，快去用它！
在某种程度上说，命令模式是为一些没有闭包的语言模拟闭包。</p>
<blockquote>
<p>我说<strong>某种程度上</strong>是因为，即使是那些支持闭包的语言，为命令建立真正的类或者结构也是很有用的。
如果你的命令拥有多重操作（比如可撤销的命令），将其全部映射到同一函数中并不优雅。</p>
<p>定义一个有字段的真实类能帮助读者理解命令包含了什么数据。
闭包是自动包装状态的完美解决方案，但它们过于自动化而很难看清包装的真正状态有哪些。</p>
</blockquote>
<p>举个例子，如果我们使用 javascript 来写游戏，那么我们可以用这种方式来写让单位移动的命令：</p>
<pre><code class="language-javascript">function makeMoveUnitCommand(unit, x, y) {
  // 这个函数就是命令对象:
  return function() {
    unit.moveTo(x, y);
  };
}
</code></pre>
<p>我们可以通过一对闭包来为撤销提供支持：</p>
<pre><code class="language-javascript">function makeMoveUnitCommand(unit, x, y) {
  var xBefore, yBefore;
  return {
    execute: function() {
      xBefore = unit.x();
      yBefore = unit.y();
      unit.moveTo(x, y);
    },
    undo: function() {
      unit.moveTo(xBefore, yBefore);
    }
  };
}
</code></pre>
<p>如果你习惯了函数式编程风格，这种做法是很自然的。
如果你没有，我希望这章可以帮你了解一些。
对于我而言，命令模式展现了函数式范式在很多问题上的高效性。</p>
<h2><a class="header" href="#参见" id="参见">参见</a></h2>
<ul>
<li>
<p>你最终可能会得到很多不同的命令类。
为了更容易实现这些类，定义一个具体的基类，包含一些能定义行为的高层方法，往往会有帮助。
这将命令的主体<code>execute()</code>转到<a href="05-2%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1.html">子类沙箱</a>中。</p>
</li>
<li>
<p>在上面的例子中，我们明确地指定哪个角色会处理命令。
在某些情况下，特别是当对象模型分层时，也可以不这么简单粗暴。
对象可以响应命令，或者将命令交给它的从属对象。
如果你这样做，你就完成了一个<a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">职责链模式</a>。</p>
</li>
<li>
<p>有些命令是无状态的纯粹行为，比如第一个例子中的<code>JumpCommand</code>。
在这种情况下，有多个实例是在浪费内存，因为所有的实例是等价的。
可以用<a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a>解决。</p>
</li>
</ul>
<blockquote>
<p>你可以将其实现为<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例</a>，但真朋友不会让你用单例。</p>
</blockquote>

				</main>

				<nav class="nav-wrapper" aria-label="Page navigation">
					<!-- Mobile navigation buttons -->
					
					<a rel="prev" href="03重返设计模式.html" class="mobile-nav-chapters previous"
						title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
						<i class="fa fa-angle-left"></i>
					</a>
					

					
					<a rel="next" href="03-2享元模式.html" class="mobile-nav-chapters next"
						title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
						<i class="fa fa-angle-right"></i>
					</a>
					

					<div style="clear: both"></div>
				</nav>
			</div>
		</div>

		<nav class="nav-wide-wrapper" aria-label="Page navigation">
			
			<a href="03重返设计模式.html" class="nav-chapters previous" title="Previous chapter"
				aria-label="Previous chapter" aria-keyshortcuts="Left">
				<i class="fa fa-angle-left"></i>
			</a>
			

			
			<a href="03-2享元模式.html" class="nav-chapters next" title="Next chapter"
				aria-label="Next chapter" aria-keyshortcuts="Right">
				<i class="fa fa-angle-right"></i>
			</a>
			
		</nav>

	</div>

	

	

	

	
	<script type="text/javascript">
		window.playpen_copyable = true;
	</script>
	

	

	
	<script defer src="https://cdn.staticfile.org/clipboard.js/2.0.4/clipboard.min.js"></script>
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/languages/basic.min.js"></script>
	<script defer src="https://cdn.staticfile.org/lazysizes/5.2.0/lazysizes.min.js"></script>
	<script defer src="https://cdn.staticfile.org/mermaid/8.4.6/mermaid.min.js"></script>
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/src/theme/book.js"></script>
	<!-- Custom JS scripts -->
	
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/plugin/init.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@da5f3d1/plugin/bundle.js"></script>
	
	
	

</body>

</html>
