<!DOCTYPE HTML>
<html lang="cmn-Hans" class="sidebar-visible no-js rust">

<head>
	<!-- Book generated using mdBook -->
	<meta charset="UTF-8">
	<title>游戏编程模式</title>
	
	<meta name="robots" content="noindex" />
	
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
	<meta name="description" content="游戏编程模式">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#e1e1db" />
	<!-- preconnect -->
	<link href='https://storage.googleapis.com/' rel='preconnect'>
	<link href='https://cdn.jsdelivr.net/' rel='preconnect'>
	<link href='https://play.rust-lang.org' rel='preconnect'>
	<link href='https://cdn.staticfile.org/' rel='preconnect'>
	<link href='https://peaceshi.github.io/' rel='preconnect'>
	<!-- preload -->
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/css/variables.css"
		as="style">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/css/general.css" as="style">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/css/chrome.css" as="style">
	<link rel="preload" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" as="style">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/highlight.css" as="style">
	<link rel="preload" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css" as="style">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/ayu-highlight.css"
		as="style">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/tomorrow-night.css"
		as="style">
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/theme/theme.css"
		as="style">
	<!-- manifest -->
	<link rel="manifest" href="manifest.json">
	<!-- favicon -->
	<link rel="shortcut icon"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/favicon.png">
	<!-- stylesheet -->
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/css/variables.css">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/css/general.css">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/css/chrome.css">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/css/print.css"
		media="print">
	<link rel='stylesheet' href='https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css'
		type='text/css'>
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/highlight.css">
	<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/ayu-highlight.css">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/tomorrow-night.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/theme/theme.css">
	<!-- Custom theme stylesheets -->
	
	
	
	
</head>

<body>
	<!-- Provide site root to javascript -->
	<script type="text/javascript">
		var path_to_root = "";
		var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
	</script>

	<!-- Work around some values being stored in localStorage wrapped in quotes -->
	<script type="text/javascript">
		try {
			var theme = localStorage.getItem('mdbook-theme');
			var sidebar = localStorage.getItem('mdbook-sidebar');

			if (theme.startsWith('"') && theme.endsWith('"')) {
				localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
			}

			if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
				localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
			}
		} catch (e) { }
	</script>

	<!-- Set the theme before any content is loaded, prevents flash -->
	<script type="text/javascript">
		var theme;
		try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
		if (theme === null || theme === undefined) { theme = default_theme; }
		var html = document.querySelector('html');
		html.classList.remove('no-js')
		html.classList.remove('rust')
		html.classList.add(theme);
		html.classList.add('js');
	</script>

	<!-- Hide / unhide sidebar before it is displayed -->
	<script type="text/javascript">
		var html = document.querySelector('html');
		var sidebar = 'hidden';
		if (document.body.clientWidth >= 1080) {
			try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
			sidebar = sidebar || 'visible';
		}
		html.classList.remove('sidebar-visible');
		html.classList.add("sidebar-" + sidebar);
	</script>
	<nav id="sidebar" class="sidebar" aria-label="Table of contents">
		<div id="sidebar-scrollbox" class="sidebar-scrollbox">
			<ol class="chapter"><li class="expanded affix "><a href="0说明.html">说明</a></li><li class="expanded affix "><a href="00致谢.html">致谢</a></li><li class="expanded affix "><a href="01序.html">作者序</a></li><li class="expanded affix "><a href="02架构，性能和游戏.html">架构，性能和游戏</a></li><li class="expanded "><a href="03重返设计模式.html"><strong aria-hidden="true">1.</strong> 重返设计模式</a></li><li><ol class="section"><li class="expanded "><a href="03-1命令模式.html"><strong aria-hidden="true">1.1.</strong> 命令模式</a></li><li class="expanded "><a href="03-2享元模式.html"><strong aria-hidden="true">1.2.</strong> 享元模式</a></li><li class="expanded "><a href="03-3观察者模式.html"><strong aria-hidden="true">1.3.</strong> 观察者模式</a></li><li class="expanded "><a href="03-4原型模式.html"><strong aria-hidden="true">1.4.</strong> 原型模式</a></li><li class="expanded "><a href="03-5单例模式.html"><strong aria-hidden="true">1.5.</strong> 单例模式</a></li><li class="expanded "><a href="03-6状态模式.html"><strong aria-hidden="true">1.6.</strong> 状态模式</a></li></ol></li><li class="expanded "><a href="04序列模式.html"><strong aria-hidden="true">2.</strong> 序列模式</a></li><li><ol class="section"><li class="expanded "><a href="04-1双缓冲模式.html"><strong aria-hidden="true">2.1.</strong> 双缓冲模式</a></li><li class="expanded "><a href="04-2游戏循环.html"><strong aria-hidden="true">2.2.</strong> 游戏循环</a></li><li class="expanded "><a href="04-3更新方法.html"><strong aria-hidden="true">2.3.</strong> 更新方法</a></li></ol></li><li class="expanded "><a href="05行为模式.html"><strong aria-hidden="true">3.</strong> 行为模式</a></li><li><ol class="section"><li class="expanded "><a href="05-1字节码.html"><strong aria-hidden="true">3.1.</strong> 字节码</a></li><li class="expanded "><a href="05-2子类沙箱.html"><strong aria-hidden="true">3.2.</strong> 子类沙箱</a></li><li class="expanded "><a href="05-3类型对象.html"><strong aria-hidden="true">3.3.</strong> 类型对象</a></li></ol></li><li class="expanded "><a href="06解耦模式.html"><strong aria-hidden="true">4.</strong> 解耦模式</a></li><li><ol class="section"><li class="expanded "><a href="06-1组件模式.html"><strong aria-hidden="true">4.1.</strong> 组件模式</a></li><li class="expanded "><a href="06-2事件队列.html"><strong aria-hidden="true">4.2.</strong> 事件队列</a></li><li class="expanded "><a href="06-3服务定位器.html"><strong aria-hidden="true">4.3.</strong> 服务定位器</a></li></ol></li><li class="expanded "><a href="07优化模式.html"><strong aria-hidden="true">5.</strong> 优化模式</a></li><li><ol class="section"><li class="expanded "><a href="07-1数据局部性.html"><strong aria-hidden="true">5.1.</strong> 数据局部性</a></li><li class="expanded "><a href="07-2脏标识模式.html"><strong aria-hidden="true">5.2.</strong> 脏标识模式</a></li><li class="expanded "><a href="07-3对象池模式.html"><strong aria-hidden="true">5.3.</strong> 对象池模式</a></li><li class="expanded "><a href="07-3空间分区.html"><strong aria-hidden="true">5.4.</strong> 空间分区</a></li></ol></li><li class="expanded "><a href="附录一.html">附录一</a></li></ol>
		</div>
		<div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
	</nav>

	<div id="page-wrapper" class="page-wrapper">

		<div class="page">
			
			<div id="menu-bar" class="menu-bar">
				<div id="menu-bar-sticky-container">
					<div class="left-buttons">
						<button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
							aria-label="Toggle Table of Contents" aria-controls="sidebar">
							<i class="fa fa-bars"></i>
						</button>
						<button id="theme-toggle" class="icon-button" type="button" title="Change theme"
							aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
							aria-controls="theme-list">
							<i class="fa fa-paint-brush"></i>
						</button>
						<ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
							<li role="none"><button role="menuitem" class="theme"
									id="light">Light</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="rust">Rust (default)</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="coal">Coal</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="navy">Navy</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="ayu">Ayu</button></li>
						</ul>
						
					</div>

					<h1 class="menu-title">游戏编程模式</h1>

					<div class="right-buttons">
						<a href="print.html" title="Print this book" aria-label="Print this book">
							<i id="print-button" class="fa fa-print"></i>
						</a>
						
						<a href="https://github.com/peaceshi/GameProgrammingPatterns" title="Git repository" aria-label="Git repository">
							<i id="git-repository-button" class="fa fa-github"></i>
						</a>
						
					</div>
				</div>
			</div>

			

			<!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
			<script type="text/javascript">
				document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
				document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
				Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
					link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
				});
			</script>

			<div id="content" class="content">
				<main>
					<h1><a class="header" href="#说明" id="说明">说明</a></h1>
<p>这个项目是在<a href="https://github.com/tkchu/Game-Programming-Patterns-CN">《游戏编程模式》中文版</a>基础上修改的.</p>
<p>先重新排版.之后根据原文进行补充.</p>
<p>本文使用<a href="https://github.com/be5invis/Sarasa-Gothic/releases/latest">Sarasa-Gothic</a> 系列字体,建议自行本地安装.</p>
<h2><a class="header" href="#目标" id="目标">目标</a></h2>
<ul>
<li>重排中文版,再根据英文版原文补充一次.</li>
<li>中英对照模式.文内代码用 rust 重新实现.</li>
<li>增加附录,注解,补充等等.并且不破坏原文风格.</li>
<li>图片重绘.</li>
</ul>
<h1><a class="header" href="#致谢" id="致谢">致谢</a></h1>
<p>据说只有作家知道写作中会遇到什么，
但还有另外一群人知道内情——那些不幸与作家有亲密关系的人。
我的妻子 Megan 从岩石般致密的生活中，为我开凿出写作时间。
洗盘子，给孩子洗澡也许不是“写作”，
但没有她的这些付出，这本书永远没法写出来。</p>
<p>我在 EA 做程序员时开始写作这本书。
我认为公司不知道这回事，
我要感谢 Michael Malone, Olivier Nallet, 以及 Richard Wifall。
他们为书籍的前几章提供了详尽有益的建议。</p>
<p>写到一半时，我决定放弃传统的出版方式。
我知道，这意味着没有编辑的指导，但有成打的读者通过邮件告诉我书该怎么写；
这意味着没有校对，但有超过 250 个 bug 报告来帮我改进；
这意味着没有写作期限的鼓舞，但当我完成一章，读者会拍着我的背鼓励，我会有更强的动力。</p>
<blockquote>
<p>我没有失去文字编辑。Lauren Briese 在我需要的时候出现并杰出地完成了工作。</p>
</blockquote>
<p>人们称之为“自出版”，但是“众出版”更加接近事实。
写作是件孤独的事，但我从没感到孤单。
哪怕是我停止写作两年后，仍有人来鼓励我。
没有那些提醒我他们期待更多章节的人，我不会重拾工作并完成此书。</p>
<blockquote>
<p>特别感谢 Colm Sloan，完全出于内心的善意，他认真阅读了书中每个章节<em>两遍</em>，给了我众多超赞的反馈。我欠他一份人情，也许是两份。</p>
</blockquote>
<p>那些写过邮件或者发过评论的人，
那些点过赞或者收藏的人，
那些发过推特的人，那些与我交流的人，
那些向朋友宣传这本书的人，那些向我发送错误报告的人，
我要对你们说：我心中充满了对你的感激。
完成这本书是我人生中最大的目标之一，是你让我梦想成真。</p>
<p>谢谢！</p>
<h1><a class="header" href="#作者序" id="作者序">作者序</a></h1>
<p>在五年级时，我和我的朋友被准许使用一间存放有几台非常破旧的 TRS-80s 的房间。
为了鼓舞我们，一位老师给我们找了一些简单的 BASIC 程序打印文档。</p>
<p>电脑的磁带驱动器已经坏掉了，所以每当我们想要运行代码，就得小心地从头开始输入它们。
因此，我们更喜欢那些只有几行长的程序：</p>
<pre><code class="language-basic">    10 PRINT &quot;BOBBY IS RADICAL!!!&quot;
    20 GOTO 10
</code></pre>
<blockquote>
<p>如果电脑打印的次数足够多，也许这句话就会魔法成真。</p>
</blockquote>
<p>哪怕这样，过程也充满了困难。我们不知道如何编程，所以小小的语法错误对我们来说也是天险。
如果程序没有工作，我们就得从头再来一遍——这经常发生。</p>
<p>文档的最后几页是个真正的怪物：一个占据了几页篇幅的程序。
我们得花些时间才能鼓起勇气去试一试，但它实在太诱人——它的标题是“地道与巨魔”。
我们不知道它能做什么，但听起来像是个游戏，还有什么比自己编个电脑游戏更酷的吗？</p>
<p>我们从来没能让它运行起来，一年以后，我们离开了那间教室。
（很久以后，当我真的学会了点 BASIC，我意识到那只是个桌面游戏角色生成器，而不是游戏。）
但是命运的车轮已经开始转动——自那时起，我就想要成为一名游戏程序员。</p>
<p>青少年时，我家有了一台能运行 QuickBASIC 的 Macintosh，之后 THINK C 也能在其上运行。
几乎整个暑假我都在用它编游戏。
自学缓慢而痛苦。
我能轻松地编写并运行某些部分——地图或者小谜题——但随着程序代码量的增长，这越来越难。</p>
<blockquote>
<p>暑假中的不少时间我都花在在路易斯安那州南部的沼泽里逮蛇和乌龟上了。
如果外面不是那么酷热，很有可能这就会是一本讲爬虫而不是编程的书了。</p>
</blockquote>
<p>起初，挑战之处仅仅在于让程序成功运行。然后，是搞明白怎样写出内容超出我大脑容量的代码。
我不再只阅读关于“如何用 C++编程”的书籍，而开始尝试找那些讲如何<strong>组织</strong>程序的书。</p>
<p>几年过后，一位朋友给我一本书：《设计模式：可复用面向对象软件的基础》。
终于！这正是我从青年时期就在寻找的书。
我一口气从头读到尾。虽然我仍然挣扎于自己的程序中，但看到别人也在挣扎并提出了解决方案是一种解脱。
我意识到手无寸铁的我终于有件像样的<strong>工具</strong>了。</p>
<blockquote>
<p>那是我首次见到这位朋友，相互介绍五分钟后，我坐在他的沙发上，在接下来的几个小时中无视他并全神贯注地阅读。
我想自那以后我的社交技能还是有所提高的。</p>
</blockquote>
<p>在 2001 年，我获得了梦想中的工作：EA 的软件工程师。
我等不及要看看真正的游戏，还有专业人士是如何组织一切的。
像实况足球这样的大型游戏使用了什么样的架构？不同的系统是如何交互的？一套代码库是如何在多个平台上运行的？</p>
<p>分析理解源代码是种震颤的体验。图形，AI，动画，视觉效果皆有杰出代码。
有专家知道如何榨干 CPU 的最后一个循环并好好使用。
那些我都不知道是否<strong>可行</strong>的事情，这些人在午饭前就能完成。</p>
<p>但是这些杰出代码依赖的<strong>架构</strong>通常是事后设计。
他们太注重<strong>功能</strong>而忽视了架构。耦合充斥在模块间。
新功能被塞到任何能塞进去的地方。
在梦想幻灭的我看来，这和其他程序员没什么不同，
如果他们阅读过《设计模式》，最多也就用用<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例模式</a>。</p>
<p>当然，没那么糟。我曾幻想游戏程序员坐在白板包围的象牙塔里，为架构冷静地讨论上几周。
而实际情况是，我看到的代码是努力应对紧张截止期限的人赶工完成的。
他们已经竭尽全力，而且就像我慢慢意识到的那样，他们全力以赴的结果通常很好。
我花在游戏代码上的时间越多，我越能发现藏在表面下的天才之处。</p>
<p>不幸的是，“藏”是普遍现象。
宝石埋在代码中，但人们从未意识到它们的存在。
我看到同事重复寻找解决方案，而需要的示例代码就埋在他们所用的代码库中。</p>
<p>这个问题正是这本书要解决的。
我挖出了游戏代码库中能找到的设计模式，打磨然后在这里展示它们，这样可以节约时间用在发明新事物上，而非<strong>重新</strong>发明它们。</p>
<h2><a class="header" href="#书店里已有的书籍" id="书店里已有的书籍">书店里已有的书籍</a></h2>
<p>书店里已经有很多游戏编程书籍了。为什么要再写一本呢？</p>
<p>我看到的很多编程书籍可以归为这两类：</p>
<ul>
<li>
<p><strong>特定领域的书籍。</strong> 这些关于细分领域的书籍带你深入理解游戏开发的某一特定层面。
它们会教授你 3D 图形，实时渲染，物理模拟，人工智能，或者音频播放。
那些很多程序员穷其一生研究的细分领域。</p>
</li>
<li>
<p><strong>完整引擎的书籍。</strong> 另一个方向，还有书籍试图包含游戏引擎的各个部分。
它们倾向于构建特定种类游戏的完整引擎，通常是 3D FPS 游戏。</p>
</li>
</ul>
<p>这两种书我都喜欢，但我认为它们并未覆盖全部空间。
特定领域的书籍很少告诉你这些代码如何与游戏的其他部分打交道。
你擅长物理或者渲染，但是你知道怎么将两者优雅地组合吗？</p>
<p>第二类书包含这些，但是我发现完整引擎的书籍通常过于整体，过于专注某类游戏了。
特别是，随着手游和休闲游戏的兴起，我们正处于众多游戏类型欣欣向荣的时刻。
我们不再只是复制 Quake 了。如果<strong>你的</strong>游戏与该类游戏不同，那些介绍单一引擎的书就不那么有用了。</p>
<p>相反，我在这里做的更<strong>à la carte</strong> 。
每一章都是独立的、可应用到代码上的思路。
这样，你可以用<strong>你</strong>认为最好的方式组合这些思路，用到你的游戏上去。</p>
<blockquote>
<p>另一个广泛使用这种<strong>à la carte</strong>风格的例子是<a href="http://www.satori.org/game-programming-gems/"><em>Game Programming Gems</em></a>系列。</p>
</blockquote>
<h2><a class="header" href="#和设计模式的关联" id="和设计模式的关联">和设计模式的关联</a></h2>
<p>任何名字中有“模式”的编程书都与 Erich Gamma，Richard Helm，Ralph Johnson，和 John Vlissides（通常被称为 GoF）合著的经典书籍：
《设计模式：可复用面向对象软件要素》相关。</p>
<blockquote>
<p>《设计模式》也受到之前的书籍的启发。
创建一种模式语言来描述问题的开放式解法，
这思路来自 <a href="http://en.wikipedia.org/wiki/A_Pattern_Language"><em>A Pattern Language</em></a>，
作者是 Christopher Alexander (还有 Sarah Ishikawa 和 Murray Silverstein).</p>
<p>他们的书是关于架构的（建筑和墙那样的<strong>真正的</strong>框架结构），
但他们希望其他人能使用相同的方法描述其他领域的解决方案。
《设计模式》正是是 GoF 用这一方法在软件业做出的努力。</p>
</blockquote>
<p>称这本书为“游戏编程模式”，我不是暗示 GoF 的模式不适用于游戏编程。
相反：本书的<a href="03%E9%87%8D%E8%BF%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">重返设计模式</a>一节包含了《设计模式》中的很多模式，
但强调了这些模式在游戏编程中的特定使用。</p>
<p>同样地，我认为本书也适用于非游戏软件。
我可以依样画瓢称本书为《更多设计模式》，但是我认为举游戏编程为例子更为契合。
你真的想要另一本介绍员工记录和银行账户的书吗？</p>
<p>也就是说，虽然这里介绍的模式在其他软件上也很有用，但它们更合适于处理游戏中常见的工程挑战：</p>
<ul>
<li>
<p>时间和顺序通常是游戏架构的核心部分。事物必须在正确的时间按正确的顺序发生。</p>
</li>
<li>
<p>高度压缩的开发周期，大量程序员需要能快速构建和迭代一系列不同的行为，同时保证不烦扰他人，也不污染代码库。</p>
</li>
<li>
<p>在定义所有的行为后，游戏开始互动。怪物攻击英雄，药物相互混合，炸弹炸飞敌人或者友军。
实现这些互动不能把代码库搞成一团乱麻。</p>
</li>
<li>
<p>最后，游戏中性能很重要。
游戏开发者处于一场榨干平台性能的竞赛中。
节约 CPU 循环的技巧区分了 A 级百万销量游戏和掉帧差评游戏。</p>
</li>
</ul>
<h2><a class="header" href="#如何阅读这本书" id="如何阅读这本书">如何阅读这本书</a></h2>
<p>《游戏编程模式》分为三大块。
第一部分介绍并划分本书的框架。包含你现在阅读的这章和<a href="02%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%80%A7%E8%83%BD%E5%92%8C%E6%B8%B8%E6%88%8F.html">下一章</a>。</p>
<p>第二部分，<a href="03%E9%87%8D%E8%BF%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">重返设计模式</a>，复习了 GoF 书籍里的很多模式。
在每一章中，我给出我对这个模式的看法，以及我认为它和游戏编程有什么关系。</p>
<p>最后一部分是这本书最肥美的部分。
它展示了十三种我发现有用的模式。它们被分为四类：</p>
<p><a href="04%E5%BA%8F%E5%88%97%E6%A8%A1%E5%BC%8F.html">序列模式</a>, <a href="05%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F.html">行为模式</a>, <a href="06%E8%A7%A3%E8%80%A6%E6%A8%A1%E5%BC%8F.html">解耦模式</a>,和<a href="07%E4%BC%98%E5%8C%96%E6%A8%A1%E5%BC%8F.html">优化模式</a>。</p>
<p>每种模式都使用固定的格式表述，这样你可以将这本书当成引用，快速找到你需要的：</p>
<ul>
<li>
<p><strong>意图</strong> 部分提供这个模式想要解决什么问题的简短介绍。<br />
将它放在首位，这样你可以快速翻阅，找到你现在需要的模式。</p>
</li>
<li>
<p><strong>动机</strong> 部分描述了模式处理的问题示例。<br />
不同于具体的算法，模式通常不针对某个特定问题。
不用示例教授模式，就像不用面团教授烘烤。动机部分提供了面团，而下部分会教你烘烤。</p>
</li>
<li>
<p><strong>模式</strong> 部分将模式从示例中剥离出来。<br />
如果你想要一段对模式的教科书式简短介绍，那就是这部分了。
如果你已经熟悉了这种模式，想要确保你没有拉下什么，这部分也是很好的提示。</p>
</li>
</ul>
<p>到目前为止，模式只是用一两个示例解释。但是如何知道模式对<strong>你的</strong>问题有没有用呢？</p>
<ul>
<li>
<p><strong>何时使用</strong> 部分提供了这个模式在何时使用何时不用的指导。<br />
<strong>记住</strong> 部分指出了使用模式的结果和风险。</p>
</li>
<li>
<p>如果你像我一样需要具体的例子来真正地<strong>理解</strong>某物，那么<strong>示例代码</strong>部分能让你称心如意。<br />
它描述模式的一步步具体实现，来展现模式是如何工作的。</p>
</li>
<li>
<p>模式与算法不同的是它们是开放的。每次你使用模式，可以用不同的方式实现。<br />
下一部分<strong>设计决策</strong>，讨论这些方式，告诉你应用模式时可供考虑的不同选项。</p>
</li>
<li>
<p>作为结尾，这里有<strong>参见</strong>部分展示了这一模式与其他模式的关联，以及那些使用它的真实代码。</p>
</li>
</ul>
<h2><a class="header" href="#关于示例代码" id="关于示例代码">关于示例代码</a></h2>
<p>这本书的示例代码使用 C++ 写就，但这并不意味着这些模式只在 C++ 中有用，或 C++ 比其他语言更适合使用这些模式。
这些模式适用于几乎每种编程语言，虽然有的模式假设编程语言有对象和类。</p>
<p>我选择 C++ 有几个原因。首先，这是在游戏制作中最流行的语言，是业界的<strong>通用语</strong>。
通常，C++ 基于的 C 语法也是 Java，C#，JavaScript 和其他很多语言的基础。
哪怕你不懂 C++ ，你也只需一点点努力就能理解这里的示例代码。</p>
<p>这本书的目标<strong>不是</strong>教会你 C++ 。
示例代码尽可能地简单，不一定符合好的 C++ 风格或规范。
示例代码展示的是意图，而不是代码。</p>
<p>特别地，代码没用“现代的”——C++11 或者更新的——标准。
没有使用标准库，很少使用模板。
它们是“糟糕” C++ 代码，但我希望保持这样，这样那些使用 C，Objective-C，Java 和其他语言的人更容易理解它们。</p>
<p>为了避免花费时间在你已经看过或者是与模式无关的代码上，示例中省略了部分代码。
如果是那样，示例代码中的省略号表明这里隐藏了一些代码。</p>
<p>假设有个函数，做了些工作然后返回值。
而用它作示例的模式只关心返回的值，而不是完成了什么工作。那样的话，示例代码长得像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>bool update()
{
  // 做点工作……
  return isDone();
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#接下来呢" id="接下来呢">接下来呢</a></h2>
<p>设计模式在软件开发过程中不断地改变和扩展。
这本书继续了 GoF 记录分享设计模式的旅程，而这旅程也不会终于本书。</p>
<p>你是这段旅程的关键部分。改良（或者否决）了这本书中的模式，你就是为软件开发社区做贡献。
如果你有任何建议，更正，或者任何反馈，保持联络！</p>
<h1><a class="header" href="#架构性能和游戏" id="架构性能和游戏">架构，性能和游戏</a></h1>
<p>在一头扎进一堆设计模式之前，我想先讲一些我对软件架构及如何将其应用到游戏之中的理解，
这也许能帮你更好地理解这本书的其余部分。
至少，在你被卷入一场关于设计模式和软件架构有多么糟糕（或多么优秀）的辩论时，
这可以给你一些火力支援。</p>
<blockquote>
<p>注意我没有建议你在战斗中选哪一边。就像任何军火贩子一样，我愿意向作战双方出售武器。</p>
</blockquote>
<h2><a class="header" href="#什么是软件架构" id="什么是软件架构">什么是软件架构</a></h2>
<p>如果把本书从头到尾读一遍，
你不会学会 3D 图形背后的线性代数或者游戏物理背后的微积分。
本书不会告诉你如何用 α-β 修剪你的 AI 树，也不会告诉你如何在音频播放中模拟房间中的混响。</p>
<blockquote>
<p>Wow，这段给这本书打了个糟糕的广告啊。</p>
</blockquote>
<p>相反，这本书告诉你在这些<strong>之间</strong>的代码的事情。
与其说这本书是关于如何写代码，不如说是关于如何<strong>架构</strong>代码的。
每个程序都有<strong>一定</strong>架构，哪怕这架构是“将所有东西都塞到<code>main()</code>中看看如何”，
所以我认为讲讲什么造成了<strong>好</strong>架构是很有意思的。我们如何区分好架构和坏架构呢？</p>
<p>我思考这个问题五年了。当然，像你一样，我有对好的设计有一种直觉。
我们都被糟糕的代码折磨得不轻，你唯一能做的好事就是删掉它们，结束它们的痛苦。</p>
<blockquote>
<p>不得不承认，我们中大多数人都该对一些糟糕代码<strong>负责</strong>。</p>
</blockquote>
<p>少数幸运儿有相反的经验，有机会在好好设计的代码库上工作。
那种代码库看上去是间豪华酒店，里面的门房随时准备满足你心血来潮的需求。
这两者之间的区别是什么呢？</p>
<h3><a class="header" href="#什么是好的软件架构" id="什么是好的软件架构">什么是<strong>好的</strong>软件架构</a></h3>
<p>对我而言，好的设计意味着当我作出改动，整个程序就好像正等着这种改动。
我可以仅调用几个函数就完成任务，而代码库本身无需改动。</p>
<p>这听起来很棒，但实际上不可行。“把代码写成改动不会影响其表面上的和谐。”就好。</p>
<p>让我们通俗些。第一个关键点是<strong>架构是关于改动的</strong>。
总会有人改动代码。如果没人碰代码，那么它的架构设计就无关紧要——无论是因为代码至善至美，还是因为代码糟糕透顶以至于没人会为了修改它而玷污自己的文本编辑器。
评价架构设计的好坏就是评价它应对改动有多么轻松。
没有了改动，架构好似永远不会离开起跑线的运动员。</p>
<h3><a class="header" href="#如何处理改动" id="如何处理改动">如何处理改动</a></h3>
<p>在你改动代码去添加新特性，去修复漏洞，或者随便用文本编辑器干点什么的时候，
你需要理解代码正在做什么。当然，你不需要理解整个程序，
但你需要将所有相关的东西装进你的大脑。</p>
<blockquote>
<p>有点诡异，这字面上是一个 OCR 过程。</p>
</blockquote>
<p>我们通常无视了这步，但这往往是编程中最耗时的部分。
如果你认为将数据从磁盘上分页到 RAM 上很慢，
那么通过一对神经纤维将数据分页到大脑中无疑更慢。</p>
<p>一旦把所有正确的上下文都记到了你的大脑里，
想一会，你就能找到解决方案。
可能有时也需要反复斟酌，但通常比较简单。
一旦理解了问题和需要改动的代码，实际的编码工作有时是微不足道的。</p>
<p>用手指在键盘上敲打一阵，直到屏幕上闪着正确的光芒，
搞定了，对吧？还没呢！
在你为之写测试并发送到代码评审之前，通常有些清理工作要做。</p>
<blockquote>
<p>我是不是说了“测试”？噢，是的。为有些游戏代码写单元测试很难，但代码库的大部分是完全可以测试的。</p>
<p>我不会在这里发表演说，但是我建议你，如果还没有做自动测试，请考虑一下。
除了手动验证以外你就没更重要的事要做了吗？</p>
</blockquote>
<p>你将一些代码加入了游戏，但肯定不想下一个人被留下来的小问题绊倒。
除非改动很小，否则就还需要一些微调新代码的工作，使之无缝对接到程序的其他部分。
如果你做对了，那么下个编写代码的人无法察觉到哪些代码是新加入的。</p>
<p>简而言之，编程的流程图看起来是这样的：</p>
<pre class="mermaid">graph LR

获得问题 --> 研究代码
研究代码 --> 编写解决方案
编写解决方案 --> 清理代码
清理代码 --> 获得问题
</pre>
<blockquote>
<p>令人震惊的死循环，我看到了。</p>
</blockquote>
<h3><a class="header" href="#解耦帮了什么忙" id="解耦帮了什么忙">解耦帮了什么忙</a></h3>
<p>虽然并不明显，但我认为很多软件架构都是关于研究代码的阶段。
将代码载入到神经元太过缓慢，找些策略减少载入的总量是件很值得做的事。
这本书有整整一章是关于<a href="06%E8%A7%A3%E8%80%A6%E6%A8%A1%E5%BC%8F.html"><strong>解耦</strong>模式</a>，
还有很多<strong>设计模式</strong>是关于同样的主题。</p>
<p>可以用多种方式定义“解耦”，但我认为如果有两块代码是耦合的，
那就意味着无法只理解其中一个。
如果<strong>解</strong>耦了它们俩，就可以单独地理解某一块。
这当然很好，因为只有一块与问题相关，
只需将<strong>这一块</strong>加载到你的大脑中而不需要加载另外一块。</p>
<p>对我来说，这是软件架构的关键目标：<strong>最小化在编写代码前需要了解的信息</strong>。</p>
<p>当然，也可以从后期阶段来看。
解耦的另一种定义是：当一块代码有<strong>改动</strong>时，不需要修改另一块代码。
肯定也得修改<strong>一些东西</strong>，但耦合程度越小，改动会波及的范围就越小。</p>
<h2><a class="header" href="#代价" id="代价">代价</a></h2>
<p>听起来很棒，对吧？解耦任何东西，然后就可以像风一样编码。
每个改动都只需修改一两个特定方法，你可以在代码库上行云流水地编写代码。</p>
<p>这就是抽象、模块化、设计模式和软件架构使人们激动不已的原因。
在架构优良的程序上工作是极佳的体验，每个人都希望能更有效率地工作。
好架构能造成生产力上<strong>巨大的</strong>不同。它的影响大得无以复加。</p>
<p>但是，天下没有免费的午餐。好的设计需要汗水和纪律。
每次做出改动或是实现特性，你都需要将它优雅的集成到程序的其他部分。
需要花费大量的努力去管理代码，
使得程序在开发过程中面对千百次变化仍能<strong>保持</strong>它的结构。</p>
<blockquote>
<p>第二部分——管理代码——需要特别关注。
我看到无数程序有优雅的开始，然后死于程序员一遍又一遍添加的“微小黑魔法”。</p>
<p>就像园艺，仅仅种植是不够的，还需要除草和修剪。</p>
</blockquote>
<p>你得考虑程序的哪部分需要解耦，然后再引入抽象。
同样，你需要决定哪部分能支持扩展来应对未来的改动。</p>
<p>人们对这点变得狂热。
他们设想，未来的开发者（或者他们自己）进入代码库，
发现它极为开放，功能强大，只需扩展。
他们想要有“至尊代码应众求”。（译著：这里是“至尊魔戒御众戒”的梗，很遗憾翻译不出来）</p>
<p>但是，事情从这里开始变得棘手。
每当你添加了抽象或者扩展支持，你就是在<strong>赌</strong>以后这里需要灵活性。
你向游戏中添加的代码和复杂性是需要时间来开发、调试和维护的。</p>
<p>如果你赌对了，后来使用了这些代码，那么功夫不负有心人。
但预测未来<strong>很难</strong>，模块化如果最终无益，那就有害。
毕竟，你得处理更多的代码。</p>
<blockquote>
<p>有些人喜欢使用术语“YAGNI”——<a href="http://en.wikipedia.org/wiki/You_aren&#x27;t_gonna_need_it">You aren't gonna need it（你不需要那个）</a>——来对抗这种预测将来需求的强烈冲动。</p>
</blockquote>
<p>当你过分关注这点时，代码库就失控了。
接口和抽象无处不在。插件系统，抽象基类，虚方法，还有各种各样的扩展点，它们遍地都是。</p>
<p>你要消耗无尽的时间回溯所有的脚手架，去找真正做事的代码。
当需要作出改动时，当然，有可能某个接口能帮上忙，但能不能找到就只能听天由命了。
理论上，解耦意味着在修改代码之前需要了解更少的代码，
但抽象层本身也会填满大脑。</p>
<p>像这样的代码库会使得人们<strong>反对</strong>软件架构，特别是设计模式。
人们很容易沉浸在代码中，忽略了目标是要发布<strong>游戏</strong>。
对可扩展性的过分强调使得无数的开发者花费多年时间制作“引擎”，
却没有搞清楚做引擎是<strong>为了什么</strong>。</p>
<h2><a class="header" href="#性能和速度" id="性能和速度">性能和速度</a></h2>
<p>软件架构和抽象有时因损伤性能而被批评，而游戏开发尤甚。
让代码更灵活的许多模式依靠虚拟调度、 接口、 指针、 消息和其他机制，
它们都会加大运行时开销。</p>
<blockquote>
<p>一个有趣的反面例子是 C++中的模板。模板编程有时可以带来没有运行时开销的抽象接口。</p>
<p>这是灵活性的两极。
当写代码调用类中的具体方法时，你就是在<strong>写</strong>的时候指定类——硬编码了调用的是哪个类。
当使用虚方法或接口时，直到<strong>运行</strong>时才知道调用的类。这更加灵活但增加了运行时开销。</p>
<p>模板编程是在两极之间。在<strong>编译时</strong>初始化模板，决定调用哪些类。</p>
</blockquote>
<p>还有一个原因。很多软件架构的目的是使程序更加灵活，作出改动需要更少的付出，编码时对程序有更少的假设。
使用接口可以让代码可与<strong>任何</strong>实现了接口的类交互，而不仅仅是<strong>现在</strong>写的类。
今天，你可以使用<a href="03-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html">观察者模式</a>和<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">消息队列</a>让游戏的两部分相互交流，
以后可以很容易地扩展为三个或四个部分相互交流。</p>
<p>但性能与假设相关。实现优化需要基于确定的限制。
敌人永远不会超过 256 个？好，可以将敌人 ID 编码为一个字节。
只在这种类型上调用方法吗？好，可以做静态调度或内联。
所有实体都是同一类？太好了，可以使用 <a href="07-1%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7.html#%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84">连续数组</a>存储它们。</p>
<p>但这并不意味着灵活性不好！它可以让我们快速改进游戏，
<strong>开发</strong>速度对创造更好的游戏体验来说是很重要的。
没有人能在纸面上构建一个平衡的游戏，哪怕是 Will Wright。这需要迭代和实验。</p>
<p>尝试想法并查看效果的速度越快，能尝试的东西就越多，也就越可能找到有价值的东西。
就算找到正确的机制，你也需要足够的时间调试。
一个微小的不平衡就有可能破坏整个游戏的乐趣。</p>
<p>这里没有普适的答案。
要么在损失一点点性能的前提下，让你的程序更加灵活以便更快地做出原型；
要么就优化性能，损失一些灵活性。</p>
<p>就我个人经验而言，让有趣的游戏变得高效比让高效的游戏变有趣简单得多。
一种折中的办法是保持代码灵活直到确定设计，再去除抽象层来提高性能。</p>
<h2><a class="header" href="#糟糕代码的优势" id="糟糕代码的优势">糟糕代码的优势</a></h2>
<p>下一观点：不同的代码风格各有千秋。
这本书的大部分是关于保持干净可控的代码，所以我坚持应该用<strong>正确</strong>方式写代码，但糟糕的代码也有一定的优势。</p>
<p>编写架构良好的代码需要仔细地思考，这会消耗时间。
在项目的整个周期中<strong>保持</strong>良好的架构需要花费大量的努力。
你需要像露营者处理营地一样小心处理代码库：总是让它比之前更好些。</p>
<p>当你要在项目上花费很久时间的时这是很好的。
但就像早先提到的，游戏设计需要很多实验和探索。
特别是在早期，写一些你<strong>知道</strong>将会扔掉的代码是很普遍的事情。</p>
<p>如果只想试试游戏的某些点子是否可行，
良好的架构就意味着在屏幕上看到和获取反馈之前要消耗很长时间。
如果最后证明这点子不对，那么删除代码时，那些让代码更优雅的工夫就付诸东流了。</p>
<p>原型——一坨勉强拼凑在一起，只能完成某个点子的简单代码——是个完全合理的编程实践。
虽然当你写一次性代码时，<em>必须</em> 保证将来可以扔掉它。
我见过很多次糟糕的经理人在玩这种把戏：</p>
<blockquote>
<p>老板：“嗨，我有些想试试的点子。只要原型，不需要做得很好。你能多快搞定？”</p>
<p>开发者：“额，如果删掉这些部分，不测试，不写文档，允许很多的漏洞，那么几天能给你临时的代码文件。”
老板：“太好了。”</p>
</blockquote>
<p>几天后</p>
<blockquote>
<p>老板：“嘿，原型很棒，你能花上几个小时清理一下然后变为成品吗？”</p>
</blockquote>
<p>你得让人们清楚，可抛弃的代码即使看上去能工作，也不能被<strong>维护</strong>，<em>必须</em> 重写。
如果<strong>有可能</strong>要维护这段代码，就得防御性地好好编写它。</p>
<blockquote>
<p>一个小技巧能保证原型代码不会变成真正用的代码：使用和游戏实现不同的编程语言。
这样，在将其实际应用于游戏中之前必须重写。</p>
</blockquote>
<h2><a class="header" href="#保持平衡" id="保持平衡">保持平衡</a></h2>
<p>有些因素在相互角力：</p>
<ol>
<li>为了在项目的整个生命周期保持其可读性，需要好的架构。</li>
<li>需要更好的运行时性能。</li>
<li>需要让现在想要的特性更快地实现。</li>
</ol>
<blockquote>
<p>有趣的是，这些都是速度：长期开发的速度，游戏运行的速度，和短期开发的速度。</p>
</blockquote>
<p>这些目标至少是部分对立的。
好的架构长期来看提高了生产力，
也意味着每个改动都需要消耗更多努力保持代码整洁。</p>
<p>草就的代码很少是<strong>运行时</strong>最快的。
相反，提升性能需要很多的开发时间。
一旦完成，它就会污染代码库：高度优化的代码不灵活，很难改动。</p>
<p>总有今日事今日毕的压力。但是如果尽可能快地实现特性，
代码库就会充满黑魔法，漏洞和混乱，阻碍未来的产出。</p>
<p>没有简单的答案，只有权衡。
从我收到的邮件看，这伤了很多人的心，特别是那些只是想做个游戏的人。
这似乎是在恐吓，“没有正确的答案，只有不同的错误。”</p>
<p>但对我而言，这让人兴奋！看看任何人们从事的领域，
你总能发现某些相互抵触的限制。无论如何，如果有简单的答案，每个人都会那么做。
一周就能掌握的领域是很无聊的。你从来没有听说过有人讨论挖坑。</p>
<blockquote>
<p>也许你会讨论挖坑；我没有深究这个类比。
可能有挖坑热爱者，挖坑规范，以及一整套亚文化。
我算什么人，能在此大放厥词？</p>
</blockquote>
<p>对我来说，这和游戏有很多相似之处。
国际象棋之类的游戏永远不能被掌握，因为每个棋子都很完美地与其他棋子相平衡。
这意味你可以花费一生探索广阔的可选策略。糟糕的游戏就像井字棋，玩上几遍就会厌倦地退出。</p>
<h2><a class="header" href="#简单" id="简单">简单</a></h2>
<p>最近，我感觉如果有什么能简化这些限制，那就是<strong>简单</strong>。
在我现在的代码中，我努力去写最简单，最直接的解决方案。
你读过这种代码后，完全理解了它在做什么，想不到其他完成的方法。</p>
<p>我的目标是正确获得数据结构和算法（大致是这样的先后），然后再从那里开始。
我发现如果能让事物变得简单，最终的代码就更少，
就意味着改动时有更少的代码载入脑海。</p>
<p>它通常跑的很快，因为没什么开销，也没什么代码需要执行。
（虽然大部分时候事实并非如此。你可以在一小段代码里加入大量的循环和递归。）</p>
<p>但是，注意我并没有说简单的代码需要更少的时间<strong>编写</strong>。
你会这么觉得是因为最终得到了更少的代码，但是好的解决方案不是往代码中注水，而是<strong>蒸干</strong>代码。</p>
<blockquote>
<p>Blaise Pascal 有句著名的信件结尾，“我没时间写得更短。”</p>
<p>另一句名言来自 Antoine de Saint-Exupery：“臻于完美之时，不是加无可加，而是减无可减。”</p>
<p>言归正传，我发现每次重写本书，它就变得更短。有些章节比刚完成时短了 20%。</p>
</blockquote>
<p>我们很少遇到优雅表达的问题，一般反而是一堆用况。
你想要 X 在 Z 情况下做 Y，在 A 情况下做 W，诸如此类。换言之，一长列不同行为。</p>
<p>最节约心血的方法是为每段用况编写一段代码。
看看新手程序员，他们经常这么干：为每种情况编写条件逻辑。</p>
<p>但这一点也不优雅，那种风格的代码遇到一点点没想到的输入就会崩溃。
当我们想象优雅的代码时，想的是<strong>通用</strong>的那一个：
只需要很少的逻辑就可以覆盖整个用况。</p>
<p>找到这样的方法有点像模式识别或者解决谜题。
需要努力去识别散乱的用例下隐藏的规律。
完成时你会感觉好得不能再好。</p>
<h2><a class="header" href="#就快完了" id="就快完了">就快完了</a></h2>
<p>几乎每个人都会跳过介绍章节，所以祝贺你看到这里。
我没有太多东西回报你的耐心，但还有些建议给你，希望对你有用：</p>
<ul>
<li>
<p>抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。</p>
</li>
<li>
<p>在整个开发周期中为性能考虑并做好设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。</p>
</li>
</ul>
<blockquote>
<p>相信我，发布前两个月<strong>不是</strong>开始思考“游戏运行只有 1FPS”这种问题的时候。</p>
</blockquote>
<ul>
<li>
<p>快速地探索游戏的设计空间，但不要跑得太快，在身后留下烂摊子。毕竟你总得回来打扫。</p>
</li>
<li>
<p>如果打算抛弃这段代码，就不要尝试将其写完美。摇滚明星将旅店房间弄得一团糟，因为他们知道明天就走人了。</p>
</li>
<li>
<p>但最重要的是，<strong>如果你想要做出让人享受的东西，那就享受做它的过程。</strong></p>
</li>
</ul>
<h1><a class="header" href="#重返设计模式" id="重返设计模式">重返设计模式</a></h1>
<p>《设计模式：可复用面向对象软件的基础》出版已经二十年了。
除非你比我从业还久，否则《设计模式》已经酝酿成一坛足以饮用的老酒了。
对于像软件行业这样快速发展的行业，它已经是老古董了。
这本书的持久流行证明了设计方法比框架和方法论更经久不衰。</p>
<p>虽然我认为<strong>设计模式</strong>仍然有意义，但在过去几十年我们学到了很多。
在这一部分，我们会遇到 GoF 记载的一些模式。
对于每个模式，我希望能讲些有用有趣的东西。</p>
<p>我认为有些模式被过度使用了(<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例模式</a>），
而另一些被冷落了（<a href="03-1%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html">命令模式</a>）。
有些模式在这里是因为我想探索其在游戏上的特殊应用（<a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a>和<a href="03-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html">观察者模式</a>）。
最后，我认为看看有些模式在更广的编程领域是如何运用的是很有趣的（<a href="03-4%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">原型模式</a>和<a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a>）。</p>
<h2><a class="header" href="#模式" id="模式">模式</a></h2>
<ul>
<li><a href="03-1%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html">命令模式</a></li>
<li><a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a></li>
<li><a href="03-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html">观察者模式</a></li>
<li><a href="03-4%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">原型模式</a></li>
<li><a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例模式</a></li>
<li><a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a></li>
</ul>
<h1><a class="header" href="#命令模式" id="命令模式">命令模式</a></h1>
<p>命令模式是我最喜欢的模式之一。
大多数我写的游戏或者别的什么之类的大型程序，都会在某处用到它。
当在正确的地方使用时，它可以将复杂的代码清理干净。
对于这样一个了不起的模式，不出所料地，GoF 有个深奥的定义：</p>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；
对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>我想你也会觉得这个句子晦涩难懂。
第一，它的比喻难以理解。
在词语可以指代任何事物的狂野软件世界之外，“客户”是一个<strong>人</strong>——那些和你做生意的人。
据我查证，人类不能被“参数化”。</p>
<p>然后，句子余下的部分介绍了可能会使用这个模式的场景。
如果你的场景不在这个列表中，那么这对你就没什么用处。
<strong>我的</strong>命令模式精简定义为：</p>
<blockquote>
<blockquote>
<blockquote>
<p>命令是具现化的方法调用。</p>
</blockquote>
<p>A command is a reified method call.</p>
</blockquote>
<p>“Reify（具现化）”来自于拉丁语“res”，意为“thing”（事物），加上英语后缀“-fy”。
所以它意为“thingify”，没准用“thingify”更合适。</p>
</blockquote>
<p>当然，“精简”往往意味着着“缺少必要信息”，所以这可能没有太大的改善。
让我扩展一下。如果你没有听说过“具现化”的话，它的意思是“实例化，对象化”。
具现化的另外一种解释方式是将某事物作为“第一公民”对待。</p>
<blockquote>
<p>在某些语言中的<strong>反射</strong>允许你在程序运行时命令式地和类型交互。
你可以获得类的类型对象，可以与其交互看看这个类型能做什么。换言之，反射是<strong>具现化类型的系统</strong>。</p>
</blockquote>
<p>两种术语都意味着将<strong>概念</strong>变成<strong>数据</strong>
——一个对象——可以存储在变量中，传给函数。
所以称命令模式为“具现化方法调用”，意思是方法调用被存储在对象中。</p>
<p>这听起来有些像“回调”，“第一公民函数”，“函数指针”，“闭包”，“偏函数”，
取决于你在学哪种语言，事实上大致上是同一个东西。GoF 随后说：</p>
<blockquote>
<p>命令模式是一种回调的面向对象实现。</p>
</blockquote>
<p>这是一种对命令模式更好的解释。</p>
<p>但这些都既抽象又模糊。我喜欢用实际的东西作为章节的开始，不好意思，搞砸了。
作为弥补，从这里开始都是命令模式能出色应用的例子。</p>
<h2><a class="header" href="#配置输入" id="配置输入">配置输入</a></h2>
<p>在每个游戏中都有一块代码读取用户的输入——按钮按下，键盘敲击，鼠标点击，诸如此类。
这块代码会获取用户的输入，然后将其变为游戏中有意义的行为：</p>
<p><img src="https://gpp.tkchu.me/images/command-buttons-one.png" alt="配置输入" /></p>
<p>下面是一种简单的实现：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) lurchIneffectively();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>专家建议：不要太经常地按 B。</p>
</blockquote>
<p>这个函数通常在<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>中每帧调用一次，我确信你可以理解它做了什么。
在我们想将用户的输入和程序行为硬编码在一起时，这段代码可以正常工作，但是许多游戏允许玩家<strong>配置</strong>按键的功能。</p>
<p>为了支持这点，需要将这些对<code>jump()</code>和<code>fireGun()</code>的直接调用转化为可以变换的东西。
“变换”听起来有点像变量干的事，因此我们需要表示游戏行为的<strong>对象</strong>。进入：命令模式。</p>
<p>我们定义了一个基类代表可触发的游戏行为：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>当你有接口只包含一个没有返回值的方法时，很可能你可以使用命令模式。</p>
</blockquote>
<p>然后我们为不同的游戏行为定义相应的子类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class JumpCommand : public Command
{
public:
  virtual void execute() { jump(); }
};

class FireCommand : public Command
{
public:
  virtual void execute() { fireGun(); }
};

// 你知道思路了吧
<span class="boring">}
</span></code></pre></pre>
<p>在代码的输入处理部分，为每个按键存储一个指向命令的指针。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class InputHandler
{
public:
  void handleInput();

  // 绑定命令的方法……

private:
  Command** buttonX_;
  Command** buttonY_;
  Command** buttonA_;
  Command** buttonB_;
};
<span class="boring">}
</span></code></pre></pre>
<p>现在输入处理部分这样处理：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) buttonX_-&gt;execute();
  else if (isPressed(BUTTON_Y)) buttonY_-&gt;execute();
  else if (isPressed(BUTTON_A)) buttonA_-&gt;execute();
  else if (isPressed(BUTTON_B)) buttonB_-&gt;execute();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意在这里没有检测<code>NULL</code>了吗？这假设每个按键都与<strong>某些</strong>命令相连。</p>
<p>如果想支持不做任何事情的按键又不想显式检测<code>NULL</code>，我们可以定义一个命令类，它的<code>execute()</code>什么也不做。
这样，某些按键处理器不必设为<code>NULL</code>，只需指向这个类。这种模式被称为<a href="http://en.wikipedia.org/wiki/Null_Object_pattern">空对象</a>。</p>
</blockquote>
<p>以前每个输入直接调用函数，现在会有一层间接寻址：</p>
<p><img src="https://gpp.tkchu.me/images/command-buttons-two.png" alt="间接寻址" /></p>
<p>这是命令模式的简短介绍。如果你能够看出它的好处，就把这章剩下的部分作为奖励吧。</p>
<h2><a class="header" href="#角色说明" id="角色说明">角色说明</a></h2>
<p>我们刚才定义的类可以在之前的例子上正常工作，但有很大的局限。
问题在于假设了顶层的<code>jump()</code>, <code>fireGun()</code>之类的函数可以找到玩家角色，然后像木偶一样操纵它。</p>
<p>这些假定的耦合限制了这些命令的用处。<code>JumpCommand</code><em>只能</em> 让玩家的角色跳跃。让我们放松这个限制。
不让函数去找它们控制的角色，我们将函数控制的角色对象<strong>传进去</strong>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute(GameActor&amp; actor) = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p>这里的<code>GameActor</code>是代表游戏世界中角色的“游戏对象”类。
我们将其传给<code>execute()</code>，这样命令类的子类就可以调用所选游戏对象上的方法，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class JumpCommand : public Command
{
public:
  virtual void execute(GameActor&amp; actor)
  {
    actor.jump();
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们可以使用这个类让游戏中的任何角色跳来跳去了。
在输入控制部分和在对象上调用命令部分之间，我们还缺了一块代码。
第一，我们修改<code>handleInput()</code>，让它可以<strong>返回</strong>命令：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) return buttonX_;
  if (isPressed(BUTTON_Y)) return buttonY_;
  if (isPressed(BUTTON_A)) return buttonA_;
  if (isPressed(BUTTON_B)) return buttonB_;

  // 没有按下任何按键，就什么也不做
  return NULL;
}
<span class="boring">}
</span></code></pre></pre>
<p>这里不能立即执行，因为还不知道哪个角色会传进来。
这里我们享受了命令是具体调用的好处——<code>延迟</code>到调用执行时再知道。</p>
<p>然后，需要一些接受命令的代码，作用在玩家角色上。像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** command = inputHandler.handleInput();
if (command)
{
  command-&gt;execute(actor);
}
<span class="boring">}
</span></code></pre></pre>
<p>将<code>actor</code>视为玩家角色的引用，它会正确地按着玩家的输入移动，
所以我们赋予了角色和前面例子中相同的行为。
通过在命令和角色间增加了一层重定向，
我们获得了一个灵巧的功能：<em>我们可以让玩家控制游戏中的任何角色，只需向命令传入不同的角色。</em></p>
<p>在实践中，这个特性并不经常使用，但是<strong>经常</strong>会有类似的用例跳出来。
到目前为止，我们只考虑了玩家控制的角色，但是游戏中的其他角色呢？
它们被游戏 AI 控制。我们可以在 AI 和角色之间使用相同的命令模式；AI 代码只需生成<code>Command</code>对象。</p>
<p>在选择命令的 AI 和展现命令的游戏角色间解耦给了我们很大的灵活度。
我们可以对不同的角色使用不同的 AI，或者为了不同的行为而混合 AI。
想要一个更加有攻击性的对手？插入一个更加有攻击性的 AI 为其生成命令。
事实上，我们甚至可以为<strong>玩家角色</strong>加上 AI，
在展示阶段，游戏需要自动演示时，这是很有用的。</p>
<p>把控制角色的命令变为第一公民对象，去除直接方法调用中严厉的束缚。
将其视为命令队列，或者是命令流：</p>
<blockquote>
<p>队列能为你做的更多事情，请看<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">事件队列</a>。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/command-stream.png" alt="一条连接AI到角色的管道" /></p>
<blockquote>
<p>为什么我觉得需要为你画一幅“流”的图像？又是为什么它看上去像是管道？</p>
</blockquote>
<p>一些代码（输入控制器或者 AI）产生一系列命令放入流中。
另一些代码（调度器或者角色自身）调用并消耗命令。
通过在中间加入队列，我们解耦了消费者和生产者。</p>
<blockquote>
<p>如果将这些指令<strong>序列化</strong>，我们可以通过网络流传输它们。
我们可以接受玩家的输入，将其通过网络发送到另外一台机器上，然后重现之。这是网络多人游戏的基础。</p>
</blockquote>
<h2><a class="header" href="#撤销和重做" id="撤销和重做">撤销和重做</a></h2>
<p>最后的这个例子是这种模式最广为人知的使用情况。
如果一个命令对象可以<strong>做</strong>一件事，那么它亦可以<strong>撤销</strong>这件事。
在一些策略游戏中使用撤销，这样你就可以回滚那些你不喜欢的操作。
它是<strong>创造</strong>游戏时<strong>必不可少的</strong>工具。
一个不能撤销误操作导致的错误的编辑器，肯定会让游戏设计师恨你。</p>
<blockquote>
<p>这是经验之谈。</p>
</blockquote>
<p>没有了命令模式，实现撤销非常困难，有了它，就是小菜一碟。
假设我们在制作单人回合制游戏，想让玩家能撤销移动，这样他们就可以集中注意力在策略上而不是猜测上。</p>
<p>我们已经使用了命令来抽象输入控制，所以每个玩家的举动都已经被封装其中。
举个例子，移动一个单位的代码可能如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit** unit, int x, int y)
  : unit_(unit),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    unit_-&gt;moveTo(x_, y_);
  }

private:
  Unit** unit_;
  int x_, y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意这和前面的命令有些许不同。
在前面的例子中，我们需要从修改的角色那里<strong>抽象</strong>命令。
在这个例子中，我们将命令<strong>绑定</strong>到要移动的单位上。
这条命令的实例不是通用的“移动某物”命令；而是游戏回合中特殊的一次移动。</p>
<p>这展现了命令模式应用时的一种情形。
就像之前的例子，指令在某些情形中是可重用的对象，代表了<strong>可执行的事件</strong>。
我们早期的输入控制器将其实现为一个命令对象，然后在按键按下时调用其<code>execute()</code>方法。</p>
<p>这里的命令更加特殊。它们代表了特定时间点能做的特定事件。
这意味着输入控制代码可以在玩家下决定时<strong>创造</strong>一个实例。就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** handleInput()
{
  Unit** unit = getSelectedUnit();

  if (isPressed(BUTTON_UP)) {
    // 向上移动单位
    int destY = unit-&gt;y() - 1;
    return new MoveUnitCommand(unit, unit-&gt;x(), destY);
  }

  if (isPressed(BUTTON_DOWN)) {
    // 向下移动单位
    int destY = unit-&gt;y() + 1;
    return new MoveUnitCommand(unit, unit-&gt;x(), destY);
  }

  // 其他的移动……

  return NULL;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>当然，在像 C++这样没有垃圾回收的语言中，这意味着执行命令的代码也要负责释放内存。</p>
</blockquote>
<p>命令的一次性为我们很快地赢得了一个优点。
为了让指令可被取消，我们为每个类定义另一个需要实现的方法：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
  virtual void undo() = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p><code>undo()</code>方法回滚了<code>execute()</code>方法造成的游戏状态改变。
这里是添加了撤销功能后的移动命令：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit** unit, int x, int y)
  : unit_(unit),
    xBefore_(0),
    yBefore_(0),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    // 保存移动之前的位置
    // 这样之后可以复原。

    xBefore_ = unit_-&gt;x();
    yBefore_ = unit_-&gt;y();

    unit_-&gt;moveTo(x_, y_);
  }

  virtual void undo()
  {
    unit_-&gt;moveTo(xBefore_, yBefore_);
  }

private:
  Unit** unit_;
  int xBefore_, yBefore_;
  int x_, y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意我们为类添加了更多的状态。
当单位移动时，它忘记了它之前是什么样的。
如果我们想要撤销这个移动，我们需要记得单位之前的状态，也就是<code>xBefore_</code>和<code>yBefore_</code>的作用。</p>
<blockquote>
<p>这看上去是<a href="http://en.wikipedia.org/wiki/Memento_pattern">备忘录</a>模式使用的地方，它从来没有有效地工作过。
由于命令趋向于修改对象状态的一小部分，对数据其他部分的快照就是浪费内存。手动内存管理的消耗更小。</p>
<p><a href="http://en.wikipedia.org/wiki/Persistent_data_structure"><strong>持久化数据结构</strong></a>是另一个选项。
使用它，每次修改对象都返回一个新对象，保持原来的对象不变。巧妙的实现下，这些新对象与之前的对象共享数据，所以比克隆整个对象开销更小。</p>
<p>使用持久化数据结构，每条命令都存储了命令执行之前对象的引用，而撤销只是切换回之前的对象。</p>
</blockquote>
<p>为了让玩家撤销移动，我们记录了执行的最后命令。当他们按下<code>control + z</code>时，我们调用命令的<code>undo()</code>方法。
（如果他们已经撤销了，那么就变成了“重做”，我们会再一次执行命令。）</p>
<p>支持多重的撤销也不太难。
我们不单单记录最后一条指令，还要记录指令列表，然后用一个引用指向“当前”的那个。
当玩家执行一条命令，我们将其添加到列表，然后将代表“当前”的指针指向它。</p>
<p><img src="https://gpp.tkchu.me/images/command-undo.png" alt="多重撤销" /></p>
<p>当玩家选择“撤销”，我们撤销现在的命令，将代表当前的指针往后退。
当他们选择“重做”，我们将代表当前的指针往前进，执行该指令。
如果在撤销后选择了新命令，那么清除命令列表中当前的指针所指命令之后的全部命令。</p>
<p>第一次在关卡编辑器中实现这点时，我觉得自己简直就是个天才。
我惊讶于它如此的简明有效。
你需要约束自己，保证每个数据修改都通过命令完成，一旦你做到了，余下的都很简单。</p>
<blockquote>
<p>重做在游戏中并不常见，但重<strong>放</strong>常见。
一种简单的重放实现是记录游戏每帧的状态，这样它可以回放，但那会消耗太多的内存。</p>
<p>相反，很多游戏记录每个实体每帧运行的命令。
为了重放游戏，引擎只需要正常运行游戏，执行之前存储的命令。</p>
</blockquote>
<h2><a class="header" href="#用类还是用函数" id="用类还是用函数">用类还是用函数</a></h2>
<p>早些时候，我说过命令与第一公民函数或者闭包类似，
但是在这里展现的每个例子都是通过类完成的。
如果你更熟悉函数式编程，你也许会疑惑函数都在哪里。</p>
<p>我用这种方式写例子是因为 C++ 对第一公民函数支持非常有限。
函数指针没有状态，函子很奇怪而且仍然需要定义类，
在 C++11 中的 lambda 演算需要大量的人工记忆辅助才能使用。</p>
<p>这并<strong>不是</strong>说你在其他语言中不可以用函数来完成命令模式。
如果你使用的语言支持闭包，不管怎样，快去用它！
在某种程度上说，命令模式是为一些没有闭包的语言模拟闭包。</p>
<blockquote>
<p>我说<strong>某种程度上</strong>是因为，即使是那些支持闭包的语言，为命令建立真正的类或者结构也是很有用的。
如果你的命令拥有多重操作（比如可撤销的命令），将其全部映射到同一函数中并不优雅。</p>
<p>定义一个有字段的真实类能帮助读者理解命令包含了什么数据。
闭包是自动包装状态的完美解决方案，但它们过于自动化而很难看清包装的真正状态有哪些。</p>
</blockquote>
<p>举个例子，如果我们使用 javascript 来写游戏，那么我们可以用这种方式来写让单位移动的命令：</p>
<pre><code class="language-javascript">function makeMoveUnitCommand(unit, x, y) {
  // 这个函数就是命令对象:
  return function() {
    unit.moveTo(x, y);
  };
}
</code></pre>
<p>我们可以通过一对闭包来为撤销提供支持：</p>
<pre><code class="language-javascript">function makeMoveUnitCommand(unit, x, y) {
  var xBefore, yBefore;
  return {
    execute: function() {
      xBefore = unit.x();
      yBefore = unit.y();
      unit.moveTo(x, y);
    },
    undo: function() {
      unit.moveTo(xBefore, yBefore);
    }
  };
}
</code></pre>
<p>如果你习惯了函数式编程风格，这种做法是很自然的。
如果你没有，我希望这章可以帮你了解一些。
对于我而言，命令模式展现了函数式范式在很多问题上的高效性。</p>
<h2><a class="header" href="#参见" id="参见">参见</a></h2>
<ul>
<li>
<p>你最终可能会得到很多不同的命令类。
为了更容易实现这些类，定义一个具体的基类，包含一些能定义行为的高层方法，往往会有帮助。
这将命令的主体<code>execute()</code>转到<a href="05-2%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1.html">子类沙箱</a>中。</p>
</li>
<li>
<p>在上面的例子中，我们明确地指定哪个角色会处理命令。
在某些情况下，特别是当对象模型分层时，也可以不这么简单粗暴。
对象可以响应命令，或者将命令交给它的从属对象。
如果你这样做，你就完成了一个<a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">职责链模式</a>。</p>
</li>
<li>
<p>有些命令是无状态的纯粹行为，比如第一个例子中的<code>JumpCommand</code>。
在这种情况下，有多个实例是在浪费内存，因为所有的实例是等价的。
可以用<a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a>解决。</p>
</li>
</ul>
<blockquote>
<p>你可以将其实现为<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例</a>，但真朋友不会让你用单例。</p>
</blockquote>
<h1><a class="header" href="#享元模式" id="享元模式">享元模式</a></h1>
<p>迷雾散尽，露出了古朴庄严的森林。古老的铁杉，在头顶编成绿色穹顶。
阳光在树叶间破碎成金色顶棚。从树干间远眺，远处的森林渐渐隐去。</p>
<p>这是我们游戏开发者梦想的超凡场景，这样的场景通常由一个模式支撑着，它的名字低调至极：享元模式。</p>
<h2><a class="header" href="#森林" id="森林">森林</a></h2>
<p>用几句话就能描述一片巨大的森林，但是在实时游戏中做这件事就完全是另外一件事了。
当屏幕上需要显示一整个森林时，图形程序员看到的是每秒需要送到 GPU 六十次的百万多边形。</p>
<p>我们讨论的是成千上万的树，每棵都由上千的多边形组成。
就算有足够的<strong>内存</strong>描述森林，渲染的过程中，CPU 到 GPU 的部分也太过繁忙了。</p>
<p>每棵树都有一系列与之相关的位：</p>
<ul>
<li>定义树干，树枝和树叶形状的多边形网格。</li>
<li>树皮和树叶的纹理。</li>
<li>在森林中树的位置和朝向。</li>
<li>大小和色彩之类的调节参数，让每棵树都看起来与众不同。</li>
</ul>
<p>如果用代码表示，那么会得到这样的东西：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Tree
{
private:
  Mesh mesh_;
  Texture bark_;
  Texture leaves_;
  Vector position_;
  double height_;
  double thickness_;
  Color barkTint_;
  Color leafTint_;
};
<span class="boring">}
</span></code></pre></pre>
<p>这是一大堆数据，多边形网格和纹理体积非常大。
描述整个森林的对象在一帧的时间就交给 GPU 实在是太过了。
幸运的是，有一种老办法来处理它。</p>
<p>关键点在于，哪怕森林里有千千万万的树，它们大多数长得一模一样。
它们使用了相同的网格和纹理。
这意味着这些树的实例的大部分字段是<strong>一样的</strong>。</p>
<blockquote>
<p>你要么是疯了，要么是亿万富翁，才能让美术给森林里每棵树建立独立模型。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/flyweight-trees.png" alt="一行树，每棵都有自己的网格、纹理、树叶，调节参数和位置朝向。" /></p>
<blockquote>
<p>注意每一棵树的小盒子中的东西都是一样的。</p>
</blockquote>
<p>我们可以通过显式地将对象切为两部分来更加明确地模拟。
第一，将树共有的数据拿出来分离到另一个类中：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class TreeModel
{
private:
  Mesh mesh_;
  Texture bark_;
  Texture leaves_;
};
<span class="boring">}
</span></code></pre></pre>
<p>游戏只需要一个这种类，
因为没有必要在内存中把相同的网格和纹理重复一千遍。
游戏世界中每个树的实例只需有一个对这个共享<code>TreeModel</code>的<strong>引用</strong>。
留在<code>Tree</code>中的是那些实例相关的数据：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Tree
{
private:
  TreeModel* model_;

  Vector position_;
  double height_;
  double thickness_;
  Color barkTint_;
  Color leafTint_;
};
<span class="boring">}
</span></code></pre></pre>
<p>你可以将其想象成这样：</p>
<p><img src="https://gpp.tkchu.me/images/flyweight-tree-model.png" alt="一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。" /></p>
<blockquote>
<p>这有点像<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>模式。
两者都涉及将一个类中的状态委托给另外的类，来达到在不同实例间分享状态的目的。
但是，这两种模式背后的意图不同。</p>
<p>使用类型对象，目标是通过将类型引入对象模型，减少需要定义的类。
伴随而来的内容分享是额外的好处。享元模式则是纯粹的为了效率。</p>
</blockquote>
<p>把所有的东西都存在主存里没什么问题，但是这对渲染也毫无帮助。
在森林到屏幕上之前，它得先到 GPU。我们需要用显卡可以识别的方式共享数据。</p>
<h2><a class="header" href="#一千个实例" id="一千个实例">一千个实例</a></h2>
<p>为了减少需要推送到 GPU 的数据量，我们想把共享的数据——<code>TreeModel</code>——只发送<strong>一次</strong>。
然后，我们分别发送每个树独特的数据——位置，颜色，大小。
最后，我们告诉 GPU，“使用同一模型渲染每个实例”。</p>
<p>幸运的是，今日的图形接口和显卡正好支持这一点。
这些细节很繁琐且超出了这部书的范围，但是 Direct3D 和 OpenGL 都可以做<a href="http://en.wikipedia.org/wiki/Geometry_instancing"><em>实例渲染</em></a>。</p>
<p>在这些 API 中，你需要提供两部分数据流。
第一部分是一块需要渲染多次的共同数据——在例子中是树的网格和纹理。
第二部分是实例的列表以及绘制第一部分时需要使用的参数。
然后调用一次渲染，绘制整个森林。</p>
<blockquote>
<p>这个 API 是由显卡直接实现的，意味着享元模式也许是唯一的有硬件支持的 GoF 设计模式。</p>
</blockquote>
<h2><a class="header" href="#享元" id="享元">享元</a></h2>
<p>好了，我们已经看了一个具体的例子，下面我介绍模式的通用部分。
享元，就像它的名字暗示的那样，
当你需要共享类时使用，通常是因为你有太多这种类了。</p>
<p>实例渲染时，每棵树通过总线送到 GPU 消耗的更多是<strong>时间</strong>而非内存，但是基本要点是一样的。</p>
<p>这个模式通过将对象的数据分为两种来解决这个问题。
第一种数据没有特定指明是哪个对象的<strong>实例</strong>，因此可以在它们间分享。
Gof 称之为<strong>固有</strong>状态，但是我更喜欢将其视为“上下文无关”部分。
在这里的例子中，是树的网格和纹理。</p>
<p>数据的剩余部分是<strong>变化</strong>状态，那些每个实例独一无二的东西。
在这个例子中，是每棵树的位置，拉伸和颜色。
就像这里的示例代码块一样，这种模式通过在每个对象出现时共享一份固有状态来节约内存。</p>
<p>就目前而言，这看上去像是基础的资源共享，很难被称为一种模式。
部分原因是在这个例子中，我们可以为共享状态划出一个清晰的<strong>身份</strong>：<code>TreeModel</code>。</p>
<p>我发现，当共享对象没有有效定义的实体时，使用这种模式就不那么明显（使用它也就越发显得精明）。
在那些情况下，这看上去是一个对象被魔术般地同时分配到了多个地方。
让我展示给你另外一个例子。</p>
<h2><a class="header" href="#扎根之所" id="扎根之所">扎根之所</a></h2>
<p>这些树长出来的地方也需要在游戏中表示。
这里可能有草，泥土，丘陵，湖泊，河流，以及其它任何你可以想到的地形。
我们<strong>基于区块</strong>建立地表：世界的表面被划分为由微小区块组成的巨大网格。
每个区块都由一种地形覆盖。</p>
<p>每种地形类型都有一系列特性会影响游戏玩法：</p>
<ul>
<li>决定了玩家能够多快地穿过它的移动开销。</li>
<li>表明能否用船穿过的水域标识。</li>
<li>用来渲染它的纹理。</li>
</ul>
<p>因为我们游戏程序员偏执于效率，我们不会在每个区块中保存这些状态。
相反，一个通用的方式是为每种地形使用一个枚举。</p>
<blockquote>
<p>再怎么样，我们也已经从树的例子吸取教训了。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Terrain
{
  TERRAIN_GRASS,
  TERRAIN_HILL,
  TERRAIN_RIVER
  // 其他地形
};
<span class="boring">}
</span></code></pre></pre>
<p>然后，世界管理巨大的网格：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class World
{
private:
  Terrain tiles_[WIDTH][HEIGHT];
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里我使用嵌套数组存储 2D 网格。
在 C/C++中这样是很有效率的，因为它会将所有元素打包在一起。
在 Java 或者其他内存管理语言中，那样做会实际给你一个数组，其中每个元素都是对数组的列的<strong>引用</strong>，那就不像你想要的那样内存友好了。</p>
<p>反正，隐藏 2D 网格数据结构背后的实现细节，能使代码更好地工作。
我这里这样做只是为了让其保持简单。</p>
</blockquote>
<p>为了获得区块的实际有用的数据，我们做了一些这样的事情：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>int World::getMovementCost(int x, int y)
{
  switch (tiles_[x][y])
  {
    case TERRAIN_GRASS: return 1;
    case TERRAIN_HILL:  return 3;
    case TERRAIN_RIVER: return 2;
      // 其他地形……
  }
}

bool World::isWater(int x, int y)
{
  switch (tiles_[x][y])
  {
    case TERRAIN_GRASS: return false;
    case TERRAIN_HILL:  return false;
    case TERRAIN_RIVER: return true;
      // 其他地形……
  }
}
你知道我的意思了。这可行，但是我觉
<span class="boring">}
</span></code></pre></pre>
<p>你知道我的意思了。这可行，但是我觉得很丑。
移动开销和水域标识是区块的<strong>数据</strong>，但在这里它们散布在代码中。
更糟的是，简单地形的数据被众多方法拆开了。
如果能够将这些包裹起来就好了。毕竟，那是我们设计对象的目的。</p>
<p>如果我们有实际的地形<strong>类</strong>就好了，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Terrain
{
public:
  Terrain(int movementCost,
          bool isWater,
          Texture texture)
  : movementCost_(movementCost),
    isWater_(isWater),
    texture_(texture)
  {}

  int getMovementCost() const { return movementCost_; }
  bool isWater() const { return isWater_; }
  const Texture&amp; getTexture() const { return texture_; }

private:
  int movementCost_;
  bool isWater_;
  Texture texture_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>你会注意这里所有的方法都是<code>const</code>。这不是巧合。
由于同一对象在多处引用，如果你修改了它，改变会同时在多个地方出现。</p>
<p>这也许不是你想要的。
通过分享对象来节约内存的这种优化，不应该影响到应用的显性行为。
因此，享元对象几乎总是不可变的。</p>
</blockquote>
<p>但是我们不想为每个区块都保存一个实例。
如果你看看这个类内部，你会发现里面实际上<strong>什么也没有</strong>，
唯一特别的是区块在<strong>哪里</strong>。
用享元的术语讲，区块的<strong>所有</strong>状态都是“固有的”或者说“上下文无关的”。</p>
<p>鉴于此，我们没有必要保存多个同种地形类型。
地面上的草区块两两无异。
我们不用地形区块对象枚举构成世界网格，而是用<code>Terrain</code>对象<strong>指针</strong>组成网格：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class World
{
private:
  Terrain* tiles_[WIDTH][HEIGHT];

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>每个相同地形的区块会指向相同的地形实例。</p>
<p><img src="https://gpp.tkchu.me/images/flyweight-tiles.png" alt="一行区块，每个区块指向共享的草、河、山丘对象。" /></p>
<p>由于地形实例在很多地方使用，如果你想要动态分配，它们的生命周期会有点复杂。
因此，我们直接在游戏世界中存储它们。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class World
{
public:
  World()
  : grassTerrain_(1, false, GRASS_TEXTURE),
    hillTerrain_(3, false, HILL_TEXTURE),
    riverTerrain_(2, true, RIVER_TEXTURE)
  {}

private:
  Terrain grassTerrain_;
  Terrain hillTerrain_;
  Terrain riverTerrain_;

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>然后我们可以像这样来描绘地面：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void World::generateTerrain()
{
  // 将地面填满草皮.
  for (int x = 0; x &lt; WIDTH; x++)
  {
    for (int y = 0; y &lt; HEIGHT; y++)
    {
      // 加入一些丘陵
      if (random(10) == 0)
      {
        tiles_[x][y] = &amp;hillTerrain_;
      }
      else
      {
        tiles_[x][y] = &amp;grassTerrain_;
      }
    }
  }

  // 放置河流
  int x = random(WIDTH);
  for (int y = 0; y &lt; HEIGHT; y++) {
    tiles_[x][y] = &amp;riverTerrain_;
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>我承认这不是世界上最好的地形生成算法。</p>
</blockquote>
<p>现在不需要<code>World</code>中的方法来接触地形属性，我们可以直接暴露出<code>Terrain</code>对象。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const Terrain&amp; World::getTile(int x, int y) const
{
  return *tiles_[x][y];
}
<span class="boring">}
</span></code></pre></pre>
<p>用这种方式，<code>World</code>不再与各种地形的细节耦合。
如果你想要某一区块的属性，可直接从那个对象获得：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>int cost = world.getTile(2, 3).getMovementCost();
<span class="boring">}
</span></code></pre></pre>
<p>我们回到了操作实体对象的 API，几乎没有额外开销——指针通常不比枚举大。</p>
<h2><a class="header" href="#性能如何" id="性能如何">性能如何</a></h2>
<p>我在这里说几乎，是因为性能偏执狂肯定会想要知道它和枚举比起来如何。
通过解引用指针获取地形需要一次间接跳转。
为了获得移动开销这样的地形数据，你首先需要跟着网格中的指针找到地形对象，
然后再找到移动开销。跟踪这样的指针会导致缓存不命中，降低运行速度。</p>
<blockquote>
<p>需要更多指针追逐和缓存不命中的相关信息，看看<a href="07-1%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7.html">数据局部性</a>这章。</p>
</blockquote>
<p>就像往常一样，优化的金科玉律是<strong>需求优先</strong>。
现代计算机硬件过于复杂，性能只是游戏的一个考虑方面。
在我这章做的测试中，享元较枚举没有什么性能上的损失。
享元实际上明显更快。但是这完全取决于内存中的事物是如何排列的。</p>
<p>我<strong>可以</strong>自信地说使用享元对象不会搞到不可收拾。
它给了你面向对象的优势，而且没有产生一堆对象。
如果你创建了一个枚举，又在它上面做了很多分支跳转，考虑一下这个模式吧。
如果你担心性能，那么至少在把代码编程为难以维护的风格之前先做些性能分析。</p>
<h2><a class="header" href="#参见-1" id="参见-1">参见</a></h2>
<ul>
<li>
<p>在区块的例子中，我们只是为每种地形创建一个实例然后存储在<code>World</code>中。
这也许能更好找到和重用这些实例。
但是在多数情况下，你不会在一开始就创建<strong>所有</strong>享元。</p>
<p>如果你不能预料哪些是实际上需要的，最好在需要时才创建。
为了保持共享的优势，当你需要一个时，首先看看是否已经创建了一个相同的实例。
如果确实如此，那么只需返回那个实例。</p>
<p>这通常意味需要将构造函数封装在查询对象是否存在的接口之后。<br />
像这样隐藏构造指令是<a href="http://en.wikipedia.org/wiki/Factory_method_pattern">工厂方法</a>的一个例子。</p>
</li>
<li>
<p>为了返回一个早先创建的享元，需要追踪那些已经实例化的对象池。<br />
正如其名，这意味着<a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池</a>是存储它们的好地方。</p>
</li>
<li>
<p>当使用<a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a>时，
经常会出现一些没有任何特定字段的“状态对象”。
这个状态的标识和方法都很有用。
在这种情况下，你可以使用这个模式，然后在不同的状态机上使用相同的对象实例。</p>
</li>
</ul>
<h1><a class="header" href="#观察者模式" id="观察者模式">观察者模式</a></h1>
<p>随便打开电脑中的一个应用，很有可能它就使用了<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC 架构</a>，而究其根本，是因为观察者模式。
观察者模式应用广泛，Java 甚至将其放到了核心库之中（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Observer.html"><code>java.util.Observer</code></a>），而 C#直接将其嵌入了<strong>语法</strong>（<a href="http://msdn.microsoft.com/en-us/library/8627sbea.aspx"><code>event</code></a>关键字）。</p>
<blockquote>
<p>就像软件中的很多东西，MVC 是 Smalltalkers 在七十年代创造的。
Lisp 程序员也许会说其实是他们在六十年代发明的，但是他们懒得记下来。</p>
</blockquote>
<p>观察者模式是应用最广泛和最广为人知的 GoF 模式，但是游戏开发世界与世隔绝，
所以对你来说，它也许是全新的。
假设你与世隔绝，让我给你举个形象的例子。</p>
<h2><a class="header" href="#成就解锁" id="成就解锁">成就解锁</a></h2>
<p>假设我们向游戏中添加了成就系统。
它存储了玩家可以完成的各种各样的成就，比如“杀死 1000 只猴子恶魔”，“从桥上掉下去”，或者“一命通关”。</p>
<blockquote>
<p><img src="https://gpp.tkchu.me/images/observer-weasel-wielder.png" alt="成就：一无所成" /></p>
<p>我发誓画的这个没有第二个意思，(笑。</p>
</blockquote>
<p>要实现这样一个包含各种行为来解锁成就的系统是很有技巧的。
如果我们不够小心，成就系统会缠绕在代码库的每个黑暗角落。
当然，“从桥上掉落”和物理引擎相关，
但我们并不想看到在处理撞击代码的线性代数时，
有个对<code>unlockFallOffBridge()</code>的调用是不？</p>
<blockquote>
<p>这只是随口一说。<br />
有自尊的物理程序员绝不会允许像<strong>游戏玩法</strong>这样的平凡之物玷污他们优美的算式。</p>
</blockquote>
<p>我们喜欢的是，照旧，让关注游戏一部分的所有代码集成到一块。
挑战在于，成就在游戏的不同层面被触发。怎么解耦成就系统和其他部分呢？</p>
<p>这就是观察者模式出现的原因。
这让代码宣称有趣的事情发生了，<em>而不必关心到底是谁接受了通知。</em></p>
<p>举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。
为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。
相反，可以这样做：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Physics::updateEntity(Entity&amp; entity)
{
  bool wasOnSurface = entity.isOnSurface();
  entity.accelerate(GRAVITY);
  entity.update();
  if (wasOnSurface &amp;&amp; !entity.isOnSurface())
  {
    notify(entity, EVENT_START_FALL);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>它做的就是声称，“额，我不知道有谁感兴趣，但是这个东西刚刚掉下去了。做你想做的事吧。”</p>
<blockquote>
<p>物理引擎确实决定了要发送什么通知，所以这并没有完全解耦。但在架构这个领域，通常只能让系统变得<strong>更好</strong>，而不是<strong>完美</strong>。</p>
</blockquote>
<p>成就系统注册它自己为观察者，这样无论何时物理代码发送通知，成就系统都能收到。
它可以检查掉落的物体是不是我们的失足英雄，
他之前有没有做过这种不愉快的与桥的经典力学遭遇。
如果满足条件，就伴着礼花和炫光解锁合适的成就，而这些都无需牵扯到物理代码。</p>
<p>事实上，我们可以改变成就的集合或者删除整个成就系统，而不必修改物理引擎。
它仍然会发送它的通知，哪怕实际没有东西接收。</p>
<blockquote>
<p>当然，如果我们<strong>永久</strong>移除成就，没有任何东西需要物理引擎的通知，
我们也同样可以移除通知代码。但是在游戏的演进中，最好保持这里的灵活性。</p>
</blockquote>
<h2><a class="header" href="#它如何运作" id="它如何运作">它如何运作</a></h2>
<p>如果你还不知道如何实现这个模式，你可能可以从之前的描述中猜到，但是为了减轻你的负担，我还是过一遍代码吧。</p>
<h3><a class="header" href="#观察者" id="观察者">观察者</a></h3>
<p>我们从那个需要知道别的对象做了什么事的类开始。
这些好打听的对象用如下接口定义：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Observer
{
public:
  virtual ~Observer() {}
  virtual void onNotify(const Entity&amp; entity, Event event) = 0;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>onNotify()</code>的参数取决于你。这就是为什么是观察者<strong>模式</strong>，
而不是“可以粘贴到游戏中的真实代码”。
典型的参数是发送通知的对象和一个装入其他细节的“数据”参数。</p>
<p>如果你用泛型或者模板编程，你可能会在这里使用它们，但是根据你的特殊用况裁剪它们也很好。
这里，我将其硬编码为接受一个游戏实体和一个描述发生了什么的枚举。</p>
</blockquote>
<p>任何实现了这个的具体类就成为了观察者。
在我们的例子中，是成就系统，所以我们可以像这样实现：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Achievements : public Observer
{
public:
  virtual void onNotify(const Entity&amp; entity, Event event)
  {
    switch (event)
    {
    case EVENT_ENTITY_FELL:
      if (entity.isHero() &amp;&amp; heroIsOnBridge_)
      {
        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
      }
      break;

      // 处理其他事件，更新heroIsOnBridge_变量……
    }
  }

private:
  void unlock(Achievement achievement)
  {
    // 如果还没有解锁，那就解锁成就……
  }

  bool heroIsOnBridge_;
};
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#被观察者" id="被观察者">被观察者</a></h3>
<p>被观察的对象拥有通知的方法函数，用 GoF 的说法，那些对象被称为“主题”。
它有两个任务。首先，它有一个列表，保存默默等它通知的观察者：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
private:
  Observer* observers_[MAX_OBSERVERS];
  int numObservers_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>在真实代码中，你会使用动态大小的集合而不是一个定长数组。
在这里，我使用这种最基础的形式是为了那些不了解 C++标准库的人们。</p>
</blockquote>
<p>重点是被观察者暴露了<strong>公开的</strong>API 来修改这个列表：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
public:
  void addObserver(Observer* observer)
  {
    // 添加到数组中……
  }

  void removeObserver(Observer* observer)
  {
    // 从数组中移除……
  }

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>这就允许了外界代码控制谁接收通知。
被观察者与观察者交流，但是不与它们<strong>耦合</strong>。
在我们的例子中，没有一行物理代码会提及成就。
但它仍然可以与成就系统交流。这就是这个模式的聪慧之处。</p>
<p>被观察者有一<strong>列表</strong>观察者而不是单个观察者也是很重要的。
这保证了观察者不会相互干扰。
举个例子，假设音频引擎也需要观察坠落事件来播放合适的音乐。
如果客体只支持单个观察者，当音频引擎注册时，就会<strong>取消</strong>成就系统的注册。</p>
<p>这意味着这两个系统需要相互交互——而且是用一种极其糟糕的方式，
第二个注册时会使第一个的注册失效。
支持一列表的观察者保证了每个观察者都是被独立处理的。
就它们各自的视角来看，自己是这世界上唯一看着被观察者的。</p>
<p>被观察者的剩余任务就是发送通知：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
protected:
  void notify(const Entity&amp; entity, Event event)
  {
    for (int i = 0; i &lt; numObservers_; i++)
    {
      observers_[i]-&gt;onNotify(entity, event);
    }
  }

  // 其他代码…………
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意，代码假设了观察者不会在它们的<code>onNotify()</code>方法中修改观察者列表。
更加可靠的实现方法会阻止或优雅地处理这样的并发修改。</p>
</blockquote>
<h3><a class="header" href="#可被观察的物理系统" id="可被观察的物理系统">可被观察的物理系统</a></h3>
<p>现在，我们只需要给物理引擎和这些挂钩，这样它可以发送消息，
成就系统可以和引擎连线来接受消息。
我们按照传统的<strong>设计模式</strong>方法实现，继承<code>Subject</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Physics : public Subject
{
public:
  void updateEntity(Entity&amp; entity);
};
<span class="boring">}
</span></code></pre></pre>
<p>这让我们将<code>notify()</code>实现为了<code>Subject</code>内的保护方法。
这样派生的物理引擎类可以调用并发送通知，但是外部的代码不行。
同时，<code>addObserver()</code>和<code>removeObserver()</code>是公开的，
所以任何可以接触物理引擎的东西都可以观察它。</p>
<blockquote>
<p>在真实代码中，我会避免使用这里的继承。
相反，我会让<code>Physics</code> <em>有</em> 一个<code>Subject</code>的实例。
不再是观察物理引擎本身，被观察的会是独立的“下落事件”对象。
观察者可以用像这样注册它们自己：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>physics.entityFell()
   .addObserver(this);

<span class="boring">}
</span></code></pre></pre>
<p>对我而言，这是“观察者”系统与“事件”系统的不同之处。
使用前者，你观察<strong>做了有趣事情的事物</strong>。
使用后者，你观察的对象代表了<strong>发生的有趣事情</strong>。</p>
</blockquote>
<p>现在，当物理引擎做了些值得关注的事情，它调用<code>notify()</code>，就像之前的例子。
它遍历了观察者列表，通知所有观察者。</p>
<p><img src="https://gpp.tkchu.me/images/observer-list.png" alt="被观察者包含一列表观察者的指针。前两个指向成就和音频系统。" /></p>
<p>很简单，对吧？只要一个类管理一列表指向接口实例的指针。
难以置信的是，如此直观的东西是无数程序和应用框架交流的主心骨。</p>
<p>观察者模式不是完美无缺的。当我问其他程序员怎么看，他们提出了一些抱怨。
让我们看看可以做些什么来处理这些抱怨。</p>
<h2><a class="header" href="#太慢了" id="太慢了">太慢了</a></h2>
<p>我经常听到这点，通常是从那些不知道模式具体细节的程序员那里。
他们有一种假设，任何东西只要沾到了“设计模式”，那么一定包含了一堆类，跳转和浪费 CPU 循环其他行为。</p>
<p>观察者模式的名声特别坏，一些坏名声的事物与它如影随形，
比如“事件”，“消息”，甚至“数据绑定”。
其中的一些系统<strong>确实会</strong>慢。（通常是故意的，出于好的意图）。
他们使用队列，或者为每个通知动态分配内存。</p>
<blockquote>
<p>这就是为什么我认为设计模式文档化很重要。
当我们没有统一的术语，我们就失去了简洁明确表达的能力。
你说“观察者”，我以为是“事件”，他以为是“消息”，
因为没人花时间记下差异，也没人阅读。</p>
<p>而那就是在这本书中我要做的。
本书中也有一章关于事件和消息：<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">事件队列</a>.</p>
</blockquote>
<p>现在你看到了模式是如何真正被实现的，
你知道事实并不如他们所想的这样。
发送通知只需简单地遍历列表，调用一些虚方法。
是的，这比静态调用慢<strong>一点</strong>，除非是性能攸关的代码，否则这点消耗都是微不足道的。</p>
<p>我发现这个模式在代码性能瓶颈以外的地方能有很好的应用，
那些你可以承担动态分配消耗的地方。
除那以外，使用它几乎毫无限制。
我们不必为消息分配对象，也无需使用队列。这里只多了一个用在同步方法调用上的额外跳转。</p>
<h3><a class="header" href="#太快" id="太快">太<strong>快</strong></a></h3>
<p>事实上，你得小心，观察者模式<strong>是</strong>同步的。
被观察者直接调用了观察者，这意味着直到所有观察者的通知方法返回后，
被观察者才会继续自己的工作。观察者会阻塞被观察者的运行。</p>
<p>这听起来很疯狂，但在实践中，这可不是世界末日。
这只是值得注意的事情。
UI 程序员——那些使用基于事件的编程的程序员已经这么干了很多年了——有句经典名言：</p>
<blockquote>
<blockquote>
<blockquote>
<p>“远离 UI 线程”。</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果要对事件同步响应，你需要完成响应，尽可能快地返回，这样 UI 就不会锁死。
当你有耗时的操作要执行时，将这些操作推到另一个线程或工作队列中去。</p>
<p>你需要小心地在观察者中混合线程和锁。
如果观察者试图获得被观察者拥有的锁，游戏就进入死锁了。
在多线程引擎中，你最好使用<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">事件队列</a>来做异步通信。</p>
<h2><a class="header" href="#它做了太多动态分配" id="它做了太多动态分配">“它做了太多动态分配”</a></h2>
<p>整个程序员社区——包括很多游戏开发者——转向了拥有垃圾回收机制的语言，
动态分配今昔非比。
但在像游戏这样性能攸关的软件中，哪怕是在有垃圾回收机制的语言，内存分配也依然重要。
动态分配需要时间，回收内存也需要时间，哪怕是自动运行的。</p>
<blockquote>
<p>很多游戏开发者不怎么担心分配,但很担心<strong>分页</strong>。
当游戏需要不崩溃地连续运行多日来获得发售资格，不断增加的分页堆会影响游戏的发售。</p>
</blockquote>
<p><a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池模式</a>一章介绍了避免这点的常用技术，以及更多其他细节。</p>
<p>在上面的示例代码中，我使用的是定长数组，因为我想尽可能保证简单。
在真实的项目中中，观察者列表随着观察者的添加和删除而动态地增长和缩短。
这种内存的分配吓坏了一些人。</p>
<p>当然，第一件需要注意的事情是只在观察者加入时分配内存。
<strong>发送</strong>通知无需内存分配——只需一个方法调用。
如果你在游戏一开始就加入观察者而不乱动它们，分配的总量是很小的。</p>
<p>如果这仍然困扰你，我会介绍一种无需任何动态分配的方式来增加和删除观察者。</p>
<h3><a class="header" href="#链式观察者" id="链式观察者">链式观察者</a></h3>
<p>我们现在看到的所有代码中，<code>Subject</code>拥有一列指针指向观察它的<code>Observer</code>。
<code>Observer</code>类本身没有对这个列表的引用。
它是纯粹的虚接口。优先使用接口，而不是有状态的具体类，这大体上是一件好事。</p>
<p>但是如果我们<strong>确实</strong>愿意在<code>Observer</code>中放一些状态，
我们可以将观察者的列表分布到<strong>观察者自己</strong>中来解决动态分配问题。
不是被观察者保留一列表分散的指针，观察者对象本身成为了链表中的一部分：</p>
<p><img src="https://gpp.tkchu.me/images/observer-linked.png" alt="一个观察者的列表。每个都有一个next_字段指向下一个。被观察者有一个head_字段指向首个观察者。" /></p>
<p>为了实现这一点，我们首先要摆脱<code>Subject</code>中的数组，然后用链表头部的指针取而代之：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
  Subject()
  : head_(NULL)
  {}

  // 方法……
private:
  Observer* head_;
};
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们在<code>Observer</code>中添加指向链表中下一观察者的指针。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Observer
{
  friend class Subject;

public:
  Observer()
  : next_(NULL)
  {}

  // 其他代码……
private:
  Observer* next_;
};
<span class="boring">}
</span></code></pre></pre>
<p>这里我们也让<code>Subject</code>成为了友类。
被观察者拥有增删观察者的 API，但是现在链表在<code>Observer</code>内部管理。
最简单的实现办法就是让被观察者类成为友类。</p>
<p>注册一个新观察者就是将其连到链表中。我们用更简单的实现方法，将其插到开头：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Subject::addObserver(Observer* observer)
{
  observer-&gt;next_ = head_;
  head_ = observer;
}
<span class="boring">}
</span></code></pre></pre>
<p>另一个选项是将其添加到链表的末尾。这么做增加了一定的复杂性。
<code>Subject</code>要么遍历整个链表来找到尾部，要么保留一个单独<code>tail_</code>指针指向最后一个节点。</p>
<p>加在在列表的头部很简单，但也有另一副作用。
当我们遍历列表给每个观察者发送一个通知，
最<strong>新</strong>注册的观察者最<strong>先</strong>接到通知。
所以如果以 A，B，C 的顺序来注册观察者，它们会以 C，B，A 的顺序接到通知。</p>
<p>理论上，这种还是那种方式没什么差别。
在好的观察者设计中，观察同一被观察者的两个观察者互相之间不该有任何顺序相关。
如果顺序<strong>确实</strong>有影响，这意味着这两个观察者有一些微妙的耦合，最终会害了你。</p>
<p>让我们完成删除操作：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Subject::removeObserver(Observer* observer)
{
  if (head_ == observer)
  {
    head_ = observer-&gt;next_;
    observer-&gt;next_ = NULL;
    return;
  }

  Observer* current = head_;
  while (current != NULL)
  {
    if (current-&gt;next_ == observer)
    {
      current-&gt;next_ = observer-&gt;next_;
      observer-&gt;next_ = NULL;
      return;
    }

    current = current-&gt;next_;
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>如你所见，从链表移除一个节点通常需要处理一些丑陋的特殊情况，应对头节点。
还可以使用指针的指针，实现一个更优雅的方案。</p>
<p>我在这里没有那么做，是因为半数看到这个方案的人都迷糊了。
但这是一个很值得做的练习：它能帮助你深入思考指针。</p>
</blockquote>
<p>因为使用的是链表，所以我们得遍历它才能找到要删除的观察者。
如果我们使用普通的数组，也得做相同的事。
如果我们使用<strong>双向</strong>链表，每个观察者都有指向前面和后面的指针，
就可以用常量时间移除观察者。在实际项目中，我会这样做。</p>
<p>剩下的事情只有发送通知了，这和遍历列表同样简单；</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Subject::notify(const Entity&amp; entity, Event event)
{
  Observer* observer = head_;
  while (observer != NULL)
  {
    observer-&gt;onNotify(entity, event);
    observer = observer-&gt;next_;
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里，我们遍历了整个链表，通知了其中每一个观察者。
这保证了所有的观察者相互独立并有同样的优先级。</p>
<p>我们可以这样实现，当观察者接到通知，它返回了一个标识，表明被观察者是否应该继续遍历列表。
如果这样做，你就接近了<a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">职责链模式</a>。</p>
</blockquote>
<p>不差嘛，对吧？被观察者现在想有多少观察者就有多少观察者，无需动态内存。
注册和取消注册就像使用简单数组一样快。
但是，我们牺牲了一些小小的功能特性。</p>
<p>由于我们使用观察者对象作为链表节点，这暗示它只能存在于一个观察者链表中。
换言之，一个观察者一次只能观察一个被观察者。
在传统的实现中，每个被观察者有独立的列表，一个观察者同时可以存在于多个列表中。</p>
<p>你也许可以接受这一限制。
通常是一个<strong>被观察者</strong>有多个<strong>观察者</strong>，反过来就很少见了。
如果这<strong>真是</strong>一个问题，这里还有一种不必使用动态分配的解决方案。
详细介绍的话，这章就太长了，但我会大致描述一下，其余的你可以自行填补……</p>
<h3><a class="header" href="#链表节点池" id="链表节点池">链表节点池</a></h3>
<p>就像之前，每个被观察者有一链表的观察者。
但是，这些链表节点不是观察者本身。
相反，它们是分散的小“链表节点”对象，
包含了指向观察者的指针和指向链表下一节点的指针。</p>
<p><img src="https://gpp.tkchu.me/images/observer-nodes.png" alt="一链表的节点。每个节点都有一个observer_字段指向观察者，一个next_字段指向列表中的下一个节点。被观察者的head_字段指向第一个节点。" /></p>
<p>由于多个节点可以指向同一观察者，这就意味着观察者可以同时在超过多个被观察者的列表中。
我们可以同时观察多个对象了。</p>
<blockquote>
<p>链表有两种风格。学校教授的那种，节点对象包含数据。
在我们之前的观察者链表的例子中，是另一种：<em>数据</em>（这个例子中是观察者）包含了<strong>节点</strong>（<code>next_</code>指针）。</p>
<p>后者的风格被称为“侵入式”链表，因为在对象内部使用链表侵入了对象本身的定义。
侵入式链表灵活性更小，但如我们所见，也更有效率。
在 Linux 核心这样的地方这种风格很流行。</p>
</blockquote>
<p>避免动态分配的方法很简单：由于这些节点都是同样大小和类型，
可以预先在<a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池</a>中分配它们。
这样你只需处理固定大小的列表节点，可以随你所需使用和重用，
而无需牵扯到真正的内存分配器。</p>
<h2><a class="header" href="#剩余的问题" id="剩余的问题">剩余的问题</a></h2>
<p>我认为该模式将人们吓阻的三个主要问题已经被搞定了。
它简单，快速，对内存管理友好。
但是这意味着你总该使用观察者吗？</p>
<p>现在，这是另一个的问题。
就像所有的设计模式，观察者模式不是万能药。
哪怕可以正确高效地的实现，它也不一定是好的解决方案。
设计模式声名狼藉的原因之一就是人们将好模式用在错误的问题上，得到了糟糕的结果。</p>
<p>还有两个挑战，一个是关于技术，另一个更偏向于可维护性。
我们先处理关于技术的挑战，因为关于技术的问题总是更容易处理。</p>
<h3><a class="header" href="#销毁被观察者和观察者" id="销毁被观察者和观察者">销毁被观察者和观察者</a></h3>
<p>我们看到的样例代码健壮可用，但有一个严重的副作用：
当删除一个被观察者或观察者时会发生什么？
如果你不小心在某些观察者上面调用了<code>delete</code>，被观察者也许仍然持有指向它的指针。
那是一个指向一片已释放区域的悬空指针。
当被观察者试图发送一个通知，额……就说发生的事情会出乎你的意料之外吧。</p>
<blockquote>
<p>不是谴责，但我注意到<strong>设计模式</strong>完全没提这个问题。</p>
</blockquote>
<p>删除被观察者更容易些，因为在大多数实现中，观察者没有对它的引用。
但是即使这样，将被观察者所占的字节直接回收可能还是会造成一些问题。
这些观察者也许仍然期待在以后收到通知，而这是不可能的了。
它们没法继续观察了，真的，它们只是认为它们可以。</p>
<p>你可以用好几种方式处理这点。
最简单的就是像我做的那样，以后一脚踩空。
在被删除时取消注册是观察者的职责。
多数情况下，观察者<strong>确实</strong>知道它在观察哪个被观察者，
所以通常需要做的只是给它的析构器添加一个<code>removeObserver()</code>。</p>
<blockquote>
<p>通常在这种情况下，难点不在如何做，而在<strong>记得</strong>做。</p>
</blockquote>
<p>如果在删除被观察者时，你不想让观察者处理问题，这也很好解决。
只需要让被观察者在它被删除前发送一个最终的“死亡通知”。
这样，任何观察者都可以接收到，然后做些合适的行为。</p>
<blockquote>
<p>默哀，献花，挽歌……</p>
</blockquote>
<p>人——哪怕是那些花费在大量时间在机器前，拥有让我们黯然失色的才能的人——也是绝对不可靠的。
这就是为什么我们发明了电脑：它们不像我们那样经常犯错误。</p>
<p>更安全的方案是在每个被观察者销毁时，让观察者自动取消注册。
如果你在观察者基类中实现了这个逻辑，每个人不必记住就可以使用它。
这确实增加了一定的复杂度。
这意味着每个<strong>观察者</strong>都需要有它在观察的<strong>被观察者</strong>的列表。
最终维护一个双向指针。</p>
<h3><a class="header" href="#别担心我有垃圾回收器" id="别担心我有垃圾回收器">别担心，我有垃圾回收器</a></h3>
<p>你们那些装备有垃圾回收系统的孩子现在一定很洋洋自得。
觉得你不必担心这个，因为你从来不必显式删除任何东西？再仔细想想！</p>
<p>想象一下：你有 UI 显示玩家角色情况的状态，比如健康和道具。
当玩家在屏幕上时，你为其初始化了一个对象。
当 UI 退出时，你直接忘掉这个对象，交给 GC 清理。</p>
<p>每当角色脸上（或者其他什么地方）挨了一拳，就发送一个通知。
UI 观察到了，然后更新健康槽。很好。
当玩家离开场景，但你没有取消观察者的注册，会发生什么？</p>
<p>UI 界面不再可见，但也不会进入垃圾回收系统，因为角色的观察者列表还保存着对它的引用。
每一次场景加载后，我们给那个不断增长的观察者列表添加一个新实例。</p>
<p>玩家玩游戏时，来回跑动，打架，角色的通知发送给<strong>所有</strong>的界面。
它们不在屏幕上，但它们接受通知，这样就浪费 CPU 循环在不可见的 UI 元素上了。
如果它们会播放声音之类的，这样的错误就会被人察觉。</p>
<p>这在通知系统中非常常见，甚至专门有个名字：<em>失效监听者问题</em>。
由于被观察者保留了对观察者的引用，最终有 UI 界面对象僵死在内存中。
这里的教训是要及时删除观察者。</p>
<blockquote>
<p>它甚至有专门的<a href="http://en.wikipedia.org/wiki/Lapsed_listener_problem">维基条目</a>。</p>
</blockquote>
<h3><a class="header" href="#然后呢" id="然后呢">然后呢</a></h3>
<p>观察者的另一个深层次问题是它的意图直接导致的。
我们使用它是因为它帮助我们放松了两块代码之间的耦合。
它让被观察者与没有静态绑定的观察者间接交流。</p>
<p>当你要理解被观察者的行为时，这很有价值，任何不相关的事情都是在分散注意力。
如果你在处理物理引擎，你根本不想要编辑器——或者你的大脑——被一堆成就系统的东西而搞糊涂。</p>
<p>另一方面，如果你的程序没能运行，漏洞散布在多个观察者之间，理清信息流变得更加困难。
显式耦合中更易于查看哪一个方法被调用了。
这是因为耦合是静态的，IDE 分析它轻而易举。</p>
<p>但是如果耦合发生在观察者列表中，想要知道哪个观察者被通知到了，唯一的办法是看看哪个观察者在列表中，而且<strong>处于运行中</strong>。
你得理清它的<strong>命令式，动态</strong>行为而非理清程序的<strong>静态</strong>交流结构。</p>
<p>处理这个的指导原则很简单。
如果为了理解程序的一部分，两个交流的模块<strong>都</strong>需要考虑，
那就不要使用观察者模式，使用其他更加显式的东西。</p>
<p>当你在某些大型程序上用黑魔法时，你会感觉这样处理很笨拙。
我们有很多术语用来描述，比如“关注点分离”，“一致性和内聚性”和“模块化”，
总归就是“这些东西待在一起，而不是与那些东西待在一起。”</p>
<p>观察者模式是一个让这些不相关的代码块互相交流，而不必打包成更大的块的好方法。
这在专注于一个特性或层面的单一代码块<strong>内</strong>不会太有用。</p>
<p>这就是为什么它能很好地适应我们的例子：
成就和物理是几乎完全不相干的领域，通常被不同的人实现。
我们想要它们之间的交流最小化，
这样无论在哪一个上工作都不需要另一个的太多信息。</p>
<h2><a class="header" href="#今日观察者" id="今日观察者">今日观察者</a></h2>
<p><strong>设计模式</strong>源于 1994。
那时候，面向对象语言<strong>正是</strong>热门的编程范式。
每个程序员都想要“30 天学会面向对象编程”，
中层管理员根据程序员创建类的数量为他们支付工资。
工程师通过继承层次的深度评价代码质量。</p>
<blockquote>
<p>同一年，Ace of Base 的畅销单曲发行了<strong>三首</strong>而不是一首，这也许能让你了解一些我们那时的品味和洞察力。</p>
</blockquote>
<p>观察者模式在那个时代中很流行，所以构建它需要很多类就不奇怪了。
但是现代的主流程序员更加适应函数式语言。
实现一整套接口只是为了接受一个通知不再符合今日的美学了。</p>
<p>它看上去是又沉重又死板。它<strong>确实</strong>又沉重又死板。
举个例子，在观察者类中，你不能为不同的被观察者调用不同的通知方法。</p>
<blockquote>
<p>这就是为什么被观察者经常将自身传给观察者。
观察者只有单一的<code>onNotify()</code>方法，
如果它观察多个被观察者，它需要知道哪个被观察者在调用它的方法。</p>
</blockquote>
<p>现代的解决办法是让“观察者”只是对方法或者函数的引用。
在函数作为第一公民的语言中，特别是那些有闭包的，
这种实现观察者的方式更为普遍。</p>
<blockquote>
<p>今日，几乎<strong>每种</strong>语言都有闭包。C++克服了在没有垃圾回收的语言中构建闭包的挑战，甚至 Java 都在 JDK8 中引入了闭包。</p>
</blockquote>
<p>举个例子，C#有“事件”嵌在语言中。
通过这样，观察者是一个“委托”，
（“委托”是方法的引用在 C#中的术语）。
在 JavaScript 事件系统中，观察者<strong>可以</strong>是支持了特定<code>EventListener</code>协议的类，
但是它们也可以是函数。
后者是人们常用的方式。</p>
<p>如果设计今日的观察者模式，我会让它基于函数而不是基于类。
哪怕是在 C++中，我倾向于让你注册一个成员函数指针作为观察者，而不是<code>Observer</code>接口的实例。</p>
<blockquote>
<p><a href="http://molecularmusings.wordpress.com/2011/09/19/generic-type-safe-delegates-and-events-in-c/">这里</a>的一篇有趣博文以某种方式在 C++上实现了这一点。</p>
</blockquote>
<h2><a class="header" href="#明日观察者" id="明日观察者">明日观察者</a></h2>
<p>事件系统和其他类似观察者的模式如今遍地都是。
它们都是成熟的方案。
但是如果你用它们写一个稍微大一些的应用，你会发现一件事情。
在观察者中很多代码最后都长得一样。通常是这样：</p>
<ol>
<li>获知有状态改变了。</li>
<li>下命令改变一些 UI 来反映新的状态。</li>
</ol>
<p>就是这样，“哦，英雄的健康现在是 7 了？让我们把血条的宽度设为 70 像素。
过上一段时间，这会变得很沉闷。
计算机科学学术界和软件工程师已经用了<strong>很长</strong>时间尝试结束这种状况了。
这些方式被赋予了不同的名字：“数据流编程”，“函数反射编程”等等。</p>
<p>即使有所突破，一般也局限在特定的领域中，比如音频处理或芯片设计，我们还没有找到万能钥匙。
与此同时，一个更脚踏实地的方式开始获得成效。那就是现在的很多应用框架使用的“数据绑定”。</p>
<p>不像激进的方式，数据绑定不再指望完全终结命令式代码，
也不尝试基于巨大的声明式数据图表架构整个应用。
它做的只是自动改变 UI 元素或计算某些数值来反映一些值的变化。</p>
<p>就像其他声明式系统，数据绑定也许太慢，嵌入游戏引擎的核心也太复杂。
但是如果说它不会侵入游戏不那么性能攸关的部分，比如 UI，那我会很惊讶。</p>
<p>与此同时，经典观察者模式仍然在那里等着我们。
是的，它不像其他的新热门技术一样在名字中填满了“函数”，“反射”，
但是它超简单而且能正常工作。对我而言，这通常是解决方案最重要的条件。</p>
<h1><a class="header" href="#原型模式" id="原型模式">原型模式</a></h1>
<p>我第一次听到“原型”这个词是在<strong>设计模式</strong>中。
如今，似乎每个人都在用这个词，但他们讨论的实际上不是<a href="http://en.wikipedia.org/wiki/Prototype_pattern">设计模式</a>。
我们会讨论他们所说的原型，也会讨论术语“原型”的有趣之处，和其背后的理念。
但首先，让我们重访传统的设计模式。</p>
<blockquote>
<p>“传统的”一词可不是随便用的。</p>
<p><strong>设计模式</strong>引自<strong>1963 年</strong> Ivan Sutherland 的<a href="http://en.wikipedia.org/wiki/Sketchpad">Sketchpad</a>传奇项目，那是这个模式首次出现。
当其他人在听迪伦和甲壳虫乐队时，Sutherland 正忙于，你知道的，发明 CAD，交互图形和面向对象编程的基本概念。</p>
<p>看看这个<a href="http://www.youtube.com/watch?v=USyoT_Ha_bA">demo</a>，跪服吧。</p>
</blockquote>
<h2><a class="header" href="#原型设计模式" id="原型设计模式">原型设计模式</a></h2>
<p>假设我们要用《圣铠传说》的风格做款游戏。
野兽和恶魔围绕着英雄，争着要吃他的血肉。
这些可怖的同行者通过“生产者”进入这片区域，每种敌人有不同的生产者。</p>
<p>在这个例子中，假设我们游戏中每种怪物都有不同的类——<code>Ghost</code>，<code>Demon</code>，<code>Sorcerer</code>等等，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Monster
{
  // 代码……
};

class Ghost : public Monster {};
class Demon : public Monster {};
class Sorcerer : public Monster {};
<span class="boring">}
</span></code></pre></pre>
<p>生产者构造特定种类怪物的实例。
为了在游戏中支持每种怪物，我们<strong>可以</strong>用一种暴力的实现方法，
让每个怪物类都有生产者类，得到平行的类结构：</p>
<p><img src="https://gpp.tkchu.me/images/prototype-hierarchies.png" alt="平行的类结构，恶灵，恶魔，巫师都继承怪物。恶灵生产者。恶魔生产者，巫师生产者都继承生产者。" /></p>
<blockquote>
<p>我得翻出落满灰尘的 UML 书来画这个图表。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/arrow-inherits.png" alt="一个UML箭头" />代表“继承”。</p>
<p>实现后看起来像是这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Spawner
{
public:
  virtual ~Spawner() {}
  virtual Monster* spawnMonster() = 0;
};

class GhostSpawner : public Spawner
{
public:
  virtual Monster* spawnMonster()
  {
    return new Ghost();
  }
};

class DemonSpawner : public Spawner
{
public:
  virtual Monster* spawnMonster()
  {
    return new Demon();
  }
};

// 你知道思路了……
<span class="boring">}
</span></code></pre></pre>
<p>除非你会根据代码量来获得工资，
否则将这些焊在一起很明显不是好方法。
众多类，众多引用，众多冗余，众多副本，众多重复自我……</p>
<p>原型模式提供了一个解决方案。
关键思路是<strong>一个对象可以产出与它自己相近的对象。</strong>
如果你有一个恶灵，你可以制造更多恶灵。
如果你有一个恶魔，你可以制造其他恶魔。
任何怪物都可以被视为<strong>原型</strong>怪物，产出其他版本的自己。</p>
<p>为了实现这个功能，我们给基类<code>Monster</code>添加一个抽象方法<code>clone()</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Monster
{
public:
  virtual ~Monster() {}
  virtual Monster* clone() = 0;

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>每个怪兽子类提供一个特定实现，返回与它自己的类和状态都完全一样的新对象。举个例子：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Ghost : public Monster {
public:
  Ghost(int health, int speed)
  : health_(health),
    speed_(speed)
  {}

  virtual Monster* clone()
  {
    return new Ghost(health_, speed_);
  }

private:
  int health_;
  int speed_;
};
<span class="boring">}
</span></code></pre></pre>
<p>一旦我们所有的怪物都支持这个，
我们不再需要为每个怪物类创建生产者类。我们只需定义一个类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Spawner
{
public:
  Spawner(Monster* prototype)
  : prototype_(prototype)
  {}

  Monster* spawnMonster()
  {
    return prototype_-&gt;clone();
  }

private:
  Monster* prototype_;
};
<span class="boring">}
</span></code></pre></pre>
<p>它内部存有一个怪物，一个隐藏的怪物，
它唯一的任务就是被生产者当做模板，去产生更多一样的怪物，
有点像一个从来不离开巢穴的蜂后。</p>
<p><img src="https://gpp.tkchu.me/images/prototype-spawner.png" alt="一个生产者包含一个对怪物应用的原型字段。他调用原型的clone()方法来产生新的怪物。" /></p>
<p>为了得到恶灵生产者，我们创建一个恶灵的原型实例，然后创建拥有这个实例的生产者：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Monster* ghostPrototype = new Ghost(15, 3);
Spawner* ghostSpawner = new Spawner(ghostPrototype);
<span class="boring">}
</span></code></pre></pre>
<p>这个模式的灵巧之处在于它不但拷贝原型的<strong>类</strong>，也拷贝它的<strong>状态</strong>。
这就意味着我们可以创建一个生产者，生产快速鬼魂，虚弱鬼魂，慢速鬼魂，而只需创建一个合适的原型鬼魂。</p>
<p>我在这个模式中找到了一些既优雅又令人惊叹的东西。
我无法想象自己是如何创造出它们的，但我更无法想象<strong>不知道</strong>这些东西的自己该如何是好。</p>
<h3><a class="header" href="#效果如何" id="效果如何">效果如何</a></h3>
<p>好吧，我们不需要为每个怪物创建单独的生产者类，那很好。
但我们<strong>确实</strong>需要在每个怪物类中实现<code>clone()</code>。
这和使用生产者方法比起来也没节约多少代码量。</p>
<p>当你坐下来试着写一个正确的<code>clone()</code>，会遇见令人不快的语义漏洞。
做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？</p>
<p>同时，这看上去没减少已存问题上的代码，
事实上还增添了些<strong>人为的问题</strong>。
我们需要将每个怪物有独立的类作为前提条件。
这绝对<strong>不是</strong>当今大多数游戏引擎运作的方法。</p>
<p>我们中大部分痛苦地学到，这样庞杂的类层次管理起来很痛苦，
那就是我们为什么用<a href="06-1%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html">组件模式</a>和<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>为不同的实体建模，这样无需一一建构自己的类。</p>
<h3><a class="header" href="#生产函数" id="生产函数">生产函数</a></h3>
<p>哪怕我们确实需要为每个怪物构建不同的类，这里还有其他的实现方法。
不是使用为每个怪物建立分离的生产者<strong>类</strong>，我们可以创建生产<strong>函数</strong>，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Monster* spawnGhost()
{
  return new Ghost();
}
<span class="boring">}
</span></code></pre></pre>
<p>这比构建怪兽生产者类更简洁。生产者类只需简单地存储一个函数指针：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>typedef Monster* (*SpawnCallback)();

class Spawner
{
public:
  Spawner(SpawnCallback spawn)
  : spawn_(spawn)
  {}

  Monster* spawnMonster()
  {
    return spawn_();
  }

private:
  SpawnCallback spawn_;
};
<span class="boring">}
</span></code></pre></pre>
<p>为了给恶灵构建生产者，你需要做：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Spawner* ghostSpawner = new Spawner(spawnGhost);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#模板" id="模板">模板</a></h3>
<p>如今，大多数 C++开发者已然熟悉模板了。
生产者类需要为某类怪物构建实例，但是我们不想硬编码是哪类怪物。
自然的解决方案是将它作为模板中的<strong>类型参数</strong>：</p>
<blockquote>
<p>我不太确定程序员是学着喜欢 C++模板还是完全畏惧并远离了 C++。
不管怎样，今日我见到的程序员中，使用 C++的也都会使用模板。</p>
<p>这里的<code>Spawner</code>类不必考虑将生产什么样的怪物，
它总与指向<code>Monster</code>的指针打交道。</p>
<p>如果我们只有<code>SpawnerFor&lt;T&gt;</code>类，模板类型没有办法共享父模板，
这样的话，如果一段代码需要与产生多种怪物类型的生产者打交道，就都得接受模板参数。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Spawner
{
public:
  virtual ~Spawner() {}
  virtual Monster* spawnMonster() = 0;
};

template &lt;class T&gt;
class SpawnerFor : public Spawner
{
public:
  virtual Monster* spawnMonster() { return new T(); }
};
<span class="boring">}
</span></code></pre></pre>
<p>像这样使用它：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Spawner* ghostSpawner = new SpawnerFor&lt;Ghost&gt;();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第一公民类型" id="第一公民类型">第一公民类型</a></h3>
<p>前面的两个解决方案使用类完成了需求，<code>Spawner</code>使用类型进行参数化。
在 C++中，类型不是第一公民，所以需要一些改动。
如果你使用 JavaScript，Python，或者 Ruby 这样的动态类型语言，
它们的类<strong>是</strong>可以传递的对象，你可以用更直接的办法解决这个问题。</p>
<blockquote>
<p>某种程度上，<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>也是为了弥补第一公民类型的缺失。
但那个模式在拥有第一公民类型的语言中也有用，因为它让<strong>你</strong>决定什么是“类型”。
你也许想要与语言内建的类不同的语义。</p>
</blockquote>
<p>当你完成一个生产者，直接向它传递要构建的怪物类——那个代表了怪物类的运行时对象。超容易的，对吧。</p>
<p>综上所述，老实说，我不能说找到了一种情景，而在这个情景下，原型<strong>设计模式</strong>是最好的方案。
也许你的体验有所不同，但现在把它搁到一边，我们讨论点别的：将原型作为一种<strong>语言范式</strong>。</p>
<h2><a class="header" href="#原型语言范式" id="原型语言范式">原型语言范式</a></h2>
<p>很多人认为“面向对象编程”和“类”是同义词。
OOP 的定义却让人感觉正好相反，
毫无疑问，<em>OOP 让你定义“对象”，将数据和代码绑定在一起。</em>
与 C 这样的结构化语言相比，与 Scheme 这样的函数语言相比，
OOP 的特性是它将状态和行为紧紧地绑在一起。</p>
<p>你也许认为类是完成这个的唯一方式方法，
但是包括 Dave Ungar 和 Randall Smith 的一大堆家伙一直在拼命区分 OOP 和类。
他们在 80 年代创建了一种叫做 Self 的语言。它不用类实现了 OOP。</p>
<h3><a class="header" href="#self-语言" id="self-语言">Self 语言</a></h3>
<p>就单纯意义而言，Self 比基于类的语言<strong>更加</strong>面向对象。
我们认为 OOP 将状态和行为绑在一起，但是基于类的语言实际将状态和行为割裂开来。</p>
<p>拿你最喜欢的基于类的语言的语法来说。
为了接触对象中的一些状态，你需要在实例的内存中查询。状态<strong>包含</strong>在实例中。</p>
<p>但是，为了调用方法，你需要找到实例的类，
然后在<strong>那里</strong>调用方法。行为包含在<strong>类</strong>中。
获得方法总需要通过中间层，这意味着字段和方法是不同的。</p>
<p><img src="https://gpp.tkchu.me/images/prototype-class.png" alt="一个类，包含了一系列方法。一个实例，包含了一系列字段和指向类的指针。" /></p>
<blockquote>
<p>举个例子，为了调用 C++中的虚方法，你需要在实例中找指向虚方法表的指针，然后再在那里找方法。</p>
</blockquote>
<p>Self 结束了这种分歧。<em>无论你要找啥</em>，都只需在对象中找。
实例同时包含状态和行为。你可以构建拥有完全独特方法的对象。</p>
<p><img src="https://gpp.tkchu.me/images/prototype-object.png" alt="一个对象中同时包含了字段和方法。" /></p>
<blockquote>
<p>没有人能与世隔绝，但这个对象是。</p>
</blockquote>
<p>如果这就是 Self 语言的全部，那它将很难使用。
基于类的语言中的继承，不管有多少缺陷，总归提供了有用的机制来重用代码，避免重复。
为了不使用类而实现一些类似的功能，Self 语言加入了<strong>委托（delegation）</strong>。</p>
<p>如果要在对象中寻找字段或者调用方法，首先在对象内部查找。
如果能找到，那就成了。如果找不到，在对象的<strong>父对象</strong>中寻找。
这里的父类仅仅是一个对其他对象的引用。
当我们没能在第一个对象中找到属性，我们尝试它的父对象，然后父类的父对象，继续下去直到找到或者没有父对象为止。
换言之，失败的查找被<strong>委托</strong>给对象的父对象。</p>
<blockquote>
<p>我在这里简化了。Self 实际上支持多个父对象。
父对象只是特别标明的字段，意味着你可以继承它们或者在运行时改变他们，
你最终得到了“动态继承”。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/prototype-delegate.png" alt="一个对象包含了字段和方法，以及一个指向委托对象的指针。" /></p>
<p>父对象让我们在不同对象间重用行为（还有状态！），这样就完成了类的公用功能。
类做的另一个关键事情就是给出了创建实例的方法。
当你需要新的某物，你可以直接<code>new Thingamabob()</code>，或者随便什么你喜欢的表达法。
类是实例的生产工厂。</p>
<p>不用类，我们怎样创建新的实例？
特别地，我们如何创建一堆有共同点的新东西？
就像这个设计模式，在 Self 中，达到这点的方式是使用<strong>克隆</strong>。</p>
<p>在 Self 语言中，就好像<strong>每个</strong>对象都自动支持原型设计模式。
任何对象都能被克隆。为了获得一堆相似的对象，你：</p>
<ol>
<li>将对象塑造成你想要的状态。你可以直接克隆系统内建的基本<code>Object</code>，然后向其中添加字段和方法。</li>
<li>克隆它来产出……额……随你想要多少就克隆多少个对象。</li>
</ol>
<p>无需烦扰自己实现<code>clone()</code>；我们就实现了优雅的原型模式，原型被内建在系统中。</p>
<p>这个系统美妙，灵巧，而且小巧，
一听说它，我就开始创建一个基于原型的语言来进一步学习。</p>
<blockquote>
<p>我知道从头开始构建一种编程语言语言不是学习它最有效率的办法，但我能说什么呢？我可算是个怪人。
如果你很好奇，我构建的语言叫<a href="http://finch.stuffwithstuff.com/">Finch</a>.</p>
</blockquote>
<h3><a class="header" href="#它的实际效果如何" id="它的实际效果如何">它的实际效果如何</a></h3>
<p>能使用纯粹基于原型的语言让我很兴奋，但是当我真正上手时，
我发现了一个令人不快的事实：用它编程没那么有趣。</p>
<blockquote>
<p>从小道消息中，我听说很多 Self 程序员得出了相同的结论。
但这项目并不是一无是处。
Self 非常的灵活，为此创造了很多虚拟机的机制来保持高速运行。</p>
<p>他们发明了 JIT 编译，垃圾回收，以及优化方法分配——这都是由同一批人实现的——
这些新玩意让动态类型语言能快速运行，构建了很多大受欢迎的应用。</p>
</blockquote>
<p>是的，语言本身很容易实现，那是因为它把复杂度甩给了用户。
一旦开始试着使用这语言，我发现我想念基于类语言中的层次结构。
最终，在构建语言缺失的库概念时，我放弃了。</p>
<p>鉴于我之前的经验都来自基于类的语言，因此我的头脑可能已经固定在它的范式上了。
但是直觉上，我认为大部分人还是喜欢有清晰定义的“事物”。</p>
<p>除去基于类的语言自身的成功以外，看看有多少游戏用类建模描述玩家角色，以及不同的敌人、物品、技能。
不是游戏中的每个怪物都与众不同，你不会看到“洞穴人和哥布林还有雪混合在一起”这样的怪物。</p>
<p>原型是非常酷的范式，我希望有更多人了解它，
但我很庆幸不必天天用它编程。
完全皈依原型的代码是一团浆糊，难以阅读和使用。</p>
<blockquote>
<p>这同时证明，<em>很少</em> 有人使用原型风格的代码。我查过了。</p>
</blockquote>
<h3><a class="header" href="#javascript-又怎么样呢" id="javascript-又怎么样呢">JavaScript 又怎么样呢</a></h3>
<p>好吧，如果基于原型的语言不那么友好，怎么解释 JavaScript 呢？
这是一个有原型的语言，每天被数百万人使用。运行 JavaScript 的机器数量超过了地球上其他所有的语言。</p>
<p>Brendan Eich，JavaScript 的缔造者，从 Self 语言中直接汲取灵感，很多 JavaScript 的语义都是基于原型的。
每个对象都有属性的集合，包含字段和“方法”（事实上只是存储为字段的函数）。
A 对象可以拥有 B 对象，B 对象被称为 A 对象的“原型”，
如果 A 对象的字段获取失败就会委托给 B 对象。</p>
<blockquote>
<p>作为语言设计者，原型的诱人之处是它们比类更易于实现。
Eich 充分利用了这一点，他在十天内创建了 JavaScript 的第一个版本。</p>
</blockquote>
<p>但除那以外，我相信在实践中，JavaScript 更像是基于类的而不是基于原型的语言。
JavaScript 与 Self 有所偏离，其中一个要点是除去了基于原型语言的核心操作“克隆”。</p>
<p>在 JavaScript 中没有方法来克隆一个对象。
最接近的方法是<code>Object.create()</code>，允许你创建新对象作为现有对象的委托。
这个方法在 ECMAScript5 中才添加，而那已是 JavaScript 出现后的第十四年了。
相对于克隆，让我带你参观一下 JavaScript 中定义类和创建对象的经典方法。
我们从<strong>构造器函数</strong>开始：</p>
<pre><code class="language-javascript">function Weapon(range, damage) {
  this.range = range;
  this.damage = damage;
}
</code></pre>
<p>这创建了一个新对象，初始化了它的字段。你像这样引入它：</p>
<pre><code class="language-javascript">var sword = new Weapon(10, 16);
</code></pre>
<p>这里的<code>new</code>调用<code>Weapon()</code>函数，而<code>this</code>绑定在新的空对象上。
函数为新对象添加了一系列字段，然后返回填满的对象。</p>
<p><code>new</code>也为你做了另外一件事。
当它创建那个新的空对象时，它将空对象的委托和一个原型对象连接起来。
你可以用<code>Weapon.prototype</code>来获得原型对象。</p>
<p>属性是添加到构造器中的，而定义<strong>行为</strong>通常是通过向原型对象添加方法。就像这样：</p>
<pre><code class="language-javascript">Weapon.prototype.attack = function(target) {
  if (distanceTo(target) &gt; this.range) {
    console.log(&quot;Out of range!&quot;);
  } else {
    target.health -= this.damage;
  }
};
</code></pre>
<p>这给武器原型添加了<code>attack</code>属性，其值是一个函数。
由于<code>new Weapon()</code>返回的每一个对象都有给<code>Weapon.prototype</code>的委托，
你现在可以通过调用<code>sword.attack()</code> 来调用那个函数。
看上去像是这样：</p>
<p><img src="https://gpp.tkchu.me/images/prototype-weapon.png" alt="一个武器原型包含一个 attack() 方法和其他方法。一个宝剑对象包含一个指向武器的委托和其他字段。" /></p>
<p>让我们复习一下：</p>
<ul>
<li>通过“new”操作创建对象，该操作引入代表类型的对象——构造器函数。</li>
<li>状态存储在实例中。</li>
<li>行为通过间接层——原型的委托——被存储在独立的对象中，代表了一系列特定类型对象的共享方法。</li>
</ul>
<p>说我疯了吧，但这听起来很像是我之前描述的类。
你<strong>可以</strong>在 JavaScript 中写原型风格的代码（<em>不用</em> 克隆），
但是语言的语法和惯用法更鼓励基于类的实现。</p>
<p>个人而言，我认为这是好事。
就像我说的，我发现如果一切都使用原型，就很难编写代码，
所以我喜欢 JavaScript，它将整个核心语义包上了一层糖衣。</p>
<h2><a class="header" href="#为数据模型构建原型" id="为数据模型构建原型">为数据模型构建原型</a></h2>
<p>好吧，我之前不断地讨论我<strong>不喜欢</strong>原型的原因，这让这一章读起来令人沮丧。
我认为这本书应该更欢乐些，所以在最后，让我们讨论讨论原型<strong>确实</strong>有用，或者更加精确，<em>委托</em> 有用的地方。</p>
<p>随着编程的进行，如果你比较程序与数据的字节数，
那么你会发现数据的占比稳定地增长。
早期的游戏在程序中生成几乎所有东西，这样程序可以塞进磁盘和老式游戏卡带。
在今日的游戏中，代码只是驱动游戏的“引擎”，游戏是完全由数据定义的。</p>
<p>这很好，但是将内容推到数据文件中并不能魔术般地解决组织大项目的挑战。
它只能把这挑战变得更难。
我们使用编程语言就因为它们有办法管理复杂性。</p>
<p>不再是将一堆代码拷来拷去，我们将其移入函数中，通过名字调用。
不再是在一堆类之间复制方法，我们将其放入单独的类中，让其他类可以继承或者组合。</p>
<p>当游戏数据达到一定规模时，你真的需要考虑一些相似的方案。
我不指望在这里能说清数据模式这个问题，
但我确实希望提出个思路，让你在游戏中考虑考虑：使用原型和委托来重用数据。</p>
<p>假设我们为早先提到的山寨版《圣铠传说》定义数据模型。
游戏设计者需要在很多文件中设定怪物和物品的属性。</p>
<blockquote>
<p>这标题是我原创的，没有受到任何已存的多人地下城游戏的影响。<br />
请不要起诉我。</p>
</blockquote>
<p>一个常用的方法是使用 JSON。
数据实体一般是<strong>字典</strong>，或者<strong>属性集合</strong>，或者其他什么术语，
因为程序员就喜欢为旧事物发明新名字。</p>
<blockquote>
<p>我们重新发明了太多次，Steve Yegge 称之为<a href="http://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html">&quot;通用设计模式&quot;</a>.</p>
</blockquote>
<p>所以游戏中的哥布林也许被定义为像这样的东西：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;goblin grunt&quot;,
  &quot;minHealth&quot;: 20,
  &quot;maxHealth&quot;: 30,
  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]
}
</code></pre>
<p>这看上去很易懂，哪怕是最讨厌文本的设计者也能使用它。
所以，你可以给哥布林大家族添加几个兄弟分支：</p>
<pre><code class="language-json">    {
      &quot;name&quot;: &quot;goblin wizard&quot;,
      &quot;minHealth&quot;: 20,
      &quot;maxHealth&quot;: 30,
      &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
      &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],
      &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]
    }

    {
      &quot;name&quot;: &quot;goblin archer&quot;,
      &quot;minHealth&quot;: 20,
      &quot;maxHealth&quot;: 30,
      &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
      &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],
      &quot;attacks&quot;: [&quot;short bow&quot;]
    }
</code></pre>
<p>现在，如果这是代码，我们会闻到了臭味。
在实体间有很多的重复，训练优良的程序员<strong>讨厌</strong>重复。
它浪费了空间，消耗了作者更多时间。
你需要仔细阅读代码才知道这些数据<strong>是不是</strong>相同的。
这难以维护。
如果我们决定让所有哥布林变强，需要记得将三个哥布林都更新一遍。糟糕糟糕糟糕。</p>
<p>如果这是代码，我们会为“哥布林”构建抽象，并在三个哥布林类型中重用。
但是无能的 JSON 没法这么做。所以让我们把它做得更加巧妙些。</p>
<p>我们可以为对象添加<code>&quot;prototype&quot;</code>字段，记录委托对象的名字。
如果在此对象内没找到一个字段，那就去委托对象中查找。</p>
<blockquote>
<p>这让<code>&quot;prototype&quot;</code>不再是数据，而成为了<strong>元</strong>数据。
哥布林有绿色疣皮和黄色牙齿。它们没有原型。
原型是<strong>表示哥布林的数据模型</strong>的属性，而不是哥布林本身的属性。</p>
</blockquote>
<p>这样，我们可以简化我们的哥布林 JSON 内容：</p>
<pre><code class="language-json">    {
      &quot;name&quot;: &quot;goblin grunt&quot;,
      &quot;minHealth&quot;: 20,
      &quot;maxHealth&quot;: 30,
      &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
      &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]
    }

    {
      &quot;name&quot;: &quot;goblin wizard&quot;,
      &quot;prototype&quot;: &quot;goblin grunt&quot;,
      &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]
    }

    {
      &quot;name&quot;: &quot;goblin archer&quot;,
      &quot;prototype&quot;: &quot;goblin grunt&quot;,
      &quot;attacks&quot;: [&quot;short bow&quot;]
    }
</code></pre>
<p>由于弓箭手和术士都将 grunt 作为原型，我们就不需要在它们中重复血量，防御和弱点。
我们为数据模型增加的逻辑超级简单——基本的单一委托——但已经成功摆脱了一堆冗余。</p>
<p>有趣的事情是，我们没有更进一步，把哥布林委托的<strong>抽象</strong>原型设置成“基本哥布林”。
相反，我们选择了最简单的哥布林，然后委托给它。</p>
<p>在基于原型的系统中，对象可以克隆产生新对象是很自然的，
我认为在这里也一样自然。这特别适合记录那些只有一处不同的实体的数据。</p>
<p>想想 Boss 和其他独特的事物，它们通常是更加常见事物的重新定义，
原型委托是定义它们的好方法。
断头魔剑，就是一把拥有加成的长剑，可以像下面这样表示：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Sword of Head-Detaching&quot;,
  &quot;prototype&quot;: &quot;longsword&quot;,
  &quot;damageBonus&quot;: &quot;20&quot;
}
</code></pre>
<p>只需在游戏引擎上多花点时间，你就能让设计者更加方便地添加不同的武器和怪物，而增加的这些丰富度能够取悦玩家。</p>
<h1><a class="header" href="#单例模式" id="单例模式">单例模式</a></h1>
<p>这个章节不同寻常。
其他章节展示如何使用某个设计模式。
这个章节展示如何<strong>避免</strong>使用某个设计模式。</p>
<p>尽管它的意图是好的，GoF 描述的<a href="http://c2.com/cgi/wiki?SingletonPattern">单例模式</a>通常弊大于利。
他们强调应该谨慎使用这个模式，但在游戏业界的口口相传中，这一提示经常被无视了。</p>
<p>就像其他模式一样，在不合适的地方使用单例模式就好像用夹板处理子弹伤口。
由于它被滥用得太严重了，这章的大部分都在讲如何<strong>回避</strong>单例模式，
但首先，让我们看看模式本身。</p>
<blockquote>
<p>当业界从 C 语言迁移到面向对象的语言，他们遇到的首个问题是“如何访问实例？”
他们知道有要调用的方法，但是找不到实例提供这个方法。
单例（换言之，全局化）是一条简单的解决方案。</p>
</blockquote>
<h2><a class="header" href="#什么是单例模式" id="什么是单例模式">什么是单例模式</a></h2>
<p><em>设计模式</em> 像这样描述单例模式：</p>
<blockquote>
<p>保证一个类只有一个实例，并且提供了访问该实例的全局访问点。</p>
</blockquote>
<p>我们从“并且”那里将句子分为两部分，分别进行考虑。</p>
<h3><a class="header" href="#保证一个类只有一个实例" id="保证一个类只有一个实例">保证一个类只有一个实例</a></h3>
<p>有时候，如果类存在多个实例就不能正确的运行。
通常发生在类与保存全局状态的外部系统互动时。</p>
<p>考虑封装文件系统的 API 类。
因为文件操作需要一段时间完成，所以类使用异步操作。
这就意味着可以同时运行多个操作，必须让它们相互协调。
如果一个操作创建文件，另一个操作删除同一文件，封装器类需要同时考虑，保证它们没有相互妨碍。</p>
<p>为了实现这点，对我们封装器类的调用必须接触之前的每个操作。
如果用户可以自由地创建类的实例，这个实例就无法知道另一实例之前的操作。
而单例模式提供的构建类的方式，在编译时保证类只有单一实例。</p>
<h3><a class="header" href="#提供了访问该实例的全局访问点" id="提供了访问该实例的全局访问点">提供了访问该实例的全局访问点</a></h3>
<p>游戏中的不同系统都会使用文件系统封装类：日志，内容加载，游戏状态保存，等等。
如果这些系统不能创建文件系统封装类的实例，它们如何访问该实例呢？</p>
<p>单例为这点也提供了解决方案。
除了创建单一实例以外，它也提供了一种获得它的全局方法。
使用这种范式，无论何处何人都可以访问实例。
综合起来，经典的实现方案如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class FileSystem
{
public:
  static FileSystem&amp; instance()
  {
    // 惰性初始化
    if (instance_ == NULL) instance_ = new FileSystem();
    return *instance_;
  }

private:
  FileSystem() {}

  static FileSystem* instance_;
};
<span class="boring">}
</span></code></pre></pre>
<p>静态的<code>instance_</code>成员保存了一个类的实例，
私有的构造器保证了它是<strong>唯一</strong>的。
公开的静态方法<code>instance()</code>让任何地方的代码都能访问实例。
在首次被请求时，它同样负责惰性实例化该单例。</p>
<p>现代的实现方案看起来是这样的：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class FileSystem
{
public:
  static FileSystem&amp; instance()
  {
    static FileSystem *instance = new FileSystem();
    return *instance;
  }

private:
  FileSystem() {}
};
<span class="boring">}
</span></code></pre></pre>
<p>哪怕是在多线程情况下，C++11 标准也保证了本地静态变量只会初始化一次，
因此，假设你有一个现代 C++编译器，这段代码是线程安全的，而前面的那个例子不是。</p>
<blockquote>
<p>当然，单例类本身的线程安全是个不同的问题！这里只保证了它的<strong>初始化</strong>没问题。</p>
</blockquote>
<h2><a class="header" href="#为什么我们使用它" id="为什么我们使用它">为什么我们使用它</a></h2>
<p>看起来已有成效。
文件系统封装类在任何需要的地方都可用，而无需笨重地到处传递。
类本身巧妙地保证了我们不会实例化多个实例而搞砸。它还具有很多其他的优良性质：</p>
<ul>
<li>
<p><strong>如果没人用，就不必创建实例。</strong>
节约内存和 CPU 循环总是好的。
由于单例只在第一次被请求时实例化，如果游戏永远不请求，那么它不会被实例化。</p>
</li>
<li>
<p><strong>它在运行时实例化。</strong>
通常的替代方案是使用含有静态成员变量的类。
我喜欢简单的解决方案，因此我尽可能使用静态类而不是单例，但是静态成员有个限制：自动初始化。
编译器在<code>main()</code>运行前初始化静态变量。
这就意味着不能使用在程序加载时才获取的信息（举个例子，从文件加载的配置）。
这也意味着它们的相互依赖是不可靠的——编译器可不保证以什么样的顺序初始化静态变量。</p>
<p>惰性初始化解决了以上两个问题。
单例会尽可能晚地初始化，所以那时它需要的所有信息都应该可用了。
只要没有环状依赖，一个单例在初始化它自己的时甚至可以引用另一个单例。</p>
</li>
<li>
<p><strong>可继承单例。</strong>
这是个很有用但通常被忽视的能力。
假设我们需要跨平台的文件系统封装类。
为了达到这一点，我们需要它变成文件系统抽象出来的接口，而子类为每个平台实现接口。
这是基类：</p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class FileSystem
{
public:
  virtual ~FileSystem() {}
  virtual char* readFile(char* path) = 0;
  virtual void  writeFile(char* path, char* contents) = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p>然后为一堆平台定义子类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class PS3FileSystem : public FileSystem
{
public:
  virtual char* readFile(char* path)
  {
    // 使用索尼的文件读写API……
  }

  virtual void writeFile(char* path, char* contents)
  {
    // 使用索尼的文件读写API……
  }
};

class WiiFileSystem : public FileSystem
{
public:
  virtual char* readFile(char* path)
  {
    // 使用任天堂的文件读写API……
  }

  virtual void writeFile(char* path, char* contents)
  {
    // 使用任天堂的文件读写API……
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>下一步，我们把<code>FileSystem</code>变成单例：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class FileSystem
{
public:
  static FileSystem&amp; instance();

  virtual ~FileSystem() {}
  virtual char* readFile(char* path) = 0;
  virtual void  writeFile(char* path, char* contents) = 0;

protected:
  FileSystem() {}
};
<span class="boring">}
</span></code></pre></pre>
<p>灵巧之处在于如何创建实例：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>FileSystem&amp; FileSystem::instance()
{
<span class="boring">  if PLATFORM == PLAYSTATION3
</span>    static FileSystem *instance = new PS3FileSystem();
<span class="boring">  elif PLATFORM == WII
</span>    static FileSystem *instance = new WiiFileSystem();
<span class="boring">  endif
</span>
  return *instance;
}
<span class="boring">}
</span></code></pre></pre>
<p>通过一个简单的编译器转换，我们把文件系统包装类绑定到合适的具体类型上。
整个代码库都可以使用<code>FileSystem::instance()</code>接触到文件系统，而无需和任何平台相关的代码耦合。耦合发生在为特定平台写的<code>FileSystem</code>类实现文件中。</p>
<p>大多数人解决问题到这个程度就已经够了。
我们得到了一个文件系统封装类。
它工作可靠，它全局有效，只要请求就能获取。
是时候提交代码，开怀畅饮了。</p>
<h2><a class="header" href="#为什么我们后悔使用它" id="为什么我们后悔使用它">为什么我们后悔使用它</a></h2>
<p>短期来看，单例模式是相对良性的。
就像其他设计决策一样，我们需要从长期考虑。
这里是一旦我们将一些不必要的单例写进代码，会给自己带来的麻烦：</p>
<h3><a class="header" href="#它是一个全局变量" id="它是一个全局变量">它是一个全局变量</a></h3>
<p>当游戏还是由几个家伙在车库中完成时，榨干硬件性能比象牙塔里的软件工程原则更重要。
C 语言和汇编程序员前辈能毫无问题地使用全局变量和静态变量，发布好游戏。
但随着游戏变得越来越大，越来越复杂，架构和管理开始变成瓶颈，
阻碍我们发布游戏的，除了硬件限制，还有<strong>生产力</strong>限制。</p>
<p>所以我们迁移到了像 C++这样的语言，
开始将一些从软件工程师前辈那里学到的智慧应用于实际。
其中一课是全局变量有害的诸多原因：</p>
<ul>
<li><strong>理解代码更加困难。</strong>
假设我们在查找其他人所写函数中的漏洞。
如果函数没有碰到任何全局状态，脑子只需围着函数转，
只需搞懂函数和传给函数的变量。</li>
</ul>
<blockquote>
<p>计算机科学家称不接触不修改全局状态的函数为“纯”函数。
纯函数易于理解，易于编译器优化，
易于完成优雅的任务，比如记住缓存的情况并继续上次调用。</p>
<p>完全使用纯函数是有难度的，但其好处足以引诱科学家创造像 Haskell 这样<strong>只</strong>使用纯函数的语言。</p>
</blockquote>
<p>现在考虑函数中间是个对<code>SomeClass::getSomeGlobalData()</code>的调用。为了查明发生了什么，得追踪整个代码库来看看什么修改了全局变量。你真的不需要讨厌全局变量，直到你在凌晨三点使用<code>grep</code>搜索数百万行代码，搞清楚哪一个错误的调用将一个静态变量设为了错误的值。</p>
<ul>
<li>
<p><strong>促进了耦合的发生。</strong>
新加入团队的程序员也许不熟悉你们完美、可维护、松散耦合的游戏架构，
但还是刚刚获得了第一个任务：在岩石撞击地面时播放声音。
你我都知道这不需要将物理和<strong>音频</strong>代码耦合，但是他只想着把任务完成。
不幸的是，我们的<code>AudioPlayer</code>是全局可见的。
所以之后一个小小的<code>#include</code>，新队员就打乱了整个精心设计的架构。</p>
<p>如果不用全局实例实现音频播放器，那么哪怕他<strong>确实</strong>用<code>#include</code>包含了头文件，他还是啥也做不了。
这种阻碍给他发送了一个明确的信号，这两个模块不该接触，他需要另辟蹊径。<em>通过控制对实例的访问，你控制了耦合。</em></p>
</li>
<li>
<p><strong>对并行不友好。</strong>
那些在单核 CPU 上运行游戏的日子已经远去。
哪怕完全不需要并行的优势，现代的代码至少也应考虑在多线程环境下<strong>工作</strong>。
当我们将某些东西转为全局变量时，我们创建了一块每个线程都能看到并访问的内存，
却不知道其他线程是否正在使用那块内存。
这种方式带来了死锁，竞争状态，以及其他很难解决的线程同步问题。</p>
</li>
</ul>
<p>像这样的问题足够吓阻我们声明全局变量了，
同理单例模式也是一样，但是那还没有告诉我们<strong>应该</strong>如何设计游戏。
怎样不使用全局变量构建游戏？</p>
<p>有几个对这个问题的答案（这本书的大部分都<strong>是</strong>由答案构成），
但是它们并非显而易见。
与此同时，我们得发布游戏。
单例模式看起来是万能药。
它被写进了一本关于面向对象设计模式的书中，因此它<strong>肯定</strong>是个好的设计模式，对吧？
况且我们已经借助它做了很多年软件设计了。</p>
<p>不幸的是，它不是解药，它是安慰剂。
如果浏览全局变量造成的问题列表，你会注意到单例模式解决不了其中任何一个。
因为单例<strong>确实是</strong>全局状态——它只是被封装在一个类中。</p>
<h3><a class="header" href="#它能在你只有一个问题的时候解决两个" id="它能在你只有一个问题的时候解决两个">它能在你只有一个问题的时候解决两个</a></h3>
<p>在 GoF 对单例模式的描述中，“并且”这个词有点奇怪。
这个模式解决了一个问题还是两个问题呢？如果我们只有其中一个问题呢？
保证实例是唯一存在的是很有用的，但是谁告诉我们要让<strong>每个人</strong>都能接触到它？
同样，全局接触很方便，但是必须禁止存在多个实例吗？</p>
<p>这两个问题中的后者，便利的访问，几乎是使用单例模式的全部原因。
想想日志类。大部分模块都能从记录诊断日志中获益。
但是，如果将<code>Log</code>类的实例传给每个需要这个方法的函数，那就混杂了产生的数据，模糊了代码的意图。</p>
<p>明显的解决方案是让<code>Log</code>类成为单例。
每个函数都能从类那里获得一个实例。
但当我们这样做时，我们无意地制造了一个奇怪的小约束。
突然之间，我们不再能创建多个日志记录者了。</p>
<p>起初，这不是一个问题。
我们记录单独的日志文件，所以只需要一个实例。
然后，随着开发周期的逐次循环，我们遇到了麻烦。
每个团队的成员都使用日志记录各自的诊断信息，大量的日志倾泻在文件里。
程序员需要翻过很多页代码来找到他关心的记录。</p>
<p>我们想将日志分散到多个文件中来解决这点。
为了达到这点，我们得为游戏的不同领域创造单独的日志记录者：
网络，UI，声音，游戏，玩法。
但是我们做不到。
<code>Log</code>类不再允许我们创建多个实例，而且调用的方式也保证了这一点：</p>
<pre><code class="language-log">    Log::instance().write(&quot;Some event.&quot;);
</code></pre>
<p>为了让<code>Log</code>类支持多个实例（就像它原来的那样），
我们需要修改类和提及它的每一行代码。
之前便利的访问就不再那么便利了。</p>
<blockquote>
<p>这可能更糟。想象一下你的<code>Log</code>类是在多个<strong>游戏</strong>间共享的库中。
现在，为了改变设计，需要在多组人之间协调改变，
他们中的大多数既没有时间，也没有动机修复它。</p>
</blockquote>
<h3><a class="header" href="#惰性初始化从你那里剥夺了控制权" id="惰性初始化从你那里剥夺了控制权">惰性初始化从你那里剥夺了控制权</a></h3>
<p>在拥有虚拟内存和软性性能需求的 PC 里，惰性初始化是一个小技巧。
游戏则是另一种状况。初始化系统需要消耗时间：分配内存，加载资源，等等。
如果初始化音频系统消耗了几百个毫秒，我们需要控制它何时发生。
如果在第一次声音播放时惰性初始化它自己，这可能发生在游戏的高潮部分，导致可见的掉帧和断续的游戏体验。</p>
<p>同样，游戏通常需要严格管理在堆上分配的内存来避免碎片。
如果音频系统在初始化时分配到了堆上，我们需要知道初始化在<strong>何时</strong>发生，
这样我们可以控制内存待在堆的<strong>哪里</strong>。</p>
<blockquote>
<p><a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池模式</a>一节中有内存碎片的其他细节。</p>
</blockquote>
<p>因为这两个原因，我见到的大多数游戏都不使用惰性初始化。
相反，它们像这样实现单例模式：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class FileSystem
{
public:
  static FileSystem&amp; instance() { return instance_; }

private:
  FileSystem() {}

  static FileSystem instance_;
};
<span class="boring">}
</span></code></pre></pre>
<p>这解决了惰性初始化问题，但是损失了几个单例<strong>确实</strong>比原生的全局变量优良的特性。
静态实例中，我们不能使用多态，在静态初始化时，类也必须是可构建的。
我们也不能在不需要这个实例的时候，释放实例所占的内存。</p>
<p>与创建一个单例不同，这里实际上是一个简单的静态类。
这并非坏事，但是如果你需要的是静态类，为什么不完全摆脱<code>instance()</code>方法，
直接使用静态函数呢？调用<code>Foo::bar()</code>比<code>Foo::instance().bar()</code>更简单，
也更明确地表明你在处理静态内存。</p>
<blockquote>
<p>通常使用单例而不是静态类的理由是，
如果你后来决定将静态类改为非静态的，你需要修改每一个调用点。
理论上，用单例就不必那么做，因为你可以将实例传来传去，像普通的实例方法一样使用。</p>
<p>实践中，我从未见过这种情况。
每个人都在使用<code>Foo::instance().bar()</code>。
如果我们将 Foo 改成非单例，我们还是得修改每一个调用点。
鉴于此，我更喜欢简单的类和简单的调用语法。</p>
</blockquote>
<h2><a class="header" href="#那该如何是好" id="那该如何是好">那该如何是好</a></h2>
<p>如果我现在达到了目标，你在下次遇到问题使用单例模式之前就会三思而后行。
但是你还是有问题需要解决。你<strong>应该</strong>使用什么工具呢？
这取决于你试图做什么，我有一些你可以考虑的选项，但是首先……</p>
<h3><a class="header" href="#看看你是不是真正地需要类" id="看看你是不是真正地需要类">看看你是不是真正地需要类</a></h3>
<p>我在游戏中看到的很多单例类都是“管理器”——那些类存在的意义就是照顾其他对象。
我曾看到一些代码库中，几乎<strong>所有</strong>类都有管理器：
怪物，怪物管理器，粒子，粒子管理器，声音，声音管理器，管理管理器的管理器。
有时候，它们被叫做“系统”或“引擎”，但是思路还是一样的。</p>
<p>管理器类有时是有用的，但通常它们只是反映出作者对 OOP 的不熟悉。思考这两个特制的类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Bullet
{
public:
  int getX() const { return x_; }
  int getY() const { return y_; }

  void setX(int x) { x_ = x; }
  void setY(int y) { y_ = y; }

private:
  int x_, y_;
};

class BulletManager
{
public:
  Bullet* create(int x, int y)
  {
    Bullet* bullet = new Bullet();
    bullet-&gt;setX(x);
    bullet-&gt;setY(y);

    return bullet;
  }

  bool isOnScreen(Bullet&amp; bullet)
  {
    return bullet.getX() &gt;= 0 &amp;&amp;
           bullet.getX() &lt; SCREEN_WIDTH &amp;&amp;
           bullet.getY() &gt;= 0 &amp;&amp;
           bullet.getY() &lt; SCREEN_HEIGHT;
  }

  void move(Bullet&amp; bullet)
  {
    bullet.setX(bullet.getX() + 5);
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>也许这个例子有些蠢，但是我见过很多代码，在剥离了外部的细节后是一样的设计。
如果你看看这个代码，<code>BulletManager</code>很自然应是一个单例。
无论如何，任何有<code>Bullet</code>的对象都需要管理，而你又需要多少个<code>BulletManager</code>实例呢？</p>
<p>事实上，这里的答案是<strong>零</strong>。
这里是我们如何为管理类解决“单例”问题：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Bullet
{
public:
  Bullet(int x, int y) : x_(x), y_(y) {}

  bool isOnScreen()
  {
    return x_ &gt;= 0 &amp;&amp; x_ &lt; SCREEN_WIDTH &amp;&amp;
           y_ &gt;= 0 &amp;&amp; y_ &lt; SCREEN_HEIGHT;
  }

  void move() { x_ += 5; }

private:
  int x_, y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>好了。没有管理器，也没有问题。
糟糕设计的单例通常会“帮助”另一个类增加代码。
如果可以，把所有的行为都移到单例帮助的类中。
毕竟，OOP 就是让对象管理好自己。</p>
<p>但是在管理器之外，还有其他问题我们需要寻求单例模式帮助。
对于每种问题，都有一些后续方案可供参考。</p>
<h3><a class="header" href="#将类限制为单一的实例" id="将类限制为单一的实例">将类限制为单一的实例</a></h3>
<p>这是单例模式帮你解决的一个问题。
就像在文件系统的例子中那样，保证类只有一个实例是很重要的。
但是，这不意味着我们需要提供对实例的<strong>公众</strong>，<strong>全局</strong>访问。
我们想要减少某部分代码的公众部分，甚至让它在类中是私有的。
在这些情况下，提供一个全局接触点消弱了整体架构。</p>
<blockquote>
<p>举个例子，我们也许想把文件系统包在<strong>另一</strong>层抽象中。</p>
</blockquote>
<p>我们希望有种方式能保证同事只有一个实例而<strong>无需</strong>提供全局接触点。
有好几种方法能做到。这是其中之一：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class FileSystem
{
public:
  FileSystem()
  {
    assert(!instantiated_);
    instantiated_ = true;
  }

  ~FileSystem() { instantiated_ = false; }

private:
  static bool instantiated_;
};

bool FileSystem::instantiated_ = false;
<span class="boring">}
</span></code></pre></pre>
<p>这个类允许任何人构建它，如果你试图构建超过一个实例，它会断言并失败。
只要正确的代码首先创建了实例，那么就保证了没有其他代码可以接触实例或者创建自己的实例。
这个类保证满足了它关注的单一实例，但是它没有指定类该如何被使用。</p>
<blockquote>
<p><em>断言</em> 函数是一种向你的代码中添加限制的方法。
当<code>assert()</code>被调用时，它计算传入的表达式。
如果结果为<code>true</code>，那么什么都不做，游戏继续。
如果结果为<code>false</code>，它立刻停止游戏。
在 debug build 时，这通常会启动调试器，或至少打印失败断言所在的文件和行号。</p>
<p><code>assert()</code>表示，
“我断言这个总该是真的。如果不是，那就是漏洞，我想<strong>立刻</strong>停止并处理它。”
这使得你可以在代码区域之间定义约束。
如果函数断言它的某个参数不能为<code>NULL</code>，那就是说，“我和调用者定下了协议：传入的参数不会<code>NULL</code>。”</p>
<p>断言帮助我们在游戏发生预期以外的事时立刻追踪漏洞，
而不是等到错误最终显现在用户可见的某些事物上。
它们是代码中的栅栏，围住漏洞，这样漏洞就不能从制造它的代码边逃开。</p>
</blockquote>
<p>这个实现的缺点是只在<strong>运行时</strong>检查并阻止多重实例化。
单例模式正相反，通过类的自然结构，在编译时就能确定实例是单一的。</p>
<h3><a class="header" href="#为了给实例提供方便的访问方法" id="为了给实例提供方便的访问方法">为了给实例提供方便的访问方法</a></h3>
<p>便利的访问是我们使用单例的一个主要原因。
这让我们在不同地方获取需要的对象更加容易。
这种便利是需要付出代价的——在我们<strong>不想</strong>要对象的地方，也能轻易地使用。</p>
<p>通用原则是在能完成工作的同时，将变量写得尽可能局部。
对象影响的范围越小，在处理它时，我们需要放在脑子里的东西就越少。
在我们拿起有<strong>全局</strong>范围影响的单例对象前，先考虑考虑代码中其他获取对象的方式：</p>
<ul>
<li><strong>传进来。</strong>
最简单的解决办法，通常也是最好的，把你需要的对象简单地作为参数传给需要它的函数。
在用其他更加繁杂的方法前，考虑一下这个解决方案。</li>
</ul>
<blockquote>
<p>有些人使用术语“依赖注入”来指代它。不是代码<strong>出来</strong>调用某些全局量来确认依赖，
而是依赖通过参数被<strong>传进</strong>到需要它的代码中去。
其他人将“依赖注入”保留为对代码提供更复杂依赖的方法。</p>
</blockquote>
<p>考虑渲染对象的函数。为了渲染，它需要接触一个代表图形设备的对象，管理渲染状态。
将其传给所有渲染函数是很自然的，通常是用一个名字像<code>context</code>之类的参数。</p>
<p>另一方面，有些对象不该在方法的参数列表中出现。
举个例子，处理 AI 的函数可能也需要写日志文件，但是日志不是它的核心关注点。
看到<code>Log</code>出现在它的参数列表中是很奇怪的事情，像这样的情况，我们需要考虑其他的选项。</p>
<blockquote>
<p>像日志这样散布在代码库各处的是“横切关注点”(cross-cutting concern)。
小心地处理横切关注点是架构中的持久挑战，特别是在静态类型语言中。</p>
<p><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">面向切面编程</a>被设计出来应对它们。</p>
</blockquote>
<ul>
<li><strong>从基类中获得。</strong>
很多游戏架构有浅层但是宽泛的继承层次，通常只有一层深。
举个例子，你也许有<code>GameObject</code>基类，每个游戏中的敌人或者对象都继承它。
使用这样的架构，很大一部分游戏代码会存在于这些“子”推导类中。
这就意味着这些类已经有了对同样事物的相同获取方法：它们的<code>GameObject</code>基类。
我们可以利用这点：</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class GameObject
{
protected:
  Log&amp; getLog() { return log_; }

private:
  static Log&amp; log_;
};

class Enemy : public GameObject
{
  void doSomething()
  {
    getLog().write(&quot;I can log!&quot;);
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>这保证任何<code>GameObject</code>之外的代码都不能接触<code>Log</code>对象，但是每个派生的实体都确实能使用<code>getLog()</code>。
这种使用 protected 函数，让派生对象使用的模式，
被涵盖在<a href="05-2%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1.html">子类沙箱</a>这章中。</p>
<blockquote>
<p>这也引出了一个新问题，“<code>GameObject</code>是怎样获得<code>Log</code>实例的？”一个简单的方案是，让基类创建并拥有静态实例。</p>
<p>如果你不想要基类承担这些，你可以提供一个初始化函数传入<code>Log</code>实例，
或使用<a href="06-3%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html">服务定位器</a>模式找到它。</p>
</blockquote>
<ul>
<li>
<p><strong>从已经是全局的东西中获取。</strong>
移除<strong>所有</strong>全局状态的目标令人钦佩，但并不实际。大多数代码库仍有一些全局可用对象，比如一个代表了整个游戏状态的<code>Game</code>或<code>World</code>对象。</p>
<p>我们可以让现有的全局对象捎带需要的东西，来减少全局变量类的数目。不让<code>Log</code>，<code>FileSystem</code>和<code>AudioPlayer</code>都变成单例，而是这样做：</p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Game
{
public:
  static Game&amp; instance() { return instance_; }

  // 设置log_, et. al. ……

  Log&amp;         getLog()         { return *log_; }
  FileSystem&amp;  getFileSystem()  { return *fileSystem_; }
  AudioPlayer&amp; getAudioPlayer() { return *audioPlayer_; }

private:
  static Game instance_;

  Log         *log_;
  FileSystem  *fileSystem_;
  AudioPlayer *audioPlayer_;
};
<span class="boring">}
</span></code></pre></pre>
<p>这样，只有<code>Game</code>是全局可见的。函数可以通过它访问其他系统。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Game::instance().getAudioPlayer().play(VERY_LOUD_BANG);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>纯粹主义者会声称这违反了 Demeter 法则。我则声称这比一大坨单例要好。</p>
</blockquote>
<p>如果，稍后，架构被改为支持多个<code>Game</code>实例（可能是为了流处理或者测试），<code>Log</code>，<code>FileSystem</code>，和<code>AudioPlayer</code>都不会被影响到——它们甚至不知道有什么区别。缺陷是，当然，更多的代码耦合到了<code>Game</code>中。如果一个类简单地需要播放声音，为了访问音频播放器，上例中仍然需要它知道游戏世界。</p>
<p>我们通过混合方案解决这点。知道<code>Game</code>的代码可以直接从它那里访问<code>AudioPlayer</code>。而不知道的代码，我们用上面描述的其他选项来提供<code>AudioPlayer</code>。</p>
<ul>
<li><strong>从服务定位器中获得。</strong><br />
目前为止，我们假设全局类是具体的类，比如<code>Game</code>。另一种选项是定义一个类，存在的唯一目标就是为对象提供全局访问。这种常见的模式被称为<a href="06-3%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html">服务定位器</a>模式，有单独讲它的章节。</li>
</ul>
<h2><a class="header" href="#单例中还剩下什么" id="单例中还剩下什么">单例中还剩下什么</a></h2>
<p>剩下的问题，何处我们<strong>应该</strong>使用真实的单例模式？说实话，我从来没有在游戏中使用全部的 GoF 模式。为了保证实例是单一的，我通常简单地使用静态类。如果这无效，我使用静态标识位，在运行时检测是不是只有一个实例被创建了。</p>
<p>书中还有一些其他章节也许能有所帮助。<a href="05-2%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1.html">子类沙箱</a>模式通过分享状态，给实例以类的访问权限而无需让其全局可用。<a href="06-3%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html">服务定位器</a>模式<strong>确实</strong>让一个对象全局可用，但它给了你如何设置对象的灵活性。</p>
<h1><a class="header" href="#状态模式" id="状态模式">状态模式</a></h1>
<p>忏悔时间：我有些越界，将太多的东西打包到了这章中。
它表面上关于<a href="http://en.wikipedia.org/wiki/State_pattern">状态模式</a>，
但我无法只讨论它和游戏，而不涉及更加基础的<strong>有限状态机（FSMs）</strong>。
但是一旦讲了那个，我发现也想要介绍<strong>层次状态机</strong>和<strong>下推自动机</strong>。</p>
<p>有很多要讲，我会尽可能简短，这里的示例代码留下了一些你需要自己填补的细节。
我希望它们仍然足够清晰，能让你获取一份全景图。</p>
<p>如果你从来没有听说过状态机，不要难过。
虽然在 AI 和编译器程序方面很出名，但它在其他编程圈就没那么知名了。
我认为应该有更多人知道它，所以在这里我将其运用在不同的问题上。</p>
<blockquote>
<p>这些状态机术语来自人工智能的早期时代。
在五十年代到六十年代，很多 AI 研究关注于语言处理。
很多现在用于分析程序语言的技术在当时是发明出来分析人类语言的。</p>
</blockquote>
<h2><a class="header" href="#感同身受" id="感同身受">感同身受</a></h2>
<p>假设我们在完成一个卷轴平台游戏。
现在的工作是实现玩家在游戏世界中操作的女英雄。
这就意味着她需要对玩家的输入做出响应。按 B 键她应该跳跃。简单实现如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    yVelocity_ = JUMP_VELOCITY;
    setGraphics(IMAGE_JUMP);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>看到漏洞了吗？</p>
<p>没有东西阻止“空中跳跃”——当角色在空中时狂按 B，她就会浮空。
简单的修复方法是给<code>Heroine</code>增加<code>isJumping_</code>布尔字段，追踪它跳跃的状态。然后这样做：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_)
    {
      isJumping_ = true;
      // 跳跃……
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里也应该有在英雄接触到地面时将<code>isJumping_</code>设回<code>false</code>的代码。
我在这里为了简明没有写。</p>
</blockquote>
<p>接下来，当玩家按下下方向键时，如果角色在地上，我们想要她卧倒，而松开按键时站起来：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    // 如果没在跳跃，就跳起来……
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      setGraphics(IMAGE_DUCK);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    setGraphics(IMAGE_STAND);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>这次看到漏洞了吗？</p>
<p>通过这个代码，玩家可以：</p>
<ol>
<li>按下键卧倒。</li>
<li>按 B 从卧倒状态跳起。</li>
<li>在空中放开下键。</li>
</ol>
<p>英雄跳一半贴图变成了站立时的贴图。是时候增加另一个标识了……</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_ &amp;&amp; !isDucking_)
    {
      // 跳跃……
    }
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      isDucking_ = true;
      setGraphics(IMAGE_DUCK);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    if (isDucking_)
    {
      isDucking_ = false;
      setGraphics(IMAGE_STAND);
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>下面，如果玩家在跳跃途中按下下方向键，英雄能够做跳斩攻击就太酷了：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_ &amp;&amp; !isDucking_)
    {
      // 跳跃……
    }
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      isDucking_ = true;
      setGraphics(IMAGE_DUCK);
    }
    else
    {
      isJumping_ = false;
      setGraphics(IMAGE_DIVE);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    if (isDucking_)
    {
      // 站立……
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>又是检查漏洞的时间了。找到了吗？</p>
<p>跳跃时我们检查了字段，防止了空气跳，但是速降时没有。又是另一个字段……</p>
<p>我们的实现方法很明显有错。
每次我们改动代码时，就破坏些东西。
我们需要增加更多动作——<em>行走</em> 都还没有加入呢——但以这种做法，完成之前就会造成一堆漏洞。</p>
<blockquote>
<p>那些你崇拜的、看上去永远能写出完美代码的程序员并不是超人。
相反，他们有<strong>哪种</strong>代码易于出错的直觉，然后避开。</p>
<p>复杂分支和可变状态——随时间改变的字段——是两种易错代码，上面的例子覆盖了两者。</p>
</blockquote>
<h2><a class="header" href="#有限状态机前来救援" id="有限状态机前来救援">有限状态机前来救援</a></h2>
<p>在经历了上面的挫败之后，把桌子扫空，只留下纸笔，我们开始画流程图。
你给英雄每件能做的事情都画了一个盒子：站立，跳跃，俯卧，跳斩。
当角色在能响应按键的状态时，你从那个盒子画出一个箭头，标记上按键，然后连接到她变到的状态。</p>
<p><img src="https://gpp.tkchu.me/images/state-flowchart.png" alt="一张画有盒子的图表，盒子代表了站立，跳跃，俯卧和跳斩。标记了按键的按下和释放的箭头连接了这些盒子。" /></p>
<p>祝贺，你刚刚建好了一个<strong>有限状态机</strong>。
它来自计算机科学的分支<strong>自动理论</strong>，那里有很多著名的数据结构，包括著名的图灵机。
FSMs 是其中最简单的成员。</p>
<p>要点是：</p>
<ul>
<li>
<p><strong>你拥有状态机所有可能<em>状态</em>的集合。</strong>
在我们的例子中，是站立，跳跃，俯卧和速降。</p>
</li>
<li>
<p><strong>状态机同时只能在<em>一个</em>状态。</strong>
英雄不可能同时处于跳跃和站立状态。事实上，防止这点是使用 FSM 的理由之一。</p>
</li>
<li>
<p><strong>一连串的<em>输入</em>或<em>事件</em>被发送给状态机。</strong>
在我们的例子中，就是按键按下和松开。</p>
</li>
<li>
<p><strong>每个状态都有<em>一系列的转移</em>，每个转移与输入和另一状态相关。</strong>
当输入进来，如果它与当前状态的某个转移相匹配，机器转换为所指的状态。</p>
<p>举个例子，在站立状态时，按下下方向键转换为俯卧状态。
在跳跃时按下下方向键转换为速降。
如果输入在当前状态没有定义转移，输入就被忽视。</p>
</li>
</ul>
<p>这就是核心部分的全部了：状态，输入，和转移。
你可以用一张流程图把它画出来。不幸的是，编译器不认识流程图，
所以我们如何<strong>实现</strong>一个？
GoF 的状态模式是一个方法——我们会谈到的——但先从简单的开始。</p>
<blockquote>
<p>对 FSMs 我最喜欢的类比是那种老式文字冒险游戏，比如 Zork。
你有个由屋子组成的世界，屋子彼此通过出口相连。你输入像“去北方”的导航指令探索屋子。</p>
<p>这其实就是状态机：每个屋子都是一个状态。
你现在在的屋子是当前状态。每个屋子的出口是它的转移。
导航指令是输入。</p>
</blockquote>
<h2><a class="header" href="#枚举和分支" id="枚举和分支">枚举和分支</a></h2>
<p><code>Heroine</code>类的问题在于它不合法地捆绑了一堆布尔量：
<code>isJumping_</code>和<code>isDucking_</code>不会同时为真。
但有些标识同时只能有一个是<code>true</code>，这提示你真正需要的其实是<code>enum</code>（枚举）。</p>
<p>在这个例子中的<code>enum</code>就是 FSM 的状态的集合，所以让我们这样定义它：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum State
{
  STATE_STANDING,
  STATE_JUMPING,
  STATE_DUCKING,
  STATE_DIVING
};
<span class="boring">}
</span></code></pre></pre>
<p>不需要一堆标识，<code>Heroine</code>只有一个<code>state_</code>状态。
这里我们同时改变了分支顺序。在前面的代码中，我们先判断输入，<em>然后</em> 判断状态。
这让处理某个按键的代码集中到了一处，但处理某个状态的代码分散到了各处。
我们想让处理状态的代码聚在一起，所以先对状态做分支。这样的话：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  switch (state_)
  {
    case STATE_STANDING:
      if (input == PRESS_B)
      {
        state_ = STATE_JUMPING;
        yVelocity_ = JUMP_VELOCITY;
        setGraphics(IMAGE_JUMP);
      }
      else if (input == PRESS_DOWN)
      {
        state_ = STATE_DUCKING;
        setGraphics(IMAGE_DUCK);
      }
      break;

    case STATE_JUMPING:
      if (input == PRESS_DOWN)
      {
        state_ = STATE_DIVING;
        setGraphics(IMAGE_DIVE);
      }
      break;

    case STATE_DUCKING:
      if (input == RELEASE_DOWN)
      {
        state_ = STATE_STANDING;
        setGraphics(IMAGE_STAND);
      }
      break;
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这看起来很普通，但是比起前面的代码是个很大的进步。
我们仍有条件分支，但简化了状态变化，将它变成了字段。
处理同一状态的所有代码都聚到了一起。
这是实现状态机最简单的方法，在某些情况下，这也不错。</p>
<p>重要的是，英雄不再会处于<strong>不合法</strong>状态。
使用布尔标识，很多可能存在的值的组合是不合法的。
通过<code>enum</code>，每个值都是合法的。</p>
</blockquote>
<p>但是，你的问题也许超过了这个解法的能力范围。
假设我们想增加一个动作动作，英雄可以俯卧一段时间充能，之后释放一次特殊攻击。
当她俯卧时，我们需要追踪充能的持续时间。</p>
<p>我们为<code>Heroine</code>添加了<code>chargeTime_</code>字段，记录充能的时间长度。
假设我们已经有一个每帧都会调用的<code>update()</code>方法。在那里，我们添加：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::update()
{
  if (state_ == STATE_DUCKING)
  {
    chargeTime_++;
    if (chargeTime_ &gt; MAX_CHARGE)
    {
      superBomb();
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>如果你猜这就是<a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a>模式，恭喜你答对了！</p>
</blockquote>
<p>我们需要在她开始俯卧的时候重置计时器，所以我们修改<code>handleInput()</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  switch (state_)
  {
    case STATE_STANDING:
      if (input == PRESS_DOWN)
      {
        state_ = STATE_DUCKING;
        chargeTime_ = 0;
        setGraphics(IMAGE_DUCK);
      }
      // 处理其他输入……
      break;

      // 其他状态……
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>总而言之，为了增加这个充能攻击，我们需要修改两个方法，
添加一个<code>chargeTime_</code>字段到<code>Heroine</code>，哪怕它只在俯卧时有意义。
我们更喜欢的是让所有相关的代码和数据都待在同一个地方。GoF 完成了这个。</p>
<h2><a class="header" href="#什么是状态模式" id="什么是状态模式">什么是状态模式</a></h2>
<p>对于那些思维模式深深沉浸在面向对象的人，每个条件分支都是使用动态分配的机会（在 C++中叫做虚方法调用）。
我觉得那就太过于复杂化了。有时候一个<code>if</code>就能满足你的需要了。</p>
<blockquote>
<p>这里有个历史遗留问题。
原先的面向对象传教徒，比如写《设计模式》的 GoF 和写《重构》的 Martin Fowler 都使用 Smalltalk。
那里，<code>ifThen:</code>只是个由你在一定情况下使用的方法，该方法在<code>true</code>和<code>false</code>对象中以不同的方式实现。</p>
</blockquote>
<p>但是在我们的例子中，面向对象确实是一个更好的方案。
这带领我们走向状态模式。GoF 这样描述状态模式：</p>
<blockquote>
<blockquote>
<blockquote>
<p>允许一个对象在其内部状态发生变化时改变自己的行为，该对象看起来好像修改了它的类型。</p>
</blockquote>
</blockquote>
</blockquote>
<p>这可没太多帮助。我们的<code>switch</code>也完成了这一点。
它们描述的东西应用在英雄的身上实际是：</p>
<h3><a class="header" href="#一个状态接口" id="一个状态接口">一个状态接口</a></h3>
<p>首先，我们为状态定义接口。
状态相关的行为——之前用<code>switch</code>的每一处——都成为了接口中的虚方法。
在我们的例子中，那是<code>handleInput()</code>和<code>update()</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class HeroineState
{
public:
  virtual ~HeroineState() {}
  virtual void handleInput(Heroine&amp; heroine, Input input) {}
  virtual void update(Heroine&amp; heroine) {}
};
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#为每个状态写个类" id="为每个状态写个类">为每个状态写个类</a></h3>
<p>对于每个状态，我们定义一个类实现接口。它的方法定义了英雄在状态的行为。
换言之，从之前的<code>switch</code>中取出每个<code>case</code>，将它们移动到状态类中。举个例子：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class DuckingState : public HeroineState
{
public:
  DuckingState()
  : chargeTime_(0)
  {}

  virtual void handleInput(Heroine&amp; heroine, Input input) {
    if (input == RELEASE_DOWN)
    {
      // 改回站立状态……
      heroine.setGraphics(IMAGE_STAND);
    }
  }

  virtual void update(Heroine&amp; heroine) {
    chargeTime_++;
    if (chargeTime_ &gt; MAX_CHARGE)
    {
      heroine.superBomb();
    }
  }

private:
  int chargeTime_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意我们也将<code>chargeTime_</code>移出了<code>Heroine</code>，放到了<code>DuckingState</code>类中。
这很好——那部分数据只在这个状态有用，现在我们的对象模型显式反映了这一点。</p>
<h3><a class="header" href="#状态委托" id="状态委托">状态委托</a></h3>
<p>接下来，向<code>Heroine</code>添加指向当前状态的指针，放弃庞大的<code>switch</code>，转向状态委托：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Heroine
{
public:
  virtual void handleInput(Input input)
  {
    state_-&gt;handleInput(*this, input);
  }

  virtual void update()
  {
    state_-&gt;update(*this);
  }

  // 其他方法……
private:
  HeroineState* state_;
};
<span class="boring">}
</span></code></pre></pre>
<p>为了“改变状态”，我们只需要将<code>state_</code>声明指向不同的<code>HeroineState</code>对象。
这就是状态模式的全部了。</p>
<blockquote>
<p>这看上去有些像<a href="http://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>和<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>模式。
在三者中，你都有一个主对象委托给下属。区别在于<strong>意图</strong>。</p>
<ul>
<li>在策略模式中，目标是解耦主类和它的部分行为。</li>
<li>在类型对象中，目标是通过<strong>共享</strong>一个对相同类型对象的引用，让一<strong>系列</strong>对象行为相近。</li>
<li>在状态模式中，目标是让主对象通过<strong>改变</strong>委托的对象，来<strong>改变</strong>它的行为。</li>
</ul>
</blockquote>
<h2><a class="header" href="#状态对象在哪里" id="状态对象在哪里">状态对象在哪里</a></h2>
<p>我这里掩掩藏了一些细节。为了改变状态，我们需要声明<code>state_</code>指向新的状态，
但那个新状态又是从哪里来呢？
在<code>enum</code>实现中，这都不用过脑子——<code>enum</code>实际上就像数字一样。
但是现在状态是类了，意味着我们需要指向实例。通常这有两种方案：</p>
<h3><a class="header" href="#静态状态" id="静态状态">静态状态</a></h3>
<p>如果状态对象没有其他数据字段，
那么它存储的唯一数据就是指向虚方法表的指针，用来调用它的方法。
在这种情况下，没理由产生多个实例。毕竟每个实例都完全一样。</p>
<blockquote>
<p>如果你的状态没有字段，只有<strong>一个</strong>虚方法，你可以再简化这个模式。
将每个状态<strong>类</strong>替换成状态<strong>函数</strong>——只是一个普通的顶层函数。
然后，主类中的<code>state_</code>字段变成一个简单的函数指针。</p>
</blockquote>
<p>在那种情况下，你可以用一个<strong>静态</strong>实例。
哪怕你有一堆 FSM 同时在同一状态上运行，它们也能指向同一实例，因为状态没有与状态机相关的部分。</p>
<blockquote>
<p>这是<a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a>。</p>
</blockquote>
<p>在<strong>哪里</strong>放置静态实例取决于你。找一个合理的地方。
没什么特殊的理由，在这里我将它放在状态基类中。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class HeroineState
{
public:
  static StandingState standing;
  static DuckingState ducking;
  static JumpingState jumping;
  static DivingState diving;

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>每个静态字段都是游戏状态类的一个实例。为了让英雄跳跃，站立状态会这样做：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if (input == PRESS_B)
{
  heroine.state_ = &amp;HeroineState::jumping;
  heroine.setGraphics(IMAGE_JUMP);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#实例化状态" id="实例化状态">实例化状态</a></h3>
<p>有时没那么容易。静态状态对俯卧状态不起作用。
它有一个<code>chargeTime_</code>字段，与正在俯卧的英雄特定相关。
在游戏中，如果只有一个英雄，那也行，但是如果要添加双人合作，同时在屏幕上有两个英雄，就有麻烦了。</p>
<p>在那种情况下，转换时需要创建状态对象。
这需要每个 FSM 拥有自己的状态实例。如果我们分配<strong>新</strong>状态，
那意味着我们需要释放<strong>当前的</strong>状态。
在这里要小心，由于触发变化的代码是当前状态中的方法，需要删除<code>this</code>，因此需要小心从事。</p>
<p>相反，我们允许<code>HeroineState</code>中的<code>handleInput()</code>返回一个新状态。
如果它那么做了，<code>Heroine</code>会删除旧的，然后换成新的，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  HeroineState* state = state_-&gt;handleInput(*this, input);
  if (state != NULL)
  {
    delete state_;
    state_ = state;
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样，直到从之前的状态返回，我们才需要删除它。
现在，站立状态可以通过创建新实例转换为俯卧状态：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>HeroineState* StandingState::handleInput(Heroine&amp; heroine, Input input)
{
  if (input == PRESS_DOWN)
  {
    // 其他代码……
    return new DuckingState();
  }

  // 保持这个状态
  return NULL;
}
<span class="boring">}
</span></code></pre></pre>
<p>如果可以，我倾向于使用静态状态，因为它们不会在状态转换时消耗太多的内存和 CPU。
但是，对于更<strong>多状态的事物</strong>，需要耗费一些精力来实现。</p>
<blockquote>
<p>当你为状态动态分配内存时，你也许会担心碎片。<a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池模式</a>可以帮上忙。</p>
</blockquote>
<h2><a class="header" href="#入口行为和出口行为" id="入口行为和出口行为">入口行为和出口行为</a></h2>
<p>状态模式的目标是将状态的行为和数据封装到单一类中。
我们完成了一部分，但是还有一些未了之事。</p>
<p>当英雄改变状态时，我们也改变她的贴图。
现在，那部分代码在她转换<strong>前</strong>的状态中。
当她从俯卧转为站立，俯卧状态修改了她的贴图：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>HeroineState* DuckingState::handleInput(Heroine&amp; heroine,Input input)
{
  if (input == RELEASE_DOWN)
  {
    heroine.setGraphics(IMAGE_STAND);
    return new StandingState();
  }

  // 其他代码……
}
<span class="boring">}
</span></code></pre></pre>
<p>我们想做的是，每个状态控制自己的贴图。这可以通过给状态一个<strong>入口行为</strong>来实现：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class StandingState : public HeroineState
{
public:
  virtual void enter(Heroine&amp; heroine)
  {
    heroine.setGraphics(IMAGE_STAND);
  }

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>在<code>Heroine</code>中，我们将处理状态改变的代码移动到新状态上调用：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  HeroineState* state = state_-&gt;handleInput(*this, input);
  if (state != NULL)
  {
    delete state_;
    state_ = state;

    // 调用新状态的入口行为
    state_-&gt;enter(*this);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>这让我们将俯卧代码简化为：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>HeroineState* DuckingState::handleInput(Heroine&amp; heroine,
                                        Input input)
{
  if (input == RELEASE_DOWN)
  {
    return new StandingState();
  }

  // 其他代码……
}
<span class="boring">}
</span></code></pre></pre>
<p>它做的所有事情就是转换到站立状态，站立状态控制贴图。
现在我们的状态真正地封装了。
关于入口行为的好事就是，当你进入状态时，不必关心你是从哪个状态转换<strong>来的</strong>。</p>
<p>大多数真正的状态图都有转为同一状态的多个转移。
举个例子，英雄在跳跃或跳斩后进入站立状态。
这意味着我们在转换发生的最后重复相同的代码。
入口行为很好地解决了这一点。</p>
<p>我们能，当然，扩展并支持<strong>出口行为</strong>。
这是在我们<strong>离开</strong>现有状态，转换到新状态之前调用的方法。</p>
<h2><a class="header" href="#有什么收获" id="有什么收获">有什么收获</a></h2>
<p>我花了这么长时间向您推销 FSMs，现在我们来捋一捋。
我到现在讲的都是真的，FSM 能很好地解决一些问题。但它们最大的优点也是它们最大的缺点。</p>
<p>状态机通过使用有约束的结构来理清杂乱的代码。
你只需一个固定状态的集合，单一的当前状态，和一些硬编码的转换。</p>
<blockquote>
<p>一个有限状态机甚至不是<strong>图灵完全的</strong>。
自动理论用一系列抽象模型描述计算，每种都比之前的复杂。
<em>图灵机</em> 是其中最具有表现力的模型之一。</p>
<p>“图灵完全”意味着一个系统（通常是编程语言）足以在内部实现一个图灵机，也就意味着，在某种程度上，所有的图灵完全具有同样的表现力。
FSMs 不够灵活，并不在其中。</p>
</blockquote>
<p>如果你需要为更复杂的东西使用状态机，比如游戏 AI，你会撞到这个模型的限制上。
感谢上天，我们的前辈找到了一些方法来避免这些限制。我会在这一章的最后简单地浏览一下它们。</p>
<h2><a class="header" href="#并发状态机" id="并发状态机">并发状态机</a></h2>
<p>我们决定赋予英雄拿枪的能力。
当她拿着枪的时候，她还是能做她之前的任何事情：跑动，跳跃，跳斩，等等。
但是她在做这些的同时也要能开火。</p>
<p>如果我们执着于 FSM，我们需要<strong>翻倍</strong>现有状态。
对于每个现有状态，我们需要另一个她持枪状态：站立，持枪站立，跳跃，持枪跳跃，
你知道我的意思了吧。</p>
<p>多加几种武器，状态就会指数爆炸。
不但增加了大量的状态，也增加了大量的冗余：
持枪和不持枪的状态是完全一样的，只是多了一点负责射击的代码。</p>
<p>问题在于我们将两种状态绑定到了一个状态机上——她<strong>做的</strong>和她<strong>携带的</strong>。
为了处理所有可能的组合，我们需要为每一<strong>对</strong>组合写一个状态。
修复方法很明显：使用两个单独的状态机。</p>
<blockquote>
<p>如果她在做什么有<strong>n</strong>个状态，而她携带了什么有<strong>m</strong>个状态，要塞到一个状态机中，
我们需要<strong>n × m</strong>个状态。使用两个状态机，就只有<strong>n + m</strong>个。</p>
</blockquote>
<p>我们保留之前记录她在做什么的状态机，不用管它。
然后定义她携带了什么的单独状态机。
<code>Heroine</code>将会有<strong>两个</strong>“状态”引用，每个对应一个状态机，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Heroine
{
  // 其他代码……

private:
  HeroineState* state_;
  HeroineState* equipment_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>为了便于说明，她的装备也使用了状态模式。在实践中，由于装备只有两个状态，一个布尔标识就够了。</p>
</blockquote>
<p>当英雄把输入委托给了状态，两个状态都需要委托：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Heroine::handleInput(Input input)
{
  state_-&gt;handleInput(*this, input);
  equipment_-&gt;handleInput(*this, input);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>功能更完备的系统也许能让状态机<strong>销毁</strong>输入，这样其他状态机就不会收到了。这能阻止两个状态机响应同一输入。</p>
</blockquote>
<p>每个状态机之后都能响应输入，发生行为，独立于其它机器改变状态。
当两个状态集合几乎没有联系的时候，它工作得不错。</p>
<p>在实践中，你会发现状态有时需要交互。
举个例子，也许她在跳跃时不能开火，或者她在持枪时不能跳斩攻击。
为了完成这个，你也许会在状态的代码中做一些粗糙的<code>if</code>测试<strong>其他</strong>状态来协同，
这不是最优雅的解决方案，但这可以搞定工作。</p>
<h2><a class="header" href="#分层状态机" id="分层状态机">分层状态机</a></h2>
<p>再充实一下英雄的行为，她可能会有更多相似的状态。
举个例子，她也许有站立、行走、奔跑和滑铲状态。在这些状态中，按 B 跳，按下蹲。</p>
<p>如果使用简单的状态机实现，我们在每个状态中的都重复了代码。
如果我们能够实现一次，在多个状态间重用就好了。</p>
<p>如果这是面向对象的代码而不是状态机的，在状态间分享代码的方式是通过继承。
我们可以为“在地面上”定义一个类处理跳跃和速降。
站立、行走、奔跑和滑铲都从它继承，然后增加各自的附加行为。</p>
<blockquote>
<p>它的影响有好有坏。
继承是一种有力的代码重用工具，但也在两块代码间建立了非常强的耦合。
这是重锤，所以请小心使用。</p>
</blockquote>
<p>你会发现，这是个被称为<strong>分层状态机</strong>的通用结构。
状态可以有<strong>父状态</strong>（这让它变为<strong>子状态</strong>）。
当一个事件进来，如果子状态没有处理，它就会交给链上的父状态。
换言之，它像重载的继承方法那样运作。</p>
<p>事实上，如果我们使用状态模式实现 FSM，我们可以使用继承来实现层次。
定义一个基类作为父状态：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class OnGroundState : public HeroineState
{
public:
  virtual void handleInput(Heroine&amp; heroine, Input input)
  {
    if (input == PRESS_B)
    {
      // 跳跃……
    }
    else if (input == PRESS_DOWN)
    {
      // 俯卧……
    }
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>每个子状态继承它：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class DuckingState : public OnGroundState
{
public:
  virtual void handleInput(Heroine&amp; heroine, Input input)
  {
    if (input == RELEASE_DOWN)
    {
      // 站起……
    }
    else
    {
      // 没有处理输入，返回上一层
      OnGroundState::handleInput(heroine, input);
    }
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>这当然不是唯一的实现层次的方法。
如果你没有使用 GoF 的状态模式，这可能不会有用。
相反，你可以显式的使用状态<strong>栈</strong>而不是单一状态来表示当前状态的父状态链。</p>
<p>栈顶的状态是当前状态，在他下面是它的直接父状态，
然后是<strong>那个</strong>父状态的父状态，以此类推。
当你需要状态的特定行为，你从栈的顶端开始，
然后向下寻找，直到某一个状态处理了它。（如果到底也没找到，就无视它。）</p>
<h2><a class="header" href="#下推自动机" id="下推自动机">下推自动机</a></h2>
<p>还有一种有限状态机的扩展也用了状态栈。
容易混淆的是，这里的栈表示的是完全不同的事物，被用于解决不同的问题。</p>
<p>要解决的问题是有限状态机没有任何<strong>历史</strong>的概念。
你记得<strong>正在</strong>什么状态中，但是不记得<strong>曾在</strong>什么状态。
没有简单的办法重回上一状态。</p>
<p>举个例子：早先，我们让无畏英雄武装到了牙齿。
当她开火时，我们需要新状态播放开火动画，发射子弹，产生视觉效果。
所以我们拼凑了一个<code>FiringState</code>，不管现在是什么状态，都能在按下开火按钮时跳转为这个状态。</p>
<blockquote>
<p>这个行为在多个状态间重复，也许是用层次状态机重用代码的好地方。</p>
</blockquote>
<p>问题在于她射击<strong>后</strong>转换到的状态。
她可以在站立、奔跑、跳跃、跳斩时射击。
当射击结束，应该转换为她之前的状态。</p>
<p>如果我们固执于纯粹的 FSM，我们就已经忘了她之前所处的状态。
为了追踪之前的状态，我们定义了很多几乎完全一样的类——站立开火，跑步开火，跳跃开火，诸如此类——
每个都有硬编码的转换，用来回到之前的状态。</p>
<p>我们真正想要的是，它会<strong>存储</strong>开火前所处的状态，之后能<strong>回想</strong>起来。
自动理论又一次能帮上忙了，相关的数据结构被称为<a href="http://en.wikipedia.org/wiki/Pushdown_automaton"><em>下推自动机</em></a>。</p>
<p>有限状态机有<strong>一个</strong>指向状态的指针，下推自动机有<strong>一栈</strong>指针。
在 FSM 中，新状态<strong>代替</strong>了之前的那个状态。
下推自动机不仅能完成那个，还能给你两个额外操作：</p>
<ol>
<li>
<p>你可以将新状态<strong>压入</strong>栈中。“当前的”状态总是在栈顶，所以你能转到新状态。
但它让之前的状态待在栈中而不是销毁它。</p>
</li>
<li>
<p>你可以<strong>弹出</strong>最上面的状态。这个状态会被销毁，它下面的状态成为新状态。</p>
</li>
</ol>
<p><img src="https://gpp.tkchu.me/images/state-pushdown.png" alt="下推自动机的栈。起初只包含了一个站立状态。然后一个开火状态被压入栈顶，当射击结束，开火状态被弹出。" /></p>
<p>这正是我们开火时需要的。我们创建<strong>单一的</strong>开火状态。
当开火按钮在其他状态按下时，我们<strong>压入</strong>开火状态。
当开火动画结束，我们<strong>弹出</strong>开火状态，然后下推自动机自动转回之前的状态。</p>
<h2><a class="header" href="#所以它们有多有用呢" id="所以它们有多有用呢">所以它们有多有用呢</a></h2>
<p>即使状态机有这些常见的扩展，它们还是很受限制。
这让今日游戏 AI 移向了更加激动人心的领域，比如<a href="http://web.archive.org/web/20140402204854/http://www.altdevblogaday.com/2011/02/24/introduction-to-behavior-trees/"><strong>行为树</strong></a>和<a href="http://web.media.mit.edu/%7Ejorkin/goap.html"><strong>规划系统</strong></a> 。
如果你关注复杂 AI，这一整章只是为了勾起你的食欲。
你需要阅读其他书来满足你的欲望。</p>
<p>这不意味着有限状态机，下推自动机，和其他简单的系统没有用。
它们是特定问题的好工具。有限状态机在以下情况有用：</p>
<ul>
<li>你有个实体，它的行为基于一些内在状态。</li>
<li>状态可以被严格地分割为相对较少的不相干项目。</li>
<li>实体响应一系列输入或事件。</li>
</ul>
<p>在游戏中，状态机因在 AI 中使用而闻名，但是它也常用于其他领域，
比如处理玩家输入，导航菜单界面，分析文字，网络协议以及其他异步（asynchronous）行为。</p>
<h1><a class="header" href="#序列模式" id="序列模式">序列模式</a></h1>
<p>电子游戏之所以有趣，很大程度上归功于它们会将我们带到别的地方。
几分钟后（或者，诚实点，可能会更长），我们活在一个虚拟的世界。
创造那样的世界是游戏程序员至上的欢愉。</p>
<p>大多数游戏世界都有的特性是<strong>时间</strong>——虚构世界以其特定的节奏运行。
作为世界的架构师，我们必须发明时间，制造推动游戏时间运作的齿轮。</p>
<p>本篇的模式是建构这些的工具。
<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>是时钟的中心轴。
对象通过<a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a>来聆听时钟的滴答声。
我们可以用<a href="04-1%E5%8F%8C%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F.html">双缓冲模式</a>存储快照来隐藏计算机的顺序执行，这样看起来世界可以进行同步更新。</p>
<h2><a class="header" href="#模式-1" id="模式-1">模式</a></h2>
<ul>
<li><a href="04-1%E5%8F%8C%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F.html">双缓冲模式</a></li>
<li><a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a></li>
<li><a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a></li>
</ul>
<h1><a class="header" href="#双缓冲模式" id="双缓冲模式">双缓冲模式</a></h1>
<h2><a class="header" href="#意图" id="意图">意图</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p><em>用序列的操作模拟瞬间或者同时发生的事情。</em></p>
</blockquote>
</blockquote>
</blockquote>
<h2><a class="header" href="#动机" id="动机">动机</a></h2>
<p>电脑具有强大的序列化处理能力。
它的力量来自于将大的任务分解为小的步骤，这样可以一步接一步的完成。
但是，通常用户需要看到事情发生在瞬间或者让多个任务同时进行。</p>
<blockquote>
<p>使用线程和多核架构让这种说法不那么正确了，但哪怕使用多核，也只有一些操作可以同步运行。</p>
</blockquote>
<p>一个典型的例子，也是每个游戏引擎都得掌控的问题，渲染。
当游戏渲染玩家所见的世界时，它同时需要处理一堆东西——远处的山，起伏的丘陵，树木，每个都在各自的循环中处理。
如果在用户<strong>观察</strong>时增量做这些，连续世界的幻觉就会被打破。
场景必须快速流畅地更新，显示一系列完整的帧，每帧都是立即出现的。</p>
<p>双缓冲解决了这个问题，但是为了理解其原理，让我们首先的复习下计算机是如何显示图形的。</p>
<h3><a class="header" href="#计算机图形系统是如何工作的概述" id="计算机图形系统是如何工作的概述">计算机图形系统是如何工作的（概述）</a></h3>
<p>在电脑屏幕上显示图像是一次绘制一个像素点。
它从左到右扫描每行像素点，然后移动至下一行。
当抵达了右下角，它退回左上角重新开始。
它做得飞快——每秒六十次——因此我们的眼睛无法察觉。
对我们来说，这是一整张静态的彩色像素——一张图像。</p>
<blockquote>
<p>这个解释是“简化过的”。
如果你是底层软件开发人员，跳过下一节吧。
你对这章的其余部分已经了解得够多了。
如果你不是，这部分的目标是给你足够的背景知识，理解等下要讨论的设计模式。</p>
</blockquote>
<p>你可以将整个过程想象为软管向屏幕喷洒像素。
独特的像素从软管的后面流入，然后在屏幕上喷洒，每次对一个像素涂一点颜色。
所以软管怎么知道哪种颜色要喷到哪里？</p>
<p>在大多数电脑上，答案是从<strong>帧缓冲</strong>中获知这些信息。
帧缓冲是内存中的色素数组，RAM 中每两个字节代表表示一个像素点的颜色。
当软管向屏幕喷洒时，它从这个数组中读取颜色值，每次一个字节。</p>
<blockquote>
<p>在字节值和颜色之间的映射通常由系统的<strong>像素格式</strong>和<strong>色深</strong>来指定。
在今日多数游戏主机上，每个像素都有 32 位，红绿蓝三个各占八位，剩下的八位保留作其他用途。</p>
</blockquote>
<p>最终，为了让游戏显示在屏幕中，我们需要做的就是写入这个数组。
我们疯狂摆弄的图形算法最终都到了这里：设置帧缓冲中的字节值。
但这里有个小问题。</p>
<p>早先，我说过计算机是顺序处理的。
如果机器在运行一块渲染代码，我们不指望它同时还能做些别的什么事。
这通常是没啥问题，但是有些事<strong>确实</strong>在程序运行时发生。
其中一件是，当游戏运行时，视频输出正在<strong>不断</strong>从帧缓冲中读取数据。
这可能会为我们带来问题。</p>
<p>假设我们要在屏幕上显示一张笑脸。
程序在帧缓冲上开始循环，为像素点涂色。
我们没有意识到的是，在写入的同时，视频驱动正在读取它。
当它扫描过已写的像素时，笑脸开始浮现，但是之后它进入了未写的部分，就将没有写的像素绘制到了屏幕上。结果就是<strong>撕裂</strong>，你在屏幕上看到了绘制到一半的图像，这是可怕的视觉漏洞。</p>
<p><img src="https://gpp.tkchu.me/images/double-buffer-tearing.png" alt="描述了正在渲染的帧的一系列图片。一个指针在像素上写入，与此同时，另一个指针正在读取。读取的指针越过了写入的指针，然后开始读取未曾渲染的像素点。" /></p>
<blockquote>
<p>显卡设备读取的缓冲帧正是我们绘制像素的那块(Fig. 1)。
显卡最终追上了渲染器，然后越过它，读取了还没有写入的像素(Fig. 2)。
我们完成了绘制，但驱动没有收到那些新像素。</p>
<p>结果(Fig. 4)是用户只看到了一半的绘制结果。
我称它为“哭脸”，笑脸看上去下半部是撕裂的。</p>
</blockquote>
<p>这就是我们需要这个设计模式的原因。
程序一次渲染一个像素，但是显示需要一次全部看到——在这帧中啥也没有，下一帧笑脸全部出现。
双缓冲解决了这个问题。我会用类比来解释。</p>
<h3><a class="header" href="#表演-1场景-1" id="表演-1场景-1">表演 1，场景 1</a></h3>
<p>想象玩家正在观看我们的表演。
在场景一结束而场景二开始时，我们需要改变舞台设置。
如果让场务在场景结束后进去拖动东西，场景的连贯性就被打破了。
我们可以减弱灯光（这是剧院实际上的做法），但是观众还是知道<strong>有什么</strong>在进行，而我们想在场景间毫无跳跃地转换。</p>
<p>通过消耗一些地皮，我们想到了一个聪明的解决方案：建<strong>两个</strong>舞台，观众两个都能看到。
每个有它自己的一组灯光。我们称这些舞台为舞台 A 和舞台 B。
场景一在舞台 A 上。同时场务在处于黑暗之中的舞台 B 布置场景二。
当场景一完成后，将切断场景 A 的灯光，打开场景 B 的灯光。观众看向新舞台，场景二立即开始。</p>
<p>同时，场务到了黑咕隆咚的舞台<strong>A</strong>，收拾了场景一然后布置场景<strong>三</strong>。
一旦场景二结束，将灯光转回舞台 A。
我们在整场表演中进行这样的活动，使用黑暗的舞台作为布置下一场景的工作区域。
每一次场景转换，只是在两个舞台间切换灯光。
观众获得了连续的体验，场景转换时没有感到任何中断。他们从来没有见到场务。</p>
<blockquote>
<p>使用单面镜以及其他的巧妙布置，你可以真正地在同一<strong>位置</strong>布置两个舞台。
随着灯光切换，观众看到了不同的舞台，无需看向不同的地方。
如何这样布置舞台就留给读者做练习吧。</p>
</blockquote>
<h3><a class="header" href="#重新回到图形" id="重新回到图形">重新回到图形</a></h3>
<p>这就是双缓冲的工作原理，
这就是你看到的几乎每个游戏背后的渲染系统。
不只用一个帧缓冲，我们用<strong>两个</strong>。其中一个代表现在的帧，即类比中的舞台 A，也就是说是显卡读取的那一个。
GPU 可以想什么时候扫就什么时候扫。</p>
<blockquote>
<p>但不是<strong>所有</strong>的游戏主机都是这么做的。
更老的简单主机中，内存有限，需要小心地同步绘制和渲染。那很需要技巧。</p>
</blockquote>
<p>同时，我们的渲染代码正在写入<strong>另一个</strong>帧缓冲。
即黑暗中的舞台 B。当渲染代码完成了场景的绘制，它将通过<strong>交换</strong>缓存来切换灯光。
这告诉图形硬件开始从第二块缓存中读取而不是第一块。
只要在刷新之前交换，就不会有任何撕裂出现，整个场景都会一下子出现。</p>
<p>这时可以使用以前的帧缓冲了。我们可以将下一帧渲染在它上面了。超棒！</p>
<h2><a class="header" href="#模式-2" id="模式-2">模式</a></h2>
<p>定义<strong>缓冲类</strong>封装了<strong>缓冲</strong>：一段可改变的状态。
这个缓冲被增量地修改，但我们想要外部的代码将修改视为单一的原子操作。
为了实现这点，类保存了<strong>两个</strong>缓冲的实例：<strong>下一缓冲</strong>和<strong>当前缓冲</strong>。</p>
<p>当信息<strong>从</strong>缓冲区中读取，它总是读取<strong>当前的</strong>缓冲区。
当信息需要写<strong>到</strong>缓存，它总是在<strong>下一</strong>缓冲区上操作。
当改变完成后，一个<strong>交换</strong>操作会立刻将当前缓冲区和下一缓冲区交换，
这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。</p>
<h2><a class="header" href="#何时使用" id="何时使用">何时使用</a></h2>
<p>这是那种你需要它时自然会想起的模式。
如果你有一个系统需要双缓冲，它可能有可见的错误（撕裂之类的）或者行为不正确。
但是，“当你需要时自然会想起”没提提供太多有效信息。
更加特殊地，以下情况都满足时，使用这个模式就很恰当：</p>
<ul>
<li>我们需要维护一些被增量修改的状态。</li>
<li>在修改到一半的时候，状态可能会被外部请求。</li>
<li>我们想要防止请求状态的外部代码知道内部的工作方式。</li>
<li>我们想要读取状态，而且不想等着修改完成。</li>
</ul>
<h2><a class="header" href="#记住" id="记住">记住</a></h2>
<p>不像其他较大的架构模式，双缓冲模式位于底层。
正因如此，它对代码库的其他部分影响较小——大多数游戏甚至不会感到有区别。
尽管这里还是有几个警告。</p>
<h3><a class="header" href="#交换本身需要时间" id="交换本身需要时间">交换本身需要时间</a></h3>
<p>在状态被修改后，双缓冲需要一个<strong>swap</strong>步骤。
这个操作必须是原子的——在交换时，没有代码可以接触到<strong>任何一个</strong>状态。
通常，这就是修改一个指针那么快，但是如果交换消耗的时间长于修改状态的时间，那可是毫无助益。</p>
<h3><a class="header" href="#我们得保存两个缓冲区" id="我们得保存两个缓冲区">我们得保存两个缓冲区</a></h3>
<p>这个模式的另一个结果是增加了内存的使用。
正如其名，这个模式需要你在内存中一直保留<strong>两个</strong>状态的拷贝。
在内存受限的设备上，你可能要付出惨痛的代价。
如果你不能接受使用两份内存，你需要使用别的方法保证状态在修改时不会被请求。</p>
<h2><a class="header" href="#示例代码" id="示例代码">示例代码</a></h2>
<p>我们知道了理论，现在看看它在实践中如何应用。
我们编写了一个非常基础的图形系统，允许我们在缓冲帧上描绘像素。
在大多数主机和电脑上，显卡驱动提供了这种底层的图形系统，
但是在这里手动实现有助于理解发生了什么。首先是缓冲区本身：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Framebuffer
{
public:
  Framebuffer() { clear(); }

  void clear()
  {
    for (int i = 0; i &lt; WIDTH * HEIGHT; i++)
    {
      pixels_[i] = WHITE;
    }
  }

  void draw(int x, int y)
  {
    pixels_[(WIDTH * y) + x] = BLACK;
  }

  const char* getPixels()
  {
    return pixels_;
  }

private:
  static const int WIDTH = 160;
  static const int HEIGHT = 120;

  char pixels_[WIDTH * HEIGHT];
};
<span class="boring">}
</span></code></pre></pre>
<p>它有将整个缓存设置成默认的颜色的操作，也将其中一个像素设置为特定颜色的操作。
它也有函数<code>getPixels()</code>，读取保存像素数据的数组。
虽然在这个例子中没有出现，但在实际中，显卡驱动会频繁调用这个函数，将缓存中的数据输送到屏幕上。</p>
<p>我们将整个缓冲区封装在<code>Scene</code>类中。渲染某物需要做的是在这块缓冲区上调用一系列<code>draw()</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Scene
{
public:
  void draw()
  {
    buffer_.clear();

    buffer_.draw(1, 1);
    buffer_.draw(4, 1);
    buffer_.draw(1, 3);
    buffer_.draw(2, 4);
    buffer_.draw(3, 4);
    buffer_.draw(4, 3);
  }

  Framebuffer&amp; getBuffer() { return buffer_; }

private:
  Framebuffer buffer_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>特别地，它画出来这幅旷世杰作：</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/double-buffer-face.png" alt="一个像素风的笑脸" /></p>
<p>每一帧，游戏告诉场景去绘制。场景清空缓冲区然后一个接一个绘制一大堆像素。
它也提供了<code>getBuffer()</code>获得缓冲区，这样显卡可以接触到它。</p>
<p>这看起来直截了当，但是如果就这样做，我们会遇到麻烦。
显卡驱动可以在<strong>任何</strong>时间调用<code>getBuffer()</code>，甚至在这个时候：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>buffer_.draw(1, 1);
buffer_.draw(4, 1);
// &lt;- 图形驱动从这里读取像素！
buffer_.draw(1, 3);
buffer_.draw(2, 4);
buffer_.draw(3, 4);
buffer_.draw(4, 3);
<span class="boring">}
</span></code></pre></pre>
<p>当上面的情况发生时，用户就会看到脸的眼睛，但是这一帧中嘴却消失了。
下一帧，又可能在某些别的地方发生冲突。最终结果是糟糕的闪烁图形。我们会用双缓冲修复这点：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Scene
{
public:
  Scene()
  : current_(&amp;buffers_[0]),
    next_(&amp;buffers_[1])
  {}

  void draw()
  {
    next_-&gt;clear();

    next_-&gt;draw(1, 1);
    // ...
    next_-&gt;draw(4, 3);

    swap();
  }

  Framebuffer&amp; getBuffer() { return *current_; }

private:
  void swap()
  {
    // 只需交换指针
    Framebuffer* temp = current_;
    current_ = next_;
    next_ = temp;
  }

  Framebuffer  buffers_[2];
  Framebuffer* current_;
  Framebuffer* next_;
};
<span class="boring">}
</span></code></pre></pre>
<p>现在<code>Scene</code>有存储在<code>buffers_</code>数组中的两个缓冲区，。
我们并不从数组中直接引用它们。而是通过两个成员，<code>next_</code>和<code>current_</code>，指向这个数组。
当绘制时，我们绘制在<code>next_</code>指向的缓冲区上。
当显卡驱动需要获得像素信息时，它总是通过<code>current_</code>获取<strong>另一个</strong>缓冲区。</p>
<p>通过这种方式，显卡驱动永远看不到我们正在施工的缓冲区。
解决方案的的最后一部分就是在场景完成绘制一帧的时候调用<code>swap()</code>。
它通过交换<code>next_</code>和<code>current_</code>的引用完成这一点。
下一次显卡驱动调用<code>getBuffer()</code>，它会获得我们刚刚完成渲染的新缓冲区，
然后将刚刚描绘好的缓冲区放在屏幕上。没有撕裂，也没有不美观的问题。</p>
<h3><a class="header" href="#不仅是图形" id="不仅是图形">不仅是图形</a></h3>
<p>双缓冲解决的核心问题是状态有可能在被修改的同时被请求。
这通常有两种原因。图形的例子覆盖了第一种原因——另一线程的代码或者另一个中断的代码直接访问了状态。</p>
<p>但是，还有一个同样常见的原因：<em>负责修改的</em> 代码试图访问同样正在修改状态。
这可能发生在很多地方，特别是实体的物理部分和 AI 部分，实体在相互交互。
双缓冲在那里也十分有用。</p>
<h3><a class="header" href="#人工不智能" id="人工不智能">人工不智能</a></h3>
<p>假设我们正在构建一个关于趣味喜剧的游戏的行为系统。
这个游戏包括一堆跑来跑去寻欢作乐的角色。这里是我们的基础角色：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Actor
{
public:
  Actor() : slapped_(false) {}

  virtual ~Actor() {}
  virtual void update() = 0;

  void reset()      { slapped_ = false; }
  void slap()       { slapped_ = true; }
  bool wasSlapped() { return slapped_; }

private:
  bool slapped_;
};
<span class="boring">}
</span></code></pre></pre>
<p>每一帧，游戏要在角色身上调用<code>update()</code>，让角色做些事情。
特别地，从玩家的角度，<em>所有的角色都应该看上去同时更新</em>。</p>
<blockquote>
<p><a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a>模式的例子。</p>
</blockquote>
<p>角色也可以相互交互，这里的“交互”，我指“可以互相扇对方巴掌”。
当更新时，角色可以在另一个角色身上调用<code>slap()</code>来扇它一巴掌，然后调用<code>wasSlapped()</code>看看自己是不是被扇了。</p>
<p>角色需要一个可以交互的舞台，让我们来布置一下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Stage
{
public:
  void add(Actor* actor, int index)
  {
    actors_[index] = actor;
  }

  void update()
  {
    for (int i = 0; i &lt; NUM_ACTORS; i++)
    {
      actors_[i]-&gt;update();
      actors_[i]-&gt;reset();
    }
  }

private:
  static const int NUM_ACTORS = 3;

  Actor* actors_[NUM_ACTORS];
};
<span class="boring">}
</span></code></pre></pre>
<p><code>Stage</code>允许我们向其中增加角色，
然后使用简单的<code>update()</code>调用来更新每个角色。
在用户看来，角色是同时移动的，但是实际上，它们是依次更新的。</p>
<p>这里需要注意的另一点是，每个角色的“被扇”状态在更新后就立刻被清除。
这样才能保证一个角色对一巴掌只反应一次。</p>
<p>作为一切的开始，让我们定义一个具体的角色子类。
这里的喜剧演员很简单。
他只面向一个角色。当他被扇时——无论是谁扇的他——他的反应是扇他面前的人一巴掌。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Comedian : public Actor
{
public:
  void face(Actor* actor) { facing_ = actor; }

  virtual void update()
  {
    if (wasSlapped()) facing_-&gt;slap();
  }

private:
  Actor* facing_;
};
<span class="boring">}
</span></code></pre></pre>
<p>现在我们把一些喜剧演员丢到舞台上看看发生了什么。
我们设置三个演员，第一个面朝第二个，第二个面朝第三个，第三个面对第一个，形成一个环：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Stage stage;

Comedian* harry = new Comedian();
Comedian* baldy = new Comedian();
Comedian* chump = new Comedian();

harry-&gt;face(baldy);
baldy-&gt;face(chump);
chump-&gt;face(harry);

stage.add(harry, 0);
stage.add(baldy, 1);
stage.add(chump, 2);
<span class="boring">}
</span></code></pre></pre>
<p>最终舞台布置如下图。箭头代表角色的朝向，然后数字代表角色在舞台数组中的索引。</p>
<p><img src="https://gpp.tkchu.me/images/double-buffer-slaps-1.png" alt="代表Harry，Baldy和Chump的三个盒子。Harry有一个指向 Baldy的箭头，Baldy有个指向Chump的箭头，Chump有个指向Harry的箭头。" /></p>
<p>我们扇哈利一巴掌，为表演拉开序幕，看看之后会发生什么：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>harry-&gt;slap();

stage.update();
<span class="boring">}
</span></code></pre></pre>
<p>记住<code>Stage</code>中的<code>update()</code>函数轮流更新每个角色，
因此如果检视整个代码，我们会发现事件这样发生：</p>
<pre><code class="language-log">Stage updates actor 0 (Harry)
  Harry was slapped, so he slaps Baldy
Stage updates actor 1 (Baldy)
  Baldy was slapped, so he slaps Chump
Stage updates actor 2 (Chump)
  Chump was slapped, so he slaps Harry
Stage update ends
</code></pre>
<p>在单独的一帧中，初始给哈利的一巴掌传给了所有的喜剧演员。
现在，让事物复杂起来，让我们重新排列舞台数组中角色的排序，
但是继续保持面向对方的方式。</p>
<p><img src="https://gpp.tkchu.me/images/double-buffer-slaps-2.png" alt="还是相同的盒子和箭头，只是顺序变成了Chump, Baldy, Harry。" /></p>
<p>我们不动舞台的其余部分，只是将添加角色到舞台的代码块改为如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>stage.add(harry, 2);
stage.add(baldy, 1);
stage.add(chump, 0);
<span class="boring">}
</span></code></pre></pre>
<p>让我们看看再次运行时会发生什么：</p>
<pre><code class="language-log">Stage updates actor 0 (Chump)
  Chump was not slapped, so he does nothing
Stage updates actor 1 (Baldy)
  Baldy was not slapped, so he does nothing
Stage updates actor 2 (Harry)
  Harry was slapped, so he slaps Baldy
Stage update ends
</code></pre>
<p>哦不。完全不一样了。问题很明显。
更新角色时，我们修改了他们的“被扇”状态，这也是我们在更新时<strong>读取</strong>的状态。
因此，在更新中早先的状态修改会影响之后<strong>同一</strong>状态的修改的步骤。</p>
<blockquote>
<p>如果你继续更新舞台，你会看到巴掌在角色间逐渐传递，每帧传递一个。
在第一帧 Harry 扇了 Baldy。下一帧，Baldy 扇了 Chump，如此类推。</p>
</blockquote>
<p>而最终的结果是，一个角色对被扇作出反应可能是在被扇的<strong>同一</strong>帧或者<strong>下一</strong>帧，
这完全取决于两个角色在舞台上是如何排序的。
这没能满足我让角色同时反应的需求——它们在同一帧中更新的顺序不该对结果有影响。</p>
<h3><a class="header" href="#缓存巴掌" id="缓存巴掌">缓存巴掌</a></h3>
<p>幸运的是，双缓冲模式可以帮忙。
这次，不是保存两大块“缓冲”，我们缓冲更小粒度的事物：每个角色的“被扇”状态。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Actor
{
public:
  Actor() : currentSlapped_(false) {}

  virtual ~Actor() {}
  virtual void update() = 0;

  void swap()
  {
    // 交换缓冲区
    currentSlapped_ = nextSlapped_;

    // 清空新的“下一个”缓冲区。.
    nextSlapped_ = false;
  }

  void slap()       { nextSlapped_ = true; }
  bool wasSlapped() { return currentSlapped_; }

private:
  bool currentSlapped_;
  bool nextSlapped_;
};
<span class="boring">}
</span></code></pre></pre>
<p>不再使用一个<code>slapped_</code>状态，每个演员现在使用两个。
就像我们之前图形的例子一样，当前状态为读准备，下一状态为写准备。</p>
<p><code>reset()</code>函数被替换为<code>swap()</code>。
现在，就在清除交换状态前，它将下一状态拷贝到当前状态上，
使其成为新的当前状态，这还需要在<code>Stage</code>中进行小小的改变：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Stage::update()
{
  for (int i = 0; i &lt; NUM_ACTORS; i++)
  {
    actors_[i]-&gt;update();
  }

  for (int i = 0; i &lt; NUM_ACTORS; i++)
  {
    actors_[i]-&gt;swap();
  }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>update()</code>函数现在更新所有的角色，<em>然后</em> 交换它们的状态。
最终结果是，角色在实际被扇<strong>之后</strong>的那帧才能看到巴掌。
这样一来，角色无论在舞台数组中如何排列，都会保持相同的行为。
无论外部的代码如何调用，所有的角色在一帧内同时更新。</p>
<h2><a class="header" href="#设计决策" id="设计决策">设计决策</a></h2>
<p>双缓冲很直观，我们上面看到的例子也覆盖了大多数你需要的场景。
使用这个模式之前，还需要做两个主要的设计决策。</p>
<h3><a class="header" href="#缓冲区是如何被交换的" id="缓冲区是如何被交换的">缓冲区是如何被交换的</a></h3>
<p>交换操作是整个过程的最重要的一步，
因为在其发生时，我们必须锁住两个缓冲区上的读取和修改。
为了让性能最优，我们需要它进行得越快越好。</p>
<ul>
<li>
<p><strong>交换缓冲区的指针或者引用：</strong>
这是我们图形例子中的做法，这也是大多数双缓冲图形通用的解决方法。</p>
<ul>
<li>
<p><em>速度快。</em> 不管缓冲区有多大，交换都只需赋值一对指针。很难在速度和简易性上超越它。</p>
</li>
<li>
<p><em>外部代码不能存储对缓存的永久指针。</em> 这是主要限制。
由于我们没有真正地移动<strong>数据</strong>，本质上做的是周期性地通知代码库的其他部分到别处去寻找缓存，
就像前面的舞台类比一样。这就意味着代码库的其他部分不能存储指向缓冲区中数据的指针——
它一段时间后可能就指向了错误的部分。</p>
<p>这会严重误导那些期待缓冲帧永远在内存中的固定地址的显卡驱动。在这种情况下，我们不能这么做。</p>
</li>
<li>
<p><em>缓冲区中的数据是两帧之前的数据，而不是上一帧的数据。</em>
接下来的那帧绘制在帧缓冲区上，而不是在它们之间拷贝数据，就像这样：</p>
<pre><code class="language-text">Frame 1 drawn on buffer A
Frame 2 drawn on buffer B
Frame 3 drawn on buffer A
...
</code></pre>
<p>你会注意到，当我们绘制第三帧时，缓冲区上的数据是<strong>第一帧</strong>的，而不是第二帧的。大多数情况下，这不是什么问题——我们通常在绘制之前清空整个帧。但如果想沿用某些缓存中已有的数据，就需要考虑数据其实比期望的更旧。</p>
<blockquote>
<p>旧帧中缓存数据的经典用法是模拟动态模糊。
当前的帧混合一点之前的帧，看起来更像真实的相机捕获的图景。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>在缓冲区之间拷贝数据：</strong>
如果我们不能重定向到其他缓存，唯一的选项就是将下帧的数据实实在在的拷贝到现在这帧上。
这是我们的扇巴掌喜剧的工作方法。
这种情况下，使用这种方法是因为拷贝状态——一个简单的布尔标识——不比修改指向缓存的指针开销大。</p>
<ul>
<li>
<p><em>下一帧的数据和之前的数据相差一帧。</em>
拷贝数据与在两块缓冲区间跳来跳去正相反。
如果我们需要前一帧的数据，这样我们可以处理更新的数据。</p>
</li>
<li>
<p><em>交换也许更花时间。</em>
这个当然是最大的缺点。交换操作现在意味着在内存中拷贝整个缓冲区。
如果缓冲区很大，比如一整个缓冲帧，这需要花费可观的时间。
由于交换时没有东西可以读取或者写入<strong>任何一个</strong>缓冲区，这是一个巨大的限制。</p>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#缓冲的粒度如何" id="缓冲的粒度如何">缓冲的粒度如何</a></h3>
<p>这里的另一个问题是缓冲区本身是如何组织的——是单个数据块还是散布在对象集合中？
图形例子是前一种，而角色例子是后一种。</p>
<p>大多数情况下，你缓存的方式自然而然会引导你找到答案，但是这里也有些灵活度。
比如，角色总能将消息存在独立的消息块中，使用索引来引用。</p>
<ul>
<li>
<p><strong>如果缓存是一整块：</strong></p>
<ul>
<li><em>交换操作更简单。</em>
由于只有一对缓存，一个简单的交换就完成了。
如果可以改变指针来交换，那么不必在意缓冲区大小，只需几部操作就可以交换整个缓冲区。</p></li>
</ul>
</li>
<li>
<p><strong>如果很多对象都持有一块数据：</strong></p>
<ul>
<li>
<p><em>交换操作更慢。</em>
为了交换，需要遍历整个对象集合，通知每个对象交换。</p>
<p>在喜剧的例子中，这没问题，因为反正需要清除被扇状态
——每块缓存的数据每帧都需要接触。
如果不需要接触较旧的帧，可以用通过在多个对象间分散状态来优化，获得使用整块缓存一样的性能。</p>
<p>思路是将“当前”和“下一”指针概念，将它们改为对象相关的<strong>偏移量</strong>。就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Actor
    {
    public:
      static void init() { current_ = 0; }
      static void swap() { current_ = next(); }

      void slap()        { slapped_[next()] = true; }
      bool wasSlapped()  { return slapped_[current_]; }

    private:
      static int current_;
      static int next()  { return 1 - current_; }

      bool slapped_[2];
    };
<span class="boring">}
</span></code></pre></pre>
<p>角色使用<code>current_</code>在状态数组中查询，获得当前的被扇状态，
下一状态总是数组中的另一索引，这样可以用<code>next()</code>来计算。
交换状态只需改动<code>current_</code>索引。
聪明之处在于<code>swap()</code>现在是<strong>静态</strong>函数，它只需被调用一次，<em>每个</em> 角色的状态都会被交换。</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#参见-2" id="参见-2">参见</a></h2>
<ul>
<li>你可以在几乎每个图形 API 中找到双缓冲模式。举个例子，OpenGL 有<code>swapBuffers()</code>，Direct3D 有&quot;swap chains&quot;, Microsoft 的 XNA 框架有<code>endDraw()</code>方法。</li>
</ul>
<h1><a class="header" href="#游戏循环" id="游戏循环">游戏循环</a></h1>
<h2><a class="header" href="#意图-1" id="意图-1">意图</a></h2>
<blockquote>
<p><em>将游戏的进行和玩家的输入解耦，和处理器速度解耦。</em></p>
</blockquote>
<h2><a class="header" href="#动机-1" id="动机-1">动机</a></h2>
<p>如果本书中有一个模式不可或缺，那非这个模式莫属了。
游戏循环是“游戏编程模式”的精髓。
几乎每个游戏都有，两两不同，而在非游戏的程序几乎没有使用。</p>
<p>为了看看它多有用，让我们快速缅怀一遍往事。
在每个编写计算机程序的人都留着胡子的时代，程序像洗碗机一样工作。
你输入一堆代码，按个按钮，等待，然后获得结果，完成。
程序全都是<strong>批处理模式</strong>的——一旦工作完成，程序就停止了。</p>
<blockquote>
<p>Ada Lovelace 和 Rear Admiral Grace Hopper 是女程序员，并没有胡子。</p>
</blockquote>
<p>你在今日仍然能看到这些程序，虽然感谢上天，我们不必在打孔纸上面编写它们了。
终端脚本，命令行程序，甚至将 Markdown 翻译成这本书的 Python 脚本都是批处理程序。</p>
<h3><a class="header" href="#采访-cpu" id="采访-cpu">采访 CPU</a></h3>
<p>最终，程序员意识到将批处理代码留在计算办公室，等几个小时后拿到结果才能开始找程序漏洞的方式实在低效。
他们想要立即的反馈。<em>交互式</em> 程序诞生了。
第一批交互式程序中就有游戏：</p>
<pre><code class="language-text">YOU ARE STANDING AT THE END OF A ROAD BEFORE A SMALL BRICK
BUILDING . AROUND YOU IS A FOREST. A SMALL
STREAM FLOWS OUT OF THE BUILDING AND DOWN A GULLY.

&gt; GO IN
YOU ARE INSIDE A BUILDING, A WELL HOUSE FOR A LARGE SPRING.
</code></pre>
<blockquote>
<p>这是<a href="http://en.wikipedia.org/wiki/Colossal_Cave_Adventure">Colossal Cave Adventure</a>，史上首个冒险游戏。</p>
</blockquote>
<p>你可以和这个程序进行实时交互。
它等待你的输入，然后进行响应。
你再输入，这样一唱一和，就像相声一样。
当轮到你时，它停在那里啥也不做。像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  char* command = readCommand();
  handleCommand(command);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这程序会永久循环，所以没法退出游戏。
真实的游戏会做些<code>while (!done)</code>进行检查，然后通过设置<code>done</code>为真来退出游戏。
我省去了那些内容，保持简明。</p>
</blockquote>
<h3><a class="header" href="#事件循环" id="事件循环">事件循环</a></h3>
<p>如果你剥开现代的图形 UI 的外皮，会惊讶地发现它们与老旧的冒险游戏差不多。
文本处理器通常呆在那里什么也不做，直到你按了个键或者点了什么东西：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  Event* event = waitForEvent();
  dispatchEvent(event);
}
<span class="boring">}
</span></code></pre></pre>
<p>这与冒险游戏主要的不同是，程序不是等待<strong>文本指令</strong>，而是等待<strong>用户输入事件</strong>——鼠标点击、按键按下之类的。
其他部分还是和以前的老式文本冒险游戏一样，程序<strong>阻塞</strong>等待用户的输入，这是个问题。</p>
<p>不像其他大多数软件，游戏即使在没有玩家输入时也继续运行。
如果你站在那里看着屏幕，游戏不会冻结。动画继续动着。视觉效果继续闪烁。
如果运气不好的话，怪物会继续吞噬英雄。</p>
<blockquote>
<p>事件循环有“空转”事件，这样你可以无需用户输入间歇地做些事情。
这对于闪烁的光标或者进度条已经足够了，但对于游戏就太原始了。</p>
</blockquote>
<p>这是真实游戏循环的第一个关键部分：<em>它处理用户输入，但是不等待它</em>。循环总是继续旋转：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  processInput();
  update();
  render();
}
<span class="boring">}
</span></code></pre></pre>
<p>我们之后会改善它，但是基本的部分都在这里了。
<code>processInput()</code>处理上次调用到现在的任何输入。
然后<code>update()</code>让游戏模拟一步。
运行 AI 和物理（通常是这种顺序）。
最终，<code>render()</code>绘制游戏，这样玩家可以看到发生了什么。</p>
<blockquote>
<p>就像你可以从名字中猜到的，<code>update()</code>是使用<a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a>模式的好地方。</p>
</blockquote>
<h3><a class="header" href="#时间之外的世界" id="时间之外的世界">时间之外的世界</a></h3>
<p>如果这个循环没有因为输入而阻塞，这就带来了明显的问题，要运转<strong>多快</strong>呢？
每次进行游戏循环都会推动一定的游戏状态的发展。
在游戏世界的居民看来，他们手上的表就会滴答一下。</p>
<blockquote>
<p>运行游戏循环一次的常用术语就是“滴答”(tick)和“帧”(frame)。</p>
</blockquote>
<p>同时，<strong>玩家的</strong>真实手表也在滴答着。
如果我们用实际时间来测算游戏循环运行的速度，就得到了游戏的“帧率”(FPS)。
如果游戏循环的更快，FPS 就更高，游戏运行得更流畅、更快。
如果循环得过慢，游戏看上去就像是慢动作电影。</p>
<p>我们现在写的这个循环是能转多快转多快，两个因素决定了帧率。
一个是<strong>每帧要做多少工作</strong>。复杂的物理，众多游戏对象，图形细节都让 CPU 和 GPU 繁忙，这决定了需要多久能完成一帧。</p>
<p>另一个是<strong>底层平台的速度。</strong> 更快的芯片可以在同样的时间里执行更多的代码。
多核，GPU 组，独立声卡，以及系统的调度都影响了在一次滴答中能够做多少东西。</p>
<h3><a class="header" href="#每秒的帧数" id="每秒的帧数">每秒的帧数</a></h3>
<p>在早期的视频游戏中，第二个因素是固定的。
如果你为 NES 或者 Apple IIe 写游戏，你<strong>明确</strong>知道游戏运行在什么 CPU 上。
你可以（也必须）为它特制代码。
你只需担忧第一个因素：每次滴答要做多少工作。</p>
<p>早期的游戏被仔细地编码，一帧只做一定的工作，开发者可以让游戏以想要的速率运行。
但是如果你想要在快些或者慢些的机器上运行同一游戏，游戏本身就会加速或减速。</p>
<blockquote>
<p>这就是为什么老式计算机通常有“<a href="http://en.wikipedia.org/wiki/Turbo_button">turbo</a>”按钮。
新的计算机运行得太快了，无法玩老游戏，因为游戏也会运行得过快。
<em>关闭</em> turbo 按钮，会减慢计算机的运行速度，就可以运行老游戏了。</p>
</blockquote>
<p>现在，很少有开发者可以奢侈地知道游戏运行的硬件条件。游戏必须自动适应多种设备。</p>
<p>这就是游戏循环的另一个关键任务：<em>不管潜在的硬件条件，以固定速度运行游戏。</em></p>
<h2><a class="header" href="#模式-3" id="模式-3">模式</a></h2>
<p>一个<strong>游戏循环</strong>在游玩中不断运行。
每一次循环，它无阻塞地<strong>处理玩家输入</strong>，<strong>更新游戏状态</strong>，<strong>渲染游戏</strong>。
它追踪时间的消耗并<strong>控制游戏的速度。</strong></p>
<h2><a class="header" href="#何时使用-1" id="何时使用-1">何时使用</a></h2>
<p>使用错误的模式比不使用模式更糟，所以这节通常告诫你不要过于热衷设计模式。
设计模式的目标不是往代码库里尽可能的塞东西。</p>
<p>但是这个模式有所不同。我可以很自信的说你<strong>会</strong>使用这个模式。
如果你使用游戏引擎，你不需要自己编写，但是它还在那里。</p>
<blockquote>
<p>对于我而言，这是“引擎”与“库”的不同之处。
使用库时，你拥有游戏循环，调用库代码。
使用引擎时，引擎拥有游戏循环，调用<strong>你的</strong>代码。</p>
</blockquote>
<p>你可能认为在做回合制游戏时不需要它。
但是哪怕是那里，就算<strong>游戏状态</strong>到玩家回合才改变，<strong>视觉</strong>和<strong>听觉</strong> 状态仍会改变。
哪怕游戏在“等待”你进行你的回合，动画和音乐也会继续运行。</p>
<h2><a class="header" href="#记住-1" id="记住-1">记住</a></h2>
<p>我们这里谈到的循环是游戏代码中最重要的部分。
有人说程序会花费 90%的时间在 10%的代码上。
游戏循环代码肯定在这 10%中。
你必须小心谨慎，时时注意效率。</p>
<blockquote>
<p>“真正的”工程师，比如机械或电子工程师，不把我们当回事，大概就是因为我们像这样使用统计学。</p>
</blockquote>
<h3><a class="header" href="#你也许需要与平台的事件循环相协调" id="你也许需要与平台的事件循环相协调">你也许需要与平台的事件循环相协调</a></h3>
<p>如果你在操作系统的顶层或者有图形 UI 和内建事件循环的平台上构建游戏，
那你就有了两个应用循环在同时运作。
它们需要很好地协调。</p>
<p>有时候，你可以进行控制，只运行你的游戏循环。
举个例子，如果舍弃了 Windows 的珍贵 API，<code>main()</code>可以只用游戏循环。
其中你可以调用<code>PeekMessage()</code>来处理和分发系统的事件。
不像<code>GetMessage()</code>，<code>PeekMessage()</code>不会阻塞等待用户输入，
因此你的游戏循环会保持运作。</p>
<p>其他的平台不会让你这么轻松地摆脱事件循环。
如果你使用网页浏览器作为平台，事件循环已被内建在浏览器的执行模型深处。
这样，你得用事件循环作为游戏循环。
你会调用<code>requestAnimationFrame()</code>之类的函数，它会回调你的代码，保持游戏继续运行。</p>
<h2><a class="header" href="#示例代码-1" id="示例代码-1">示例代码</a></h2>
<p>在如此长的介绍之后，游戏循环的代码实际上很直观。
我们会浏览一堆变种，比较它们的好处和坏处。</p>
<p>游戏循环驱动了 AI，渲染和其他游戏系统，但这些不是模式的要点，
所以我们会调用虚构的方法。在实现了<code>render()</code>，<code>update()</code>之后，
剩下的作为给读者的练习（挑战！）。</p>
<h3><a class="header" href="#跑能跑多快跑多快" id="跑能跑多快跑多快">跑，能跑多快跑多快</a></h3>
<p>我们已经见过了可能是最简单的游戏循环：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  processInput();
  update();
  render();
}
<span class="boring">}
</span></code></pre></pre>
<p>它的问题是你不能控制游戏运行得有多快。
在快速机器上，循环会运行得太快，玩家看不清发生了什么。
在慢速机器上，游戏慢的跟在爬一样。
如果游戏的一部分有大量内容或者做了很多 AI 或物理运算，游戏就会慢一些。</p>
<h3><a class="header" href="#休息一下" id="休息一下">休息一下</a></h3>
<p>我们看看增加一个简单的小修正如何。
假设你想要你的游戏以 60FPS 运行。这样每帧大约 16 毫秒。
只要你用少于这个的时长进行游戏所有的处理和渲染，就可以以稳定的帧率运行。
你需要做的就是处理这一帧然后<strong>等待</strong>，直到处理下一帧的时候，就像这样：</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-simple.png" alt="一个简单的游戏循环流程图。处理输入 → 更新游戏 → 渲染 → 等待，然后从头开始。" /></p>
<p>代码看上去像这样：</p>
<blockquote>
<p><em>1000 毫秒 / 帧率 = 毫秒每帧</em>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  double start = getCurrentTime();
  processInput();
  update();
  render();

  sleep(start + MS_PER_FRAME - getCurrentTime());
}
<span class="boring">}
</span></code></pre></pre>
<p>如果它很快地处理完一帧，这里的<code>sleep()</code>保证了游戏不会运行太<strong>快</strong>。
如果你的游戏运行太<strong>慢</strong>，这无济于事。
如果需要超过 16ms 来更新并渲染一帧，休眠的时间就变成了<strong>负的</strong>。
如果计算机能回退时间，很多事情就很容易了，但是它不能。</p>
<p>相反，游戏变慢了。
可以通过每帧少做些工作来解决这个问题——减少物理效果和绚丽光影，或者把 AI 变笨。
但是这影响了那些有快速机器的玩家的游玩体验。</p>
<h3><a class="header" href="#一小步一大步" id="一小步一大步">一小步，一大步</a></h3>
<p>让我们尝试一些更加复杂的东西。我们拥有的问题基本上是：</p>
<ol>
<li>每次更新将游戏时间推动一个固定量。</li>
<li>这消耗一定量的<strong>真实</strong>时间来处理它。</li>
</ol>
<p>如果第二步消耗的时间超过第一步，游戏就变慢了。
如果它需要超过 16ms 来推动游戏时间 16ms，那它永远也跟不上。
但是如果一步中推动游戏时间<strong>超过</strong>16ms，那我们可以减少更新频率，就可以跟得上了。</p>
<p>接着的思路是基于上帧到现在有多少<strong>真实</strong>时间流逝来选择前进的时间。
这一帧花费的时间越长，游戏的间隔越大。
它总能跟上真实时间，因为它走的步子越来越大。
有人称之为<strong>变化的</strong>或者<strong>流动的</strong>时间间隔。它看上去像是：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>double lastTime = getCurrentTime();
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - lastTime;
  processInput();
  update(elapsed);
  render();
  lastTime = current;
}
<span class="boring">}
</span></code></pre></pre>
<p>每一帧，我们计算上次游戏更新到现在有多少<strong>真实</strong>时间过去了（即变量<code>elapsed</code>）。
当我们更新游戏状态时将其传入。
然后游戏引擎让游戏世界推进一定的时间量。</p>
<p>假设有一颗子弹跨过屏幕。
使用固定的时间间隔，在每一帧中，你根据它的速度移动它。
使用变化的时间间隔，你<strong>根据过去的时间拉伸速度</strong>。
随着时间间隔增加，子弹在每帧间移动得更远。
无论是二十个快的小间隔还是四个慢的大间隔，子弹在<strong>真实</strong>时间里移动<strong>同样</strong>多的距离。
这看上去成功了：</p>
<ul>
<li>游戏在不同的硬件上以固定的速度运行。</li>
<li>使用高端机器的玩家获得了更流畅的游戏体验。</li>
</ul>
<p>但悲剧的是，这里有一个严重的问题：
游戏不再是确定的了，也不再稳定。
这是我们给自己挖的一个坑：</p>
<blockquote>
<p>“确定的”代表每次你运行程序，如果给了它同样的输入，就获得同样的输出。
可以想得到，在确定的程序中追踪漏洞更容易——一旦找到造成漏洞的输入，每次你都能重现之。</p>
<p>计算机本身是确定的；它们机械地执行程序。
在纷乱的真实世界搀合进来，非确定性就出现了。
例如，网络，系统时钟，线程调度都依赖于超出程序控制的外部世界。</p>
</blockquote>
<p>假设我们有个双人联网游戏，Fred 的游戏机是台性能猛兽，而 George 正在使用他祖母的老爷机。
前面提到的子弹在他们的屏幕上飞行。
在 Fred 的机器上，游戏跑得超级快，每个时间间隔都很小。
比如，我们塞了 50 帧在子弹穿过屏幕的那一秒。
可怜的 George 的机器只能塞进大约 5 帧。</p>
<p>这就意味着在 Fred 的机器上，物理引擎每秒更新 50 次位置，但是 George 的只更新 5 次。
大多数游戏使用浮点数，它们有<strong>舍入误差</strong>。
每次你将两个浮点数加在一起，获得的结果就会有点偏差。
Fred 的机器做了 10 倍的操作，所以他的误差要比 George 的更大。
<em>同样</em> 的子弹最终在他们的机器上到了<strong>不同的位置</strong>。</p>
<p>这是使用变化时间可引起的问题之一，还有更多问题呢。
为了实时运行，游戏物理引擎做的是实际机制法则的近似。
为了避免飞天遁地，物理引擎添加了阻尼。
这个阻尼运算被小心地安排成以固定的时间间隔运行。
改变了它，物理就不再稳定。</p>
<blockquote>
<p>“飞天遁地”在这里使用的是它的字面意思。当物理引擎卡住，对象获得了完全错误的速度，就会飞到天上或者掉入地底。</p>
</blockquote>
<p>这种不稳定性太糟了，这个例子在这里的唯一原因是作为警示寓言，引领我们到更好的东西……</p>
<h3><a class="header" href="#追逐时间" id="追逐时间">追逐时间</a></h3>
<p>游戏中渲染通常<strong>不会</strong>被动态时间间隔影响到。
由于渲染引擎表现的是时间上的一瞬间，它不会计算上次到现在过了多久。
它只是将当前事物渲染在所在的地方。</p>
<blockquote>
<p>这或多或少是成立的。像动态模糊的东西会被时间间隔影响，但如果有一点延迟，玩家通常也不会注意到。</p>
</blockquote>
<p>我们可以利用这点。
以固定的时间间隔<strong>更新</strong>游戏，因为这让所有事情变得简单，物理和 AI 也更加稳定。
但是我们允许灵活调整<strong>渲染</strong>的时刻，释放一些处理器时间。</p>
<p>它像这样运作：自上一次游戏循环过去了一定量的真实时间。
需要为游戏的“当前时间”模拟推进相同长度的时间，以追上玩家的时间。
我们使用一<strong>系列</strong>的<strong>固定</strong>时间步长。
代码大致如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>double previous = getCurrentTime();
double lag = 0.0;
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - previous;
  previous = current;
  lag += elapsed;

  processInput();

  while (lag &gt;= MS_PER_UPDATE)
  {
    update();
    lag -= MS_PER_UPDATE;
  }

  render();
}
<span class="boring">}
</span></code></pre></pre>
<p>这里有几个部分。
在每帧的开始，根据过去了多少真实的时间，更新<code>lag</code>。
这个变量表明了游戏世界时钟比真实世界落后了多少，然后我们使用一个固定时间步长的内部循环进行追赶。
一旦我们追上真实时间，我们就渲染然后开始新一轮循环。
你可以将其画成这样：</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-fixed.png" alt="修改后的流程图。处理输入 → 更新游戏 → 等待，然重回更新这步 → 渲染 → 回到开始。" /></p>
<p>注意这里的时间步长不是<strong>视觉上的</strong>帧率了。
<code>MS_PER_UPDATE</code>只是我们更新游戏的<strong>间隔</strong>。
这个间隔越短，就需要越多的处理次数来追上真实时间。
它越长，游戏抖动得越厉害。
理想上，你想要它足够短，通常快过 60FPS，这样游戏在高速机器上会有高效的表现。</p>
<p>但是小心不要把它整得<strong>太</strong>短了。
你需要保证即使在最慢的机器上，这个时间步长也超过处理一次<code>update()</code>的时间。
否则，你的游戏就跟不上现实时间了。</p>
<blockquote>
<p>我不会详谈这个，但你可以通过限定内层循环的最大次数来保证这一点。
游戏会变慢，但是比完全卡死要好。</p>
</blockquote>
<p>幸运的是，我们给自己了一些喘息的空间。
技巧在于我们将<strong>渲染拉出了更新循环</strong>。
这释放了一大块 CPU 时间。
最终结果是游戏以固定时间步长<strong>模拟</strong>，该时间步长与硬件不相关。
只是使用低端硬件的玩家<strong>看到的</strong>内容会有抖动。</p>
<h3><a class="header" href="#卡在中间" id="卡在中间">卡在中间</a></h3>
<p>我们还剩一个问题，就是剩下的延迟。
以固定的时间步长更新游戏，在任意时刻渲染。
这就意味着从玩家的角度看，游戏经常在两次更新之间时显示。</p>
<p>这是时间线：</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-timeline.png" alt="一条时间线，上面是均匀分布的更新时刻和不均匀的渲染时刻。" /></p>
<p>就像你看到的那样，我们以紧凑固定的时间步长进行更新。
同时，我们在任何可能的时候渲染。
它比更新发生得要少，而且也不稳定。
两者都没问题。糟糕的是，我们不总能在正确的时间点渲染。
看看第三次渲染时间。它发生在两次更新之间。</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-timeline-close.png" alt="时间线的一部分，渲染发生在两次更新之间。&quot;" /></p>
<p>想象一颗子弹飞过屏幕。第一次更新时，它在左边。
第二次更新将它移到了右边。
这个游戏在两次更新之间的时间点渲染，所以玩家期望看到子弹在屏幕的中间。
而现在的实现中，它还在左边。这意味着看上去移动发生了卡顿。</p>
<p>方便的是，我们<strong>实际</strong>知道渲染时距离两次更新的时间：它被存储在<code>lag</code>中。
我们在<code>lag</code>比更新时间间隔小时，而不是<code>lag</code>是<strong>零</strong>时，跳出循环进行渲染。
<code>lag</code>的剩余量？那就是到下一帧的时间。</p>
<p>当我们要渲染时，我们将它传入：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>render(lag / MS_PER_UPDATE);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>我们在这里除以<code>MS_PER_UPDATE</code>来<strong>归一化</strong>值。
不管更新的时间步长是多少，传给<code>render()</code>的值总在 0（恰巧在前一帧）到 1.0（恰巧在下一帧）之间。
这样，渲染引擎不必担心帧率。它只需处理 0 到 1 的值。</p>
</blockquote>
<p>渲染器知道每个游戏对象<strong>以及它当前的速度</strong>。
假设子弹在屏幕左边 20 像素的地方，正在以 400 像素每帧的速度向右移动。
如果在两帧正中渲染，我们会给<code>render()</code>传 0.5。
它绘制了半帧之前的图形，在 220 像素，啊哈，平滑的移动。</p>
<p>当然，也许这种推断是错误的。
在我们计算下一帧时，也许会发现子弹碰撞到另一障碍，或者减速，又或者别的什么。
我们只是在上一帧位置和我们<strong>认为的</strong>下一帧位置之间插值。
但只有在完成物理和 AI 更新后，我们才能知道真正的位置。</p>
<p>所以推断有猜测的成分，有时候结果是错误的。
但是，幸运地，这种修正通常不可感知。
最起码，比你不使用推断导致的卡顿更不明显。</p>
<h2><a class="header" href="#设计决策-1" id="设计决策-1">设计决策</a></h2>
<p>虽然这章我讲了很多，但是有更多的东西我没讲。
一旦你考虑显示刷新频率的同步，多线程，多 GPU，真正的游戏循环会变得更加复杂。
即使在高层，这里还有一些问题需要你回答：</p>
<h3><a class="header" href="#拥有游戏循环的是你还是平台" id="拥有游戏循环的是你还是平台">拥有游戏循环的是你，还是平台</a></h3>
<p>这个选择通常是已经由平台决定的。
如果你在做浏览器中的游戏，很可能你<strong>不能</strong>编写自己的经典游戏循环。
浏览器本身的事件驱动机制阻碍了这一点。
类似地，如果你使用现存的游戏引擎，你很可能依赖于它的游戏循环而不是自己写一个。</p>
<ul>
<li>
<p><strong>使用平台的事件循环：</strong></p>
<ul>
<li>
<p><em>简单</em>。你不必担心编写和优化自己的游戏核心循环。</p>
</li>
<li>
<p><em>平台友好。</em>
你不必明确地给平台一段时间让它处理它自己的事件，不必缓存事件，不必管理任何平台输入模型和你的不匹配之处。</p>
</li>
<li>
<p><em>你失去了对时间的控制。</em>
平台会在它方便时调用代码。
如果这不如你想要的那样平滑或者频繁，太糟了。
更糟的是，大多数应用的事件循环并未为游戏设计，通常<strong>是</strong>又慢又卡顿。</p>
</li>
</ul>
</li>
<li>
<p><strong>使用游戏引擎的循环：</strong></p>
<ul>
<li>
<p><em>不必自己编写。</em>
编写游戏循环非常需要技巧。
由于是每帧都要执行的核心代码，小小的漏洞或者性能问题就对游戏有巨大的影响。
稳固的游戏循环是使用现有引擎的原因之一。</p>
</li>
<li>
<p><em>不必自己编写。</em>
当然，硬币的另一面是，如果引擎无法满足你<strong>真正的</strong>需求，你也没法获得控制权。</p>
</li>
</ul>
</li>
<li>
<p><strong>自己写：</strong></p>
<ul>
<li>
<p><em>完全的控制。</em>
你可以做任何想做的事情。你可以为游戏的需求订制开发。</p>
</li>
<li>
<p><em>你需要与平台交互。</em>
应用框架和操作系统通常需要时间片去处理自己的事件和其他工作。
如果你拥有应用的核心循环，平台就没有这些时间片了。
你得显式定期检查，保证框架没有挂起或者混乱。</p>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#如何管理能量消耗" id="如何管理能量消耗">如何管理能量消耗</a></h3>
<p>在五年前这还不是问题。
游戏运行在插到插座上的机器上或者专用的手持设备上。
但是随着智能手机，笔记本以及移动游戏的发展，现在需要关注这个问题了。
画面绚丽，但会耗干三十分钟前充的电，并将手机变成空间加热器的游戏，可不能让人开心。</p>
<p>现在，你需要考虑的不仅仅是让游戏看上去很棒，同时也要尽可能少地使用 CPU。
你需要设置一个性能的<strong>上限</strong>：完成一帧之内所需的工作后，让 CPU 休眠。</p>
<ul>
<li>
<p><strong>尽可能快地运行：</strong></p>
<p>这是 PC 游戏的常态（即使越来越多的人在笔记本上运行游戏）。
游戏循环永远不会显式告诉系统休眠。相反，空闲的循环被划在提升 FPS 或者图像显示效果上了。</p>
<p>这会给你最好的游戏体验。
但是，也会尽可能多地使用电量。如果玩家在笔记本电脑上游玩，他们就得到了一个很好的加热器。</p>
</li>
<li>
<p><strong>固定帧率</strong></p>
<p>移动游戏更加注意游戏的体验质量，而不是最大化图像画质。
很多这种游戏都会设置最大帧率（通常是 30 或 60FPS）。
如果游戏循环在分配的时间片消耗完之前完成，剩余的时间它会休眠。</p>
<p>这给了玩家“足够好的”游戏体验，也让电池轻松了一点。</p>
</li>
</ul>
<h3><a class="header" href="#你如何控制游戏速度" id="你如何控制游戏速度">你如何控制游戏速度</a></h3>
<p>游戏循环有两个关键部分：不阻塞用户输入和自适应的帧时间步长。
输入部分很直观。关键在于你如何处理时间。
这里有数不尽的游戏可运行的平台，
每个游戏都需要在其中一些平台上运行。
如何适应平台的变化就是关键。</p>
<blockquote>
<p>创作游戏看来是人类的天性，因为每当我们建构可以计算的机器，首先做的就是在上面编游戏。
PDP-1 是一个仅有 4096 字内存的 2kHz 机器，但是 Steve Russell 和他的朋友还是在上面创建了 Spacewar!。</p>
</blockquote>
<ul>
<li>
<p><strong>固定时间步长，没有同步：</strong></p>
<p>见我们第一个样例中的代码。你只需尽可能快地运行游戏。</p>
<ul>
<li>
<p><em>简单</em>。这是主要的（好吧，唯一的）好处。</p>
</li>
<li>
<p><em>游戏速度直接受到硬件和游戏复杂度影响。</em>
主要的缺点是，如果有所变化，会直接影响游戏速度。游戏速度与游戏循环紧密相关。</p>
</li>
</ul>
</li>
<li>
<p><strong>固定时间步长，有同步：</strong></p>
<p>对复杂度控制的下一步是使用固定的时间间隔，但在循环的末尾增加同步点，保证游戏不会运行得过快。</p>
<ul>
<li>
<p><em>还是很简单。</em>
这比过于简单以至于不可行的例子只多了一行代码。
在多数游戏循环中，你可能<strong>总</strong>需要做一些同步。
你可能需要<a href="04-1%E5%8F%8C%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F.html">双缓冲</a>图形并将缓冲块与更新显示的频率同步。</p>
</li>
<li>
<p><em>电量友好。</em>
这对移动游戏至关重要。你不想消耗不必要的电量。
通过简单地休眠几个毫秒而不是试图每帧塞入更多的处理，你就节约了电量。</p>
</li>
<li>
<p><em>游戏不会运行得太快。</em>
这解决了固定循环速度的一半问题。</p>
</li>
<li>
<p><em>游戏可能运行的太慢。</em>
如果花了太多时间更新和渲染一帧，播放也会减缓。
因为这种方案没有分离更新和渲染，它比更高级的方案更容易遇到这点。
没法扔掉<strong>渲染</strong>帧来追上真实时间，游戏本身会变慢。</p>
</li>
</ul>
</li>
<li>
<p><strong>动态时间步长：</strong></p>
<p>我把这个方案放在这里作为问题的解决办法之一，附加警告：大多数我认识的游戏开发者反对它。
不过记住<strong>为什么</strong>反对它是很有价值的。</p>
<ul>
<li>
<p><em>能适应并调整，避免运行得太快或者太慢。</em>
如果游戏不能追上真实时间，它用越来越长的时间步长更新，直到追上。</p>
</li>
<li>
<p><em>让游戏不确定而且不稳定。</em>
这是真正的问题，当然。在物理和网络部分使用动态时间步长会遇见更多的困难。</p>
</li>
</ul>
</li>
<li>
<p><strong>固定更新时间步长，动态渲染：</strong></p>
<p>在示例代码中提到的最后一个选项是最复杂的，但是也是最有适应性的。
它以固定时间步长更新，但是如果需要赶上玩家的时间，可以扔掉一些<strong>渲染</strong>帧。</p>
<ul>
<li>
<p><em>能适应并调整，避免运行得太快或者太慢。</em>
只要能实时<strong>更新</strong>，游戏状态就不会落后于真实时间。如果玩家用高端的机器，它会回以更平滑的游戏体验。</p>
</li>
<li>
<p><em>更复杂。</em>
主要负面问题是需要在实现中写更多东西。
你需要将更新的时间步长调整得尽可能小来适应高端机，同时不至于在低端机上太慢。</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#参见-3" id="参见-3">参见</a></h2>
<ul>
<li>
<p>关于游戏循环的经典文章是 Glenn Fiedler 的&quot;<a href="http://gafferongames.com/game-physics/fix-your-timestep/">Fix Your Timestep</a>&quot;。如果没有这篇文章，这章就不会是这个样子。</p>
</li>
<li>
<p>Witters 关于<a href="http://www.koonsolo.com/news/dewitters-gameloop/">game loops</a>的文章也值得阅读。</p>
</li>
<li>
<p><a href="http://unity3d.com/">Unity</a>框架有一个复杂的游戏循环，细节在<a href="http://docs.unity3d.com/Manual/ExecutionOrder.html">这里</a>有详尽的解释。</p>
</li>
</ul>
<h1><a class="header" href="#更新方法" id="更新方法">更新方法</a></h1>
<h2><a class="header" href="#意图-2" id="意图-2">意图</a></h2>
<blockquote>
<p><em>通过每次处理一帧的行为模拟一系列独立对象。</em></p>
</blockquote>
<h2><a class="header" href="#动机-2" id="动机-2">动机</a></h2>
<p>玩家操作强大的女武神完成考验：从死亡巫王的栖骨之处偷走华丽的珠宝。
她尝试接近巫王华丽的地宫门口，然后遇到了……<em>啥也没遇到</em>。
没有诅咒雕像向她发射闪电，没有不死战士巡逻入口。
她直捣黄龙，拿走了珠宝。游戏结束。你赢了。</p>
<p>好吧，这可不行。</p>
<p>地宫需要守卫——一些英雄可以杀死的敌人。
首先，我们需要一个骷髅战士在门口前后移动巡逻。
如果无视任何关于游戏编程的知识，
让骷髅蹒跚着来回移动的最简单的代码大概是这样的：</p>
<blockquote>
<p>如果巫王想表现得更加智慧，它应创造一些仍有脑子的东西。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  // 向右巡逻
  for (double x = 0; x &lt; 100; x++)
  {
    skeleton.setX(x);
  }

  // 向左巡逻
  for (double x = 100; x &gt; 0; x--)
  {
    skeleton.setX(x);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里的问题，当然，是骷髅来回打转，可玩家永远看不到。
程序锁死在一个无限循环，那可不是有趣的游戏体验。
我们事实上想要的是骷髅<strong>每帧</strong>移动一步。</p>
<p>我们得移除这些循环，依赖外层游戏循环来迭代。
这保证了在卫士来回巡逻时，游戏能响应玩家的输入并进行渲染。如下：</p>
<blockquote>
<p>当然，<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>是本书的另一个章节。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Entity skeleton;
bool patrollingLeft = false;
double x = 0;

// 游戏主循环
while (true)
{
  if (patrollingLeft)
  {
    x--;
    if (x == 0) patrollingLeft = false;
  }
  else
  {
    x++;
    if (x == 100) patrollingLeft = true;
  }

  skeleton.setX(x);

  // 处理用户输入并渲染游戏……
}
<span class="boring">}
</span></code></pre></pre>
<p>在这里前后两个版本展示了代码是如何变得复杂的。
左右巡逻需要两个简单的<code>for</code>循环。
通过指定哪个循环在执行，我们追踪了骷髅在移向哪个方向。
现在我们每帧跳出到外层的游戏循环，然后再跳回继续我们之前所做的，我们使用<code>patrollingLeft</code>显式地追踪了方向。</p>
<p>但或多或少这能行，所以我们继续。
一堆无脑的骨头不会对你的女武神提出太多挑战，
我们下一个添加的是魔法雕像。它们一直会向她发射闪电球，这样可让她保持移动。</p>
<p>继续我们的“用最简单的方式编码”的风格，我们得到了：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 骷髅的变量……
Entity leftStatue;
Entity rightStatue;
int leftStatueFrames = 0;
int rightStatueFrames = 0;

// 游戏主循环：
while (true)
{
  // 骷髅的代码……

  if (++leftStatueFrames == 90)
  {
    leftStatueFrames = 0;
    leftStatue.shootLightning();
  }

  if (++rightStatueFrames == 80)
  {
    rightStatueFrames = 0;
    rightStatue.shootLightning();
  }

  // 处理用户输入，渲染游戏
}
<span class="boring">}
</span></code></pre></pre>
<p>你会发现这代码渐渐滑向失控。
变量数目不断增长，代码都在游戏循环中，每段代码处理一个特殊的游戏实体。
为了同时访问并运行它们，我们将它们的代码混杂在了一起。</p>
<blockquote>
<p>一旦能用“混杂”一词描述你的架构，你就有麻烦了。</p>
</blockquote>
<p>你也许已经猜到了修复这个所用的简单模式了：
<em>每个游戏实体应该封装它自己的行为。</em>
这保持了游戏循环的整洁，便于添加和移除实体。</p>
<p>为了做到这点需要<strong>抽象层</strong>，我们通过定义抽象的<code>update()</code>方法来完成。
游戏循环管理对象的集合，但是不知道对象的具体类型。
它只知道这些对象可以被更新。
这样，每个对象的行为与游戏循环分离，与其他对象分离。</p>
<p>每一帧，游戏循环遍历集合，在每个对象上调用<code>update()</code>。
这给了我们在每帧上更新一次行为的机会。
在所有对象上每帧调用它，对象就能同时行动。</p>
<blockquote>
<p>死抠细节的人会在这点上揪着我不放，是的，它们没有<strong>真的同步</strong>。
当一个对象更新时，其他的都不在更新中。
我们等会儿再说这点。</p>
</blockquote>
<p>游戏循环维护动态的对象集合，所以从关卡添加和移除对象是很容易的——只需要将它们从集合中添加和移除。
不必再用硬编码，我们甚至可以用数据文件构成这个关卡，那正是我们的关卡设计者需要的。</p>
<h2><a class="header" href="#模式-4" id="模式-4">模式</a></h2>
<p><strong>游戏世界</strong>管理<strong>对象集合</strong>。
每个对象实现一个<strong>更新方法</strong>模拟对象在<strong>一帧</strong>内的行为。每一帧，游戏循环更新集合中的每一个对象。</p>
<h2><a class="header" href="#何时使用-2" id="何时使用-2">何时使用</a></h2>
<p>如果<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>模式是切片面包，
那么更新方法模式就是它的奶油。
很多玩家交互的游戏实体都以这样或那样的方式实现了这个模式。
如果游戏有太空陆战队，火龙，火星人，鬼魂或者运动员，很有可能它使用了这个模式。</p>
<p>但是如果游戏更加抽象，移动部分不太像活动的角色而更加像棋盘上的棋子，
这个模式通常就不适用了。
在棋类游戏中，你不需要同时模拟所有的部分，
你可能也不需要告诉棋子每帧都更新它们自己。</p>
<blockquote>
<p>你也许不需要每帧更新它们的<strong>行为</strong>，但即使是棋类游戏，
你可能也需要每帧更新<strong>动画</strong>。
这个设计模式也可以帮到你。</p>
</blockquote>
<p>更新方法适应以下情况：</p>
<ul>
<li>
<p>你的游戏有很多对象或系统需要同时运行。</p>
</li>
<li>
<p>每个对象的行为都与其他的大部分独立。</p>
</li>
<li>
<p>对象需要跟着时间进行模拟。</p>
</li>
</ul>
<h2><a class="header" href="#记住-2" id="记住-2">记住</a></h2>
<p>这个模式很简单，所以没有太多值得发现的惊喜。当然，每行代码还是有利有弊。</p>
<h2><a class="header" href="#将代码划分到一帧帧中会让它更复杂" id="将代码划分到一帧帧中会让它更复杂">将代码划分到一帧帧中会让它更复杂</a></h2>
<p>当你比较前面两块代码时，第二块看上去更加复杂。
两者都只是让骷髅守卫来回移动，但与此同时，第二块代码将控制权交给了游戏循环的一帧帧中。</p>
<p>这个改变是游戏循环处理用户输入，渲染等几乎必须要注意的事项，所以第一个例子不大实用。
但是很有必要记住，将你的行为切片会增加很高的复杂性。</p>
<blockquote>
<p>我在这里说几乎是因为有时候鱼和熊掌可以兼得。
你可以直接为对象编码而不进行返回，
保持很多对象同时运行并与游戏循环保持协调。</p>
<p>你需要的是允许你同时拥有多个“线程”执行的系统。
如果对象的代码可以在执行中暂停和继续，而不是总得<strong>返回</strong>，
你可以用更加命令式的方式编码。</p>
<p>真实的线程太过重量级而不能这么做，
但如果你的语言支持轻量协同架构比如 generators，coroutines 或者 fibers，那你也许可以使用它们。</p>
</blockquote>
<p><a href="05-1%E5%AD%97%E8%8A%82%E7%A0%81.html">字节码</a>是另一个在应用层创建多个线程执行的方法。</p>
<h3><a class="header" href="#当离开每帧时你需要存储状态以备将来继续" id="当离开每帧时你需要存储状态以备将来继续">当离开每帧时，你需要存储状态，以备将来继续</a></h3>
<p>在第一个示例代码中，我们不需要用任何变量表明守卫在向左还是向右移动。
这显式的依赖于哪块代码正在运行。</p>
<p>当我们将其变为一次一帧的形式，我们需要创建<code>patrollingLeft</code>变量来追踪行走的方向。
当从代码中返回时，就丢失了行走的方向，所以为了下帧继续，我们需要显式存储足够的信息。</p>
<p><a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a>通常可以在这里帮忙。
状态机在游戏中频繁出现的部分原因是（就像名字暗示的），它能在你离开时为你存储各种你需要的状态。</p>
<h3><a class="header" href="#对象逐帧模拟但并非真的同步" id="对象逐帧模拟但并非真的同步">对象逐帧模拟，但并非真的同步</a></h3>
<p>在这个模式中，游戏遍历对象集合，更新每一个对象。
在<code>update()</code>调用中，大多数对象都能够接触到游戏世界的其他部分，
包括现在正在更新的其他对象。这就意味着你更新对象的<strong>顺序</strong>至关重要。</p>
<p>如果对象更新列表中，A 在 B 之前，当 A 更新时，它会看到 B 之前的状态。
但是当 B 更新时，由于 A 已经在这帧更新了，它会看见 A 的<strong>新</strong>状态。
哪怕按照玩家的视角，所有对象都是同时运转的，游戏的核心还是回合制的。
只是完整的“回合”只有一帧那么长。</p>
<blockquote>
<p>如果，由于某些原因，你决定<strong>不</strong>让游戏按这样的顺序更新，你需要<a href="04-1%E5%8F%8C%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F.html">双缓冲模式</a>。
那么 AB 更新的顺序就没有关系了，因为<strong>双方</strong>都会看对方之前那帧的状态。</p>
</blockquote>
<p>当关注游戏逻辑时，这通常是件好事。
同时更新所有对象将把你带到一些不愉快的语义角落。
想象如果国际象棋中，黑白双方同时移动会发生什么。
双方都试图同时往同一个空格子中放置棋子。这怎么解决？</p>
<p>序列更新解决了这点——每次更新都让游戏世界从一个合法状态增量更新到下一个，不会出现引发歧义而需要协调的部分。</p>
<blockquote>
<p>这对在线游戏也有用，因为你有了可以在网上发送的行动指令序列。</p>
</blockquote>
<h3><a class="header" href="#在更新时修改对象列表需小心" id="在更新时修改对象列表需小心">在更新时修改对象列表需小心</a></h3>
<p>当你使用这个模式时，很多游戏行为在更新方法中纠缠在一起。
这些行为通常包括增加和删除可更新对象。</p>
<p>举个例子，假设骷髅守卫被杀死时掉落物品。
使用新对象，你通常可以将其增加到列表尾部，而不引起任何问题。
你会继续遍历这张链表，最终找到新的那个，然后也更新了它。</p>
<p>但这确实表明新对象在它产生的那帧就有机会活动，甚至有可能在玩家看到它之前。
如果你不想发生那种情况，简单的修复方法就是在游戏循环中缓存列表对象的数目，然后只更新那么多数目的对象就停止：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>int numObjectsThisTurn = numObjects_;
for (int i = 0; i &lt; numObjectsThisTurn; i++)
{
  objects_[i]-&gt;update();
}
<span class="boring">}
</span></code></pre></pre>
<p>这里，<code>objects_</code>是可更新游戏对象的数组，而<code>numObjects_</code>是数组的长度。
当添加新对象时，这个数组长度变量就增加。
在循环的一开始，我们在<code>numObjectsThisTurn</code>中存储数组的长度，
这样这帧的遍历循环会停在新添加的对象之前。</p>
<p>一个更麻烦的问题是在遍历时<strong>移除</strong>对象。
你击败了邪恶的野兽，现在它需要被移出对象列表。
如果它正好位于你当前更新对象之前，你会意外地跳过一个对象：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for (int i = 0; i &lt; numObjects_; i++)
{
  objects_[i]-&gt;update();
}
<span class="boring">}
</span></code></pre></pre>
<p>这个简单的循环通过增加索引值来遍历每个对象。
下图的左侧展示了在我们更新英雄时，数组看上去是什么样的：</p>
<p><img src="https://gpp.tkchu.me/images/update-method-remove.png" alt="在一次移除中的对象实体列表。一个指针指向第二个实体，英雄。排在第一个的怪兽被移除后，英雄向上移动一格，与此同时，指针向下移动一格。" /></p>
<p>我们在更新她时，索引值<code>i</code>是 1。
邪恶野兽被她杀了，因此需要从数组移除。
英雄移到了位置 0，倒霉的乡下人移到了位置 1。
在更新英雄之后，<code>i</code>增加到了 2。
就像你在右图看到的，倒霉的乡下人被跳过了，没有更新。</p>
<blockquote>
<p>一种简单的解决方案是在更新时<strong>从后往前</strong>遍历列表。
这种方式只会移动已经被更新的对象。</p>
</blockquote>
<p>一种解决方案是小心地移除对象，任何对象被移除时，更新索引。
另一种是在遍历完列表后再移除对象。
将对象标为“死亡”，但是把它放在那里。
在更新时跳过任何死亡的对象。然后，在完成遍历后，遍历列表并删除尸体。</p>
<blockquote>
<p>如果在更新循环中有多个线程处理对象，
那么你可能更喜欢推迟任何修改，避免更新时同步线程的开销。</p>
</blockquote>
<h2><a class="header" href="#示例代码-2" id="示例代码-2">示例代码</a></h2>
<p>这个模式太直观了，代码几乎只是在重复说明要点。
这不意味着这个模式没<strong>有用</strong>。它<strong>因为</strong>简单而有用：这是一个无需装饰的干净解决方案。</p>
<p>但是为了让事情更具体些，让我们看看一个基础的实现。
我们会从代表骷髅和雕像的<code>Entity</code>类开始：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Entity
{
public:
  Entity()
  : x_(0), y_(0)
  {}

  virtual ~Entity() {}
  virtual void update() = 0;

  double x() const { return x_; }
  double y() const { return y_; }

  void setX(double x) { x_ = x; }
  void setY(double y) { y_ = y; }

private:
  double x_;
  double y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>我在这里只呈现了我们后面所需东西的最小集合。
可以推断在真实代码中，会有很多图形和物理这样的其他东西。
上面这部分代码最重要的部分是它有抽象的<code>update()</code>方法。</p>
<p>游戏管理实体的集合。在我们的示例中，我会把它放在一个代表游戏世界的类中。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class World
{
public:
  World()
  : numEntities_(0)
  {}

  void gameLoop();

private:
  Entity* entities_[MAX_ENTITIES];
  int numEntities_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>在真实的世界程序中，你可能真的要使用集合类，我在这里使用数组来保持简单。</p>
</blockquote>
<p>现在，万事俱备，游戏通过每帧更新每个实体来实现模式：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void World::gameLoop()
{
  while (true)
  {
    // 处理用户输入……

    // 更新每个实体
    for (int i = 0; i &lt; numEntities_; i++)
    {
      entities_[i]-&gt;update();
    }

    // 物理和渲染……
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>正如其名，这是<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>模式的一个例子。</p>
</blockquote>
<h3><a class="header" href="#子类化实体" id="子类化实体">子类化实体</a></h3>
<p>有很多读者刚刚起了鸡皮疙瘩，因为我在<code>Entity</code>主类中使用继承来定义不同的行为。
如果你在这里还没有看出问题，我会提供一些线索。</p>
<p>当游戏业界从 6502 汇编代码和 VBLANKs 转向面向对象的语言时，
开发者陷入了对软件架构的狂热之中。
其中之一就是使用继承。他们建立了遮天蔽日的高耸的拜占庭式对象层次。</p>
<p>最终证明这是个糟点子，没人可以不拆解它们来管理庞杂的对象层次。
哪怕在 1994 年的 GoF 都知道这点，并写道：</p>
<blockquote>
<p>多用“对象组合”，而非“类继承”。</p>
<p>只在你我间聊聊，我认为这已经是一朝被蛇咬十年怕井绳了。
我通常避免使用它，但教条地不用和教条地使用一样糟。
你可以适度使用，不必完全禁用。</p>
</blockquote>
<p>当游戏业界都明白了这一点，解决方案是使用<a href="06-1%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html">组件（component）模式</a>。
使用它，<code>update()</code>是实体的<strong>组件</strong>而不是在<code>Entity</code>中。
这让你避开了为了定义和重用行为而创建实体所需的复杂类继承层次。相反，你只需混合和组装组件。</p>
<p>如果我真正在做游戏，我也许也会那么做。
但是这章不是关于组件的，
而是关于<code>update()</code>方法，最简单，最少牵连其他部分的介绍方法，
就是把更新方法放在<code>Entity</code>中然后创建一些子类。</p>
<blockquote>
<p>组件模式在<a href="06-1%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html">这里</a>。</p>
</blockquote>
<h3><a class="header" href="#定义实体" id="定义实体">定义实体</a></h3>
<p>好了，回到任务中。
我们原先的动机是定义巡逻的骷髅守卫和释放闪电的魔法雕像。
让我们从我们的骷髅朋友开始吧。
为了定义它的巡逻行为，我们定义恰当地实现了<code>update()</code>的新实体：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Skeleton : public Entity
{
public:
  Skeleton()
  : patrollingLeft_(false)
  {}

  virtual void update()
  {
    if (patrollingLeft_)
    {
      setX(x() - 1);
      if (x() == 0) patrollingLeft_ = false;
    }
    else
    {
      setX(x() + 1);
      if (x() == 100) patrollingLeft_ = true;
    }
  }

private:
  bool patrollingLeft_;
};
<span class="boring">}
</span></code></pre></pre>
<p>如你所见，几乎就是从早先的游戏循环中剪切代码，然后粘贴到<code>Skeleton</code>的<code>update()</code>方法中。
唯一的小小不同是<code>patrollingLeft_</code>被定义为字段而不是本地变量。
通过这种方式，它的值在<code>update()</code>两次调用间保持不变。</p>
<p>让我们对雕像如法炮制：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Statue : public Entity
{
public:
  Statue(int delay)
  : frames_(0),
    delay_(delay)
  {}

  virtual void update()
  {
    if (++frames_ == delay_)
    {
      shootLightning();

      // 重置计时器
      frames_ = 0;
    }
  }

private:
  int frames_;
  int delay_;

  void shootLightning()
  {
    // 火光效果……
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>又一次，大部分改动是将代码从游戏循环中移动到类中，然后重命名一些东西。
但是，在这个例子中，我们真的让代码库变简单了。
先前讨厌的命令式代码中，存在存储每个雕像的帧计数器和开火的速率的分散的本地变量。</p>
<p>现在那些都被移动到了<code>Statue</code>类中，你可以想创建多少就创建多少实例了，
每个实例都有它自己的小计时器。
这是这章背后的真实动机——现在为游戏世界增加新实体会更加简单，
因为每个实体都带来了它需要的全部东西。</p>
<p>这个模式让我们分离了游戏世界的<strong>构建</strong>和<strong>实现</strong>。
这同样能让我们灵活地使用分散的数据文件或关卡编辑器来构建游戏世界。</p>
<p><img src="https://gpp.tkchu.me/images/update-method-uml.png" alt="一个UML图。世界有一系列实体组成，每实体都有update()方法。可镂卫士和魔法雕像都继承实体。" /></p>
<blockquote>
<p>还有人关心 UML 吗？如果还有，那就是我们刚刚建的。</p>
</blockquote>
<h3><a class="header" href="#传递时间" id="传递时间">传递时间</a></h3>
<p>这是模式的关键，但是我只对常用的部分进行了细化。
到目前为止，我们假设每次对<code>update()</code>的调用都推动游戏世界前进一个固定的时间。</p>
<p>我更喜欢那样，但是很多游戏使用<strong>可变时间步长</strong>。
在那种情况下，每次游戏循环推进的时间长度或长或短，
具体取决于它需要多长时间处理和渲染前一帧。</p>
<p><a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>一章讨论了更多关于固定和可变时间步长的优劣。</p>
<p>这意味着每次<code>update()</code>调用都需要知道虚拟的时钟转动了多少，
所以你经常可以看到传入消逝的时间。
举个例子，我们可以让骷髅卫士像这样处理变化的时间步长：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Skeleton::update(double elapsed)
{
  if (patrollingLeft_)
  {
    x -= elapsed;
    if (x &lt;= 0)
    {
      patrollingLeft_ = false;
      x = -x;
    }
  }
  else
  {
    x += elapsed;
    if (x &gt;= 100)
    {
      patrollingLeft_ = true;
      x = 100 - (x - 100);
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，骷髅卫士移动的距离随着消逝时间的增长而增长。
也可以看出，处理变化时间步长需要的额外复杂度。
如果一次需要更新的时间步长过长，骷髅卫士也许就超过了其巡逻的范围，因此需要小心的处理。</p>
<h2><a class="header" href="#设计决策-2" id="设计决策-2">设计决策</a></h2>
<p>在这样简单的模式中，没有太多的调控之处，但是这里仍有两个你需要决策的地方：</p>
<h3><a class="header" href="#更新方法在哪个类中" id="更新方法在哪个类中">更新方法在哪个类中</a></h3>
<p>最明显和最重要的决策就是决定将<code>update()</code>放在哪个类中。</p>
<ul>
<li>
<p><strong>实体类中：</strong></p>
<p>如果你已经有实体类了，这是最简单的选项，
因为这不会带来额外的类。如果你需要的实体种类不多，这也许可行，但是业界已经逐渐远离这种做法了。</p>
<p>当类的种类很多时，一有新行为就建<code>Entity</code>子类来实现是痛苦的。
当你最终发现你想要用单一继承的方法重用代码时，你就卡住了。</p>
</li>
<li>
<p><strong>组件类：</strong></p>
<p>如果你已经使用了<a href="06-1%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html">组件模式</a>，你知道这个该怎么做。
这让每个组件独立更新它自己。
更新方法用了同样的方法解耦游戏中的实体，组件让你进一步解耦了<strong>单一实体中的各部分</strong>。
渲染，物理，AI 都可以自顾自了。</p>
</li>
<li>
<p><strong>委托类：</strong></p>
<p>还可将类的部分行为委托给其他的对象。
<a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a>可以这样做，你可以通过改变它委托的对象来改变它的行为。
<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>也这样做了，这样你可以在同“种”实体间分享行为。</p>
<p>如果你使用了这些模式，将<code>update()</code>放在委托类中是很自然的。
在那种情况下，也许主类中仍有<code>update()</code>方法，但是它不是虚方法，可以简单地委托给委托对象。就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Entity::update()
{
// 转发给状态对象
state_-&gt;update();
}
<span class="boring">}
</span></code></pre></pre>
<p>这样做允许你改变委托对象来定义新行为。就像使用组件，这给了你无须定义全新的子类就能改变行为的灵活性。</p>
</li>
</ul>
<h3><a class="header" href="#如何处理隐藏对象" id="如何处理隐藏对象">如何处理隐藏对象</a></h3>
<p>游戏中的对象，不管什么原因，可能暂时无需更新。
它们可能是停用了，或者超出了屏幕，或者还没有解锁。
如果状态中的这种对象很多，每帧遍历它们却什么都不做是在浪费 CPU 循环。</p>
<p>一种方法是管理单独的“活动”对象集合，它存储真正需要更新的对象。
当一个对象停用时，从那个集合中移除它。当它启用时，再把它添加回来。
用这种方式，你只需要迭代那些真正需要更新的东西：</p>
<ul>
<li>
<p><strong>如果你使用单个包括了所有不活跃对象的集合：</strong></p>
<ul>
<li><em>浪费时间</em>。对于不活跃对象，你要么检查一些“是否启用”的标识，要么调用一些啥都不做的方法。</li>
</ul>
<blockquote>
<p>检查对象启用与否然后跳过它，不但消耗了 CPU 循环，还报销了你的数据缓存。
CPU 通过从 RAM 上读取数据到缓存上来优化读取。
这样做是基于刚刚读取内存之后的内存部分很可能等会儿也会被读取到这个假设。</p>
<p>当你跳过对象，你可能越过了缓存的尾部，强迫它从缓慢的主存中再取一块。</p>
</blockquote>
</li>
<li>
<p><strong>如果你使用单独的集合保存活动对象：</strong></p>
<ul>
<li>
<p><em>使用了额外的内存管理第二个集合。</em>
当你需要所有实体时，通常又需要一个巨大的集合。在那种情况下，这集合是多余的。
在速度比内存要求更高的时候（通常如此），这取舍仍是值得的。
另一个权衡后的选择是使用两个集合，除了活动对象集合的另一个集合只包含<strong>不活跃</strong>实体而不是全部实体。</p>
</li>
<li>
<p><em>得保持集合同步。</em>
当对象创建或完全销毁时（不是暂时停用），你得修改全部对象集合和活跃对象集合。</p>
</li>
</ul>
</li>
</ul>
<p>方法选择的度量标准是不活跃对象的可能数量。
数量越多，用分离的集合避免在核心游戏循环中用到它们就更有用。</p>
<h2><a class="header" href="#参见-4" id="参见-4">参见</a></h2>
<ul>
<li>
<p>这个模式，以及<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>模式和<a href="06-1%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html">组件模式</a>，是构建游戏引擎核心的三位一体。</p>
</li>
<li>
<p>当你关注在每帧中更新实体或组件的缓存性能时，<a href="07-1%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7.html">数据局部性</a>模式可以让它跑到更快。</p>
</li>
<li>
<p><a href="http://unity3d.com">Unity</a>框架在多个类中使用了这个模式，包括
<a href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.Update.html"><code>MonoBehaviour</code></a>。</p>
</li>
<li>
<p>微软的<a href="http://creators.xna.com/en-US/">XNA</a>平台在
<a href="http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.game.update.aspx"><code>Game</code></a>
和
<a href="http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.gamecomponent.update.aspx"><code>GameComponent</code></a>
类中使用了这个模式。</p>
</li>
<li>
<p><a href="http://html5quintus.com/">Quintus</a>，一个 JavaScript 游戏引擎在它的主<a href="http://html5quintus.com/guide/sprites.md"><code>Sprite</code></a>类中使用了这个模式。</p>
</li>
</ul>
<h1><a class="header" href="#行为模式" id="行为模式">行为模式</a></h1>
<p>一旦做好游戏设定，在里面装满了角色和道具，剩下的就是启动场景。
为了完成这点，你需要行为——告诉游戏中每个实体做什么的剧本。</p>
<p>当然，所有代码都是“行为”，并且所有软件都是定义行为的，
但在游戏中有所不同的是，行为通常很<strong>多</strong>。
文字处理器也许有很长的特性清单，
但特性的数量与角色扮演游戏中的居民，物品和任务数量相比，那就相形见绌了。</p>
<p>本章的模式有助于快速定义和完善大量的行为。
<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>定义行为的类别而无需完成真正的类。
<a href="05-2%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1.html">子类沙箱</a>定义各种行为的安全原语。
最先进的是<a href="05-1%E5%AD%97%E8%8A%82%E7%A0%81.html">字节码</a>，将行为从代码中分离，放入数据文件中。</p>
<h2><a class="header" href="#模式-5" id="模式-5">模式</a></h2>
<ul>
<li><a href="05-1%E5%AD%97%E8%8A%82%E7%A0%81.html">字节码</a></li>
<li><a href="05-2%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1.html">子类沙箱</a></li>
<li><a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a></li>
</ul>
<h1><a class="header" href="#字节码" id="字节码">字节码</a></h1>
<h2><a class="header" href="#意图-3" id="意图-3">意图</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p><strong>将行为编码为虚拟机器上的指令，赋予其数据的灵活性。</strong></p>
</blockquote>
</blockquote>
</blockquote>
<h2><a class="header" href="#动机-3" id="动机-3">动机</a></h2>
<p>制作游戏也许很有趣，但绝不容易。
现代游戏的代码库很是庞杂。
主机厂商和应用市场有严格的质量要求，
小小的崩溃漏洞就能阻止游戏发售。</p>
<blockquote>
<p>我曾参与制作有六百万行 C++代码的游戏。作为对比，控制好奇号火星探测器的软件还没有其一半大小。</p>
</blockquote>
<p>与此同时，我们希望榨干平台的每一点性能。
游戏对硬件发展的推动首屈一指，只有坚持不懈地优化才能跟上竞争。</p>
<p>为了保证稳定和性能的需求，我们使用如 C++这样的重量级的编程语言，它既有能兼容多数硬件的底层表达能力，又拥有防止漏洞的强类型系统。</p>
<p>我们对自己的专业技能充满自信，但其亦有代价。
专业程序员需要多年的训练，之后又要对抗代码规模的增长。
构建大型游戏的时间长度可以在“喝杯咖啡”和
“烤咖啡豆，手磨咖啡豆，弄杯 espresso，打奶泡，在拿铁咖啡里拉花。”之间变动。</p>
<p>除开这些挑战，游戏还多了个苛刻的限制：“乐趣”。
玩家需要仔细权衡过的新奇体验。
这需要不断的迭代，但是如果每个调整都需要让工程师修改底层代码，然后等待漫长的编译结束，那就毁掉了创作流程。</p>
<h3><a class="header" href="#法术战斗" id="法术战斗">法术战斗</a></h3>
<p>假设我们在完成一个基于法术的格斗游戏。
两个敌对的巫师互相丢法术，直到分出胜负。
我们可以将这些法术都定义在代码中，但这就意味着每次修改法术都会牵扯到工程师。
当设计者想修改几个数字感觉一下效果，就要重新编译整个工程，重启，然后进入战斗。</p>
<p>像现在的许多游戏一样，我们也需要在发售之后更新游戏，修复漏洞或是添加新内容。
如果所有法术都是硬编码的，那么每次修改都意味着要给游戏的可执行文件打补丁。</p>
<p>再扯远一点，假设我们还想支持<strong>模组</strong>。我们想让<strong>玩家</strong>创造自己的法术。
如果这些法术都是硬编码的，那就意味着每个模组制造者都得拥有编译游戏的整套工具链，
我们也就不得不开放源代码，如果他们的自创法术上有个漏洞，那么就会把其他人的游戏也搞崩溃。</p>
<h3><a class="header" href="#数据---代码" id="数据---代码">数据 -&gt; 代码</a></h3>
<p>很明显实现引擎的编程语言不是个好选择。
我们需要将法术放在与游戏核心隔绝的沙箱中。
我们想要它们易于修改，易于加载，并与其他可执行部分相隔离。</p>
<p>我不知道你怎么想，但这听上去让我觉得有点像是<strong>数据</strong>。
如果能在分离的数据文件中定义行为，游戏引擎还能加载并“执行”它们，就可以实现所有目标。</p>
<p>这里需要指出“执行”对于数据的意思。如何让文件中的数据表示为行为呢？这里有几种方式。
与<a href="http://en.wikipedia.org/wiki/Interpreter_pattern">解释器模式</a>对比着看会好理解些。</p>
<h3><a class="header" href="#解释器模式" id="解释器模式">解释器模式</a></h3>
<p>关于这个模式我就能写整整一章，但是有四个家伙的工作早涵盖了这一切，
所以，这里给一些简短的介绍。</p>
<p>它源于一种你想要执行的语言——想想<strong>编程</strong>语言。</p>
<p>比如，它支持这样的算术表达式</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    (1 + 2) ** (3 - 4)
<span class="boring">}
</span></code></pre></pre>
<p>然后，把每块表达式，每条语言规则，都装到<strong>对象</strong>中去。数字字面量都变成对象：</p>
<pre class="mermaid">graph TB
    A; B; C; D;
</pre>
<p>简单地说，它们在原始值上做了个小封装。
运算符也是对象，它们拥有操作数的引用。
如果你考虑了括号和优先级，那么表达式就魔术般变成这样的小树：</p>
<pre class="mermaid">graph TB
    * --> + & -;
    + --> 1 & 2;
    - --> 3 & 4;
</pre>
<blockquote>
<p>这里的“魔术”是什么？很简单——<strong>语法分析（parsing）</strong>。
语法分析器接受一串字符作为输入，将其转为<strong>抽象语法树（Abstract syntax tree，AST）</strong>，即一个包含了表示文本语法结构的对象集合。</p>
<p>完成这个你就得到了半个编译器。</p>
</blockquote>
<p>解释器模式与<strong>创建</strong>这棵树无关，它只关于<strong>执行</strong>这棵树。
它工作的方式非常巧妙。树中的每个对象都是表达式或子表达式。
用真正面向对象的方式描述，我们会让表达式自己对自己求值。</p>
<p>首先，我们定义所有表达式都实现的基本接口：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Expression
{
public:
  virtual ~Expression() {}
  virtual double evaluate() = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p>然后，为我们语言中的每种语法定义一个实现这个接口的类。最简单的是数字：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class NumberExpression : public Expression
{
public:
  NumberExpression(double value)
  : value_(value)
  {}

  virtual double evaluate()
  {
    return value_;
  }

private:
  double value_;
};
<span class="boring">}
</span></code></pre></pre>
<p>一个数字表达式就等于它的值。加法和乘法有点复杂，因为它们包含子表达式。在一个表达式计算自己的值之前，必须先递归地计算其子表达式的值。像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class AdditionExpression : public Expression
{
public:
  AdditionExpression(Expression* left, Expression* right)
  : left_(left),
    right_(right)
  {}

  virtual double evaluate()
  {
    // 计算操作数
    double left = left_-&gt;evaluate();
    double right = right_-&gt;evaluate();

    // 把它们加起来
    return left + right;
  }

private:
  Expression* left_;
  Expression* right_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>你肯定能想明白乘法的实现是什么样的。</p>
</blockquote>
<p>很优雅对吧？只需几个简单的类，现在我们可以表示和计算任意复杂的算术表达式。
只需要创建正确的对象，并正确地连起来。</p>
<blockquote>
<p>Ruby 用了这种实现方法差不多 15 年。在 1.9 版本，他们转换到了本章所介绍的字节码。看看我给你节省了多少时间！</p>
</blockquote>
<p>这是个优美、简单的模式，但它有一些问题。
看看插图，看到了什么？大量的小盒子，以及它们之间大量的箭头。
代码被表示为小物体组成的巨大分形树。这会带来些令人不快的后果：</p>
<ul>
<li>
<p>从磁盘上加载它需要实例化并连接成吨的小对象。</p>
</li>
<li>
<p>这些对象和它们之间的指针会占据大量的内存。在 32 位机上，那个小的算术表达式至少要占据 68 字节，这还没考虑内存对其呢。</p>
<blockquote>
<p>如果你想自己算算，别忘了算上虚函数表指针。</p>
</blockquote>
</li>
<li>
<p>顺着那些指针遍历子表达式是对数据缓存的谋杀。同时，虚函数调用是对指令缓存的屠戮。</p>
<blockquote>
<p>参见<a href="07-1%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7.html">数据局部性</a>一章以了解什么是缓存以及它是如何影响游戏性能的。</p>
</blockquote>
</li>
</ul>
<p>将这些拼到一起，怎么念？S-L-O-W。
这就是为什么大多数广泛应用的编程语言不基于解释器模式：
太慢了，也太消耗内存了。</p>
<h3><a class="header" href="#虚拟的机器码" id="虚拟的机器码">虚拟的机器码</a></h3>
<p>想想我们的游戏。玩家电脑在运行游戏时并不会遍历一堆 C++语法结构树。
我们提前将其编译成了机器码，CPU 基于机器码运行。机器码有什么好处呢？</p>
<ul>
<li>
<p><strong>密集。</strong> 它是一块坚实连续的二进制数据块，没有一位被浪费。</p>
</li>
<li>
<p><strong>线性。</strong> 指令被打成包，一条接一条地执行。不会在内存里到处乱跳（除非你的控制流代码真真这么干了）。</p>
</li>
<li>
<p><strong>底层。</strong> 每条指令都做一件小事，有趣的行为从<strong>组合</strong>中诞生。</p>
</li>
<li>
<p><strong>速度快。</strong> 综合所有这些条件（当然，也包括它直接由硬件实现这一事实），机器码跑得跟风一样快。</p>
</li>
</ul>
<p>这听起来很好，但我们不希望真的用机器代码来写咒语。
让玩家提供游戏运行时的机器码简直是在自找麻烦。我们需要的是机器代码的性能和解释器模式的安全的折中。</p>
<p>如果不是加载机器码并直接执行，而是定义自己的<strong>虚拟</strong>机器码呢？
然后，在游戏中写个小模拟器。
这与机器码类似——密集，线性，相对底层——但也由游戏直接掌控，所以可以放心地将其放入沙箱。</p>
<blockquote>
<p>这就是为什么很多游戏主机和 iOS 不允许程序在运行时生成并加载机器码。
这是一种拖累，因为最快的编程语言实现就是那么做的。
它们包含了“即时（just-in-time）”编译器，或者<strong>JIT</strong>，在运行时将语言翻译成优化的机器码。</p>
</blockquote>
<p>我们将小模拟器称为<strong>虚拟机</strong>（或简称“VM”），它运行的二进制机器码叫做<strong>字节码</strong>。
它有数据的灵活性和易用性，但比解释器模式性能更好。</p>
<blockquote>
<p>在程序语言编程圈，“虚拟机”和“解释器”是同义词，我在这里交替使用。
当指代 GoF 的解释器模式，我会加上“模式”来表明区别。</p>
</blockquote>
<p>这听起来有点吓人。
这章其余部分的目标是为了展示一下，如果把功能列表缩减下来，它实际上相当通俗易懂。
即使最终没有使用这个模式，你也至少可以对 Lua 和其他使用了这一模式的语言有个更好的理解。</p>
<h2><a class="header" href="#模式-6" id="模式-6">模式</a></h2>
<p><strong>指令集</strong> 定义了可执行的底层操作。一系列的指令被编码为<strong>字节序列</strong>。</p>
<p><strong>虚拟机</strong> 使用 <strong>中间值栈</strong> 依次执行这些指令。通过组合指令，可以定义复杂的高层行为。</p>
<h2><a class="header" href="#何时使用-3" id="何时使用-3">何时使用</a></h2>
<p>这是本书中最复杂的模式，无法轻易地加入游戏中。这个模式应当用在你有许多行为需要定义，而游戏实现语言因为如下原因不适用时：</p>
<ul>
<li>过于底层，繁琐易错。</li>
<li>编译慢或者其他工具因素导致迭代缓慢。</li>
<li>安全性依赖编程者。如果想保证行为不会破坏游戏，你需要将其与代码的其他部分隔开。</li>
</ul>
<p>当然，该列表描述了一堆特性。谁不希望有更快的迭代循环和更多的安全性？
然而，世上没有免费的午餐。字节码比本地代码慢，所以不适合引擎的性能攸关的部分。</p>
<h2><a class="header" href="#记住-3" id="记住-3">记住</a></h2>
<p>创建自己的语言或者建立系统中的系统是很有趣的。
我在这里做的是小演示，但在现实项目中，这些东西会像藤蔓一样蔓延。</p>
<blockquote>
<p>对我来说，游戏开发也正因此而有趣。
不管哪种情况，我都创建了虚拟空间让他人游玩。</p>
</blockquote>
<p>每当我看到有人定义小语言或脚本系统，他们都说，“别担心，它很小。”
于是，不可避免地，他们增加更多小功能，直到完成了一个完整的语言。
除了，和其它语言不同，它是定制的并拥有棚户区的建筑风格。</p>
<blockquote>
<p>例如每一种模板语言。</p>
</blockquote>
<p>当然，完成完整的语言并没有什么<strong>错</strong>。只是要确定你做得慎重。 否则，你就要小心地控制你的字节码所能表达的范围。在野马脱缰之前把它拴住。</p>
<h3><a class="header" href="#你需要一个前端" id="你需要一个前端">你需要一个前端</a></h3>
<p>底层的字节码指令性能优越，但是二进制的字节码格式<strong>不是</strong>用户能写的。
我们将行为移出代码的一个原因是想要以更<strong>高层</strong>的形式表示它。
如果说写 C++太过底层，那么让用户写汇编可不是一个改进方案——就算是你设计的！</p>
<blockquote>
<p>一个反例的是令人尊敬的游戏<a href="http://en.wikipedia.org/wiki/RoboWar">RoboWar</a>。
在游戏中，<strong>玩家</strong> 编写类似汇编的语言控制机器人，我们这里也会讨论这种指令集。</p>
<p>这是我介绍类似汇编的语言的首选。</p>
</blockquote>
<p>就像 GoF 的解释器模式，它假设你有某些方法来<strong>生成</strong>字节码。
通常情况下，用户在更高层编写行为，再用工具将其翻译为虚拟机能理解的字节码。
这里的工具就是编译器。</p>
<p>我知道，这听起来很吓人。丑话说在前头，
如果没有资源制作编辑器，那么字节码不适合你。
但是，接下来你会看到，也可能没你想的那么糟。</p>
<h3><a class="header" href="#你会想念调试器" id="你会想念调试器">你会想念调试器</a></h3>
<p>编程很难。我们知道想要机器做什么，但并不总能正确地传达——所以我们会写出漏洞。
为了查找和修复漏洞，我们已经积累了一堆工具来了解代码做错了什么，以及如何修正。
我们有调试器，静态分析器，反编译工具等。
所有这些工具都是为现有的语言设计的：无论是机器码还是某些更高层次的东西。</p>
<p>当你定义自己的字节码虚拟机时，你就得把这些工具抛在脑后了。
当然，可以通过调试器调试虚拟机，但它告诉你虚拟机<strong>本身</strong>在做什么，而不是正在被翻译的字节码是干什么的。</p>
<p>它当然也不会把字节码映射回编译前的高层次的形式。</p>
<p>如果你定义的行为很简单，可能无需太多工具帮忙调试就能勉强坚持下来。
但随着内容规模增长，还是应该花些时间完成些功能，让用户看到字节码在做什么。
这些功能也许不随游戏发布，但它们至关重要，它们能确保你的游戏<strong>能</strong>被发布。</p>
<blockquote>
<p>当然，如果你想要让游戏支持模组，那你<strong>会</strong>发布这些特性，它们就更加重要了。</p>
</blockquote>
<h2><a class="header" href="#示例代码-3" id="示例代码-3">示例代码</a></h2>
<p>经历了前面几个章节后，你也许会惊讶于它的实现是多么直接。
首先需要为虚拟机设定一套指令集。
在开始考虑字节码之类的东西前，先像思考 API 一样思考它。</p>
<h3><a class="header" href="#法术的-api" id="法术的-api">法术的 API</a></h3>
<p>如果直接使用 C++代码定义法术，代码需要调用何种 API 呢？
在游戏引擎中，构成法术的基本操作是什么样的？</p>
<p>大多数法术最终改变一个巫师的状态，因此先从这样的代码开始。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void setHealth(int wizard, int amount);
void setWisdom(int wizard, int amount);
void setAgility(int wizard, int amount);
<span class="boring">}
</span></code></pre></pre>
<p>第一个参数指定哪个巫师被影响，<code>0</code>代表玩家而<code>1</code>代表对手。
以这种方式，治愈法术可以治疗玩家的巫师，而伤害法术伤害他的敌人。
这三个小方法能覆盖的法术出人意料地多。</p>
<p>如果法术只是默默地调整数据，游戏逻辑就已经完成了，
但玩这样的游戏会让玩家无聊得要哭。让我们修复这点：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void playSound(int soundId);
void spawnParticles(int particleType);
<span class="boring">}
</span></code></pre></pre>
<p>这并不影响游戏玩法，但它们增强了游戏的<strong>体验</strong>。
我们可以增加一些镜头晃动，动画之类的，但这足够我们开始了。</p>
<h3><a class="header" href="#法术指令集" id="法术指令集">法术指令集</a></h3>
<p>现在让我们把这种<strong>程序化</strong>的 API 转化为可被数据控制的东西。
从小处开始，然后慢慢拓展到整体。
现在，要去除方法的所有参数。
假设<code>set__()</code>方法总影响玩家的巫师，总直接将状态设为最大值。
同样，FX 操作总是播放一个硬编码的声音和粒子效果。</p>
<p>这样，一个法术就只是一系列指令了。
每条指令都代表了想要呈现的操作。我们可以枚举如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Instruction
{
  INST_SET_HEALTH      = 0x00,
  INST_SET_WISDOM      = 0x01,
  INST_SET_AGILITY     = 0x02,
  INST_PLAY_SOUND      = 0x03,
  INST_SPAWN_PARTICLES = 0x04
};
<span class="boring">}
</span></code></pre></pre>
<p>为了将法术编码进数据，我们存储了一数组<code>enum</code>值。
只有几个不同的基本操作原语，因此<code>enum</code>值的范围可以存储到一个字节中。
这就意味着法术的代码就是一系列字节——也就是“字节码”。</p>
<p><img src="https://gpp.tkchu.me/images/bytecode-code.png" alt="一系列字节码指令：0x00 HEALTH, 0x03 SOUND, 0x004 PARTICLES, ..." /></p>
<blockquote>
<p>有些字节码虚拟机为每条指令使用多个字节，解码规则也更复杂。
事实上，在 x86 这样的常见芯片上的机器码更加复杂。</p>
</blockquote>
<p>但单字节对于<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">Java 虚拟机</a>和支撑了.NET 平台的<a href="http://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime</a>已经足够了，对我们来说也一样。</p>
<p>为了执行一条指令，我们看看它的基本操作原语是什么，然后调用正确的 API 方法。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>switch (instruction)
{
  case INST_SET_HEALTH:
    setHealth(0, 100);
    break;

  case INST_SET_WISDOM:
    setWisdom(0, 100);
    break;

  case INST_SET_AGILITY:
    setAgility(0, 100);
    break;

  case INST_PLAY_SOUND:
    playSound(SOUND_BANG);
    break;

  case INST_SPAWN_PARTICLES:
    spawnParticles(PARTICLE_FLAME);
    break;
}
<span class="boring">}
</span></code></pre></pre>
<p>用这种方式，解释器建立了沟通代码世界和数据世界的桥梁。我们可以像这样将其放进执行法术的虚拟机：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class VM
{
public:
  void interpret(char bytecode[], int size)
  {
    for (int i = 0; i &lt; size; i++)
    {
      char instruction = bytecode[i];
      switch (instruction)
      {
        // 每条指令的跳转分支……
      }
    }
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>输入这些，你就完成了你的首个虚拟机。
不幸的是，它并不灵活。
我们不能设定攻击对手的法术，也不能减少状态上限。我们只能播放声音！</p>
<p>为了获得像一个真正的语言那样的表达能力，我们需要在这里引入参数。</p>
<h3><a class="header" href="#栈式机器" id="栈式机器">栈式机器</a></h3>
<p>要执行复杂的嵌套表达式，得先从最里面的子表达式开始。
计算完里面的，将结果作为参数向外流向包含它们的表达式，
直到得出最终结果，整个表达式就算完了。</p>
<p>解释器模式将其明确地表现为嵌套对象组成的树，但我们需要指令速度达到列表的速度。我们仍然需要确保子表达式的结果正确地向外传递给包括它的表达式。</p>
<p>但由于数据是扁平的，我们得使用指令的<strong>顺序</strong>来控制这一点。我们的做法和 CPU 一样——使用栈。</p>
<blockquote>
<p>这种架构不出所料地被称为<a href="http://en.wikipedia.org/wiki/Stack_machine"><strong>栈式计算机</strong></a>。像<a href="http://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a>，<a href="http://en.wikipedia.org/wiki/PostScript">PostScript</a>，和<a href="http://en.wikipedia.org/wiki/Factor_(programming_language)">Factor</a> 这些语言直接将这点暴露给用户。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class VM
{
public:
  VM()
  : stackSize_(0)
  {}

  // 其他代码……

private:
  static const int MAX_STACK = 128;
  int stackSize_;
  int stack_[MAX_STACK];
};
<span class="boring">}
</span></code></pre></pre>
<p>虚拟机用内部栈保存值。在例子中，指令交互的值只有一种，那就是数字，
所以可以使用简单的<code>int</code>数组。
每当数据需要从一条指令传到另一条，它就得通过栈。</p>
<p>顾名思义，值可以压入栈或者从栈弹出，所以让我们添加一对方法。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class VM
{
private:
  void push(int value)
  {
    // 检查栈溢出
    assert(stackSize_ &lt; MAX_STACK);
    stack_[stackSize_++] = value;
  }

  int pop()
  {
    // 保证栈不是空的
    assert(stackSize_ &gt; 0);
    return stack_[--stackSize_];
  }

  // 其余的代码
};
<span class="boring">}
</span></code></pre></pre>
<p>当一条指令需要接受参数，就将参数从栈弹出，如下所示：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>switch (instruction)
{
  case INST_SET_HEALTH:
  {
    int amount = pop();
    int wizard = pop();
    setHealth(wizard, amount);
    break;
  }

  case INST_SET_WISDOM:
  case INST_SET_AGILITY:
    // 像上面一样……

  case INST_PLAY_SOUND:
    playSound(pop());
    break;

  case INST_SPAWN_PARTICLES:
    spawnParticles(pop());
    break;
}
<span class="boring">}
</span></code></pre></pre>
<p>为了将一些值<strong>存入</strong>栈中，需要另一条指令：字面量。
它代表了原始的整数值。但是<strong>它</strong>的值又是从哪里来的呢？
我们怎么样避免这样追根溯源到无穷无尽呢？</p>
<p>技巧是利用指令是字节序列这一事实——我们可以直接将数值存储在字节数组中。
如下，我们为数值字面量定义了另一条指令类型：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>case INST_LITERAL:
{
  // 从字节码中读取下一个字节
  int value = bytecode[++i];
  push(value);
  break;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里，从单个字节中读取值，从而避免了解码多字节整数需要的代码，
但在真实实现中，你会需要支持整个数域的字面量。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/bytecode-literal.png" alt="字面量指令的二进制编码：0x05 (字面量) 之后是 123 (值)。" /></p>
<p>它读取字节码流中的字节<strong>作为数值</strong>并将其压入栈。</p>
<p>让我们把一些这样的指令串起来看看解释器的执行，感受下栈是如何工作的。
从空栈开始，解释器指向第一个指令：</p>
<p><img src="https://gpp.tkchu.me/images/bytecode-stack-1.png" alt="执行一个字节码序列。执行指针指向第一个字面量指令，栈是空的。" /></p>
<p>首先，它执行第一条<code>INST_LITERAL</code>，读取字节码流的下一个字节(<code>0</code>)并压入栈中。</p>
<p><img src="https://gpp.tkchu.me/images/bytecode-stack-2.png" alt="下一步。字面量0倍压入到了栈中，执行指针指向了下一个字面量。" /></p>
<p>然后，它执行第二条<code>INST_LITERAL</code>，读取<code>10</code>然后压入。</p>
<p><img src="https://gpp.tkchu.me/images/bytecode-stack-3.png" alt="下一步。现在10倍压入了栈中，执行指针指向了Health指令。" /></p>
<p>最后，执行<code>INST_SET_HEALTH</code>。这会弹出<code>10</code>存进<code>amount</code>，弹出<code>0</code>存进<code>wizard</code>。然后用这两个参数调用<code>setHealth()</code>。</p>
<p>完成！我们获得了将玩家巫师血量设为 10 点的法术。
现在我们拥有了足够的灵活度，来定义修改任一巫师的状态到任意值的法术。
我们还可以放出不同的声音和粒子效果。</p>
<p>但是……这感觉还是像<strong>数据</strong>格式。比如，不能将巫师的血量提升为他智力的一半。
设计师希望法术能表达<strong>规则</strong>，而不仅仅是<strong>数值</strong>。</p>
<h3><a class="header" href="#行为--组合" id="行为--组合">行为 = 组合</a></h3>
<p>如果我们视小虚拟机为编程语言，现在它能支持的只有一些内置函数，以及常量参数。
为了让字节码感觉像<strong>行为</strong>，我们缺少的是<strong>组合</strong>。</p>
<p>设计师需要能以有趣的方式组合不同的值，来创建表达式。
举个简单的例子，他们想让法术<strong>变化</strong>一个数值而不是<strong>变到</strong>一个数值。</p>
<p>这需要考虑到状态的当前值。
我们有指令来<strong>修改</strong>状态，现在需要添加方法<strong>读取</strong>状态：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>case INST_GET_HEALTH:
{
  int wizard = pop();
  push(getHealth(wizard));
  break;
}

case INST_GET_WISDOM:
case INST_GET_AGILITY:
  // 你知道思路了吧……
<span class="boring">}
</span></code></pre></pre>
<p>正如你所看到的，这要与栈双向交互。
弹出一个参数来确定获取哪个巫师的状态，然后查找状态的值并压入栈中。</p>
<p>这允许我们创造复制状态的法术。
我们可以创建一个法术，根据巫师的智慧设定敏捷度，或者让巫师的血量等于对方的血量。</p>
<p>有所改善，但仍很受限制。接下来，我们需要算术。
是时候让小虚拟机学习如何计算 1 + 1 了，我们将添加更多的指令。
现在，你可能已经知道如何去做，猜到了大概的模样。我只展示加法：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>case INST_ADD:
{
  int b = pop();
  int a = pop();
  push(a + b);
  break;
}
<span class="boring">}
</span></code></pre></pre>
<p>像其他指令一样，它弹出数值，做点工作，然后压入结果。
直到现在，每个新指令似乎都只是有所改善而已，但其实我们已完成大飞跃。
这并不显而易见，但现在我们可以处理各种复杂的，深层嵌套的算术表达式了。</p>
<p>来看个稍微复杂点的例子。
假设我们希望有个法术，能让巫师的血量增加敏捷和智慧的平均值。
用代码表示如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>setHealth(0, getHealth(0) +
    (getAgility(0) + getWisdom(0)) / 2);
<span class="boring">}
</span></code></pre></pre>
<p>你可能会认为我们需要指令来处理括号造成的分组，但栈隐式支持了这一点。可以手算如下：</p>
<ol>
<li>获取巫师当前的血量并记录。</li>
<li>获取巫师敏捷并记录。</li>
<li>对智慧执行同样的操作。</li>
<li>获取最后两个值，加起来并记录。</li>
<li>除以二并记录。</li>
<li>回想巫师的血量，将它和这结果相加并记录。</li>
<li>取出结果，设置巫师的血量为这一结果。</li>
</ol>
<p>你看到这些“记录”和“回想”了吗？每个“记录”对应一个压入，“回想”对应弹出。
这意味着可以很容易将其转化为字节码。例如，第一行获得巫师的当前血量：</p>
<pre><code class="language-text">LITERAL 0
GET_HEALTH
</code></pre>
<p>这些字节码将巫师的血量压入堆栈。
如果我们机械地将每行都这样转化，最终得到一大块等价于原来表达式的字节码。
为了让你感觉这些指令是如何组合的，我在下面给你做个示范。</p>
<p>为了展示堆栈如何随着时间推移而变化，我们举个代码执行的例子。
巫师目前有 45 点血量，7 点敏捷，和 11 点智慧。
每条指令的右边是栈在执行指令之后的模样，再右边是解释指令意图的注释：</p>
<pre><code class="language-text">LITERAL 0    [0]            # 巫师索引
LITERAL 0    [0, 0]         # 巫师索引
GET_HEALTH   [0, 45]        # 获取血量()
LITERAL 0    [0, 45, 0]     # 巫师索引
GET_AGILITY  [0, 45, 7]     # 获取敏捷()
LITERAL 0    [0, 45, 7, 0]  # 巫师索引
GET_WISDOM   [0, 45, 7, 11] # 获取智慧()
ADD          [0, 45, 18]    # 将敏捷和智慧加起来
LITERAL 2    [0, 45, 18, 2] # 被除数：2
DIVIDE       [0, 45, 9]     # 计算敏捷和智慧的平均值
ADD          [0, 54]        # 将平均值加到现有血量上。
SET_HEALTH   []             # 将结果设为血量
</code></pre>
<p>如果你注意每步的栈，你可以看到数据如何魔法一般地在其中流动。
我们最开始压入<code>0</code>来查找巫师，然后它一直挂在栈的底部，直到最终的<code>SET_HEALTH</code>才用到它。</p>
<blockquote>
<p>也许“魔法”在这里的门槛太低了。</p>
</blockquote>
<h3><a class="header" href="#一台虚拟机" id="一台虚拟机">一台虚拟机</a></h3>
<p>我可以继续下去，添加越来越多的指令，但是时候适可而止了。
如上所述，我们已经有了一个可爱的小虚拟机，可以使用简单，紧凑的数据格式，定义开放的行为。
虽然“字节码”和“虚拟机”的听起来很吓人，但你可以看到它们往往简单到只需栈，循环，和 switch 语句。</p>
<p>还记得我们最初的让行为呆在沙盒中的目标吗？
现在，你已经看到虚拟机是如何实现的，很明显，那个目标已经完成。
字节码不能把恶意触角伸到游戏引擎的其他部分，因为我们只定义了几个与其他部分接触的指令。</p>
<p>我们通过控制栈的大小来控制内存使用量，并很小心地确保它不会溢出。
我们甚至可以控制它使用多少<strong>时间</strong>。
在指令循环里，可以追踪已经执行了多少指令，如果遇到了问题也可以摆脱困境。</p>
<blockquote>
<p>控制运行时间在例子中没有必要，因为没有任何循环的指令。
可以限制字节码的总体大小来限制运行时间。
这也意味着我们的字节码不是图灵完备的。</p>
</blockquote>
<p>现在就剩一个问题了：创建字节码。
到目前为止，我们使用伪代码，再手工编写为字节码。
除非你有<strong>很多</strong>的空闲时间，否则这种方式并不实用。</p>
<h3><a class="header" href="#语法转换工具" id="语法转换工具">语法转换工具</a></h3>
<p>我们最初的目标是创造更<strong>高层</strong>的方式来控制行为，但是，我们却创造了比 C++更<strong>底层</strong>的东西。
它具有我们想要的运行性能和安全性，但绝对没有对设计师友好的可用性。</p>
<p>为了填补这一空白，我们需要一些工具。
我们需要一个程序，让用户定义法术的高层次行为，然后生成对应的低层栈式机字节码。</p>
<p>这可能听起来比虚拟机更难。
许多程序员都在大学参加编译器课程，除了被龙书或者&quot;<a href="http://en.wikipedia.org/wiki/Lex_(software)">lex</a>&quot;和&quot;<a href="http://en.wikipedia.org/wiki/Yacc">yacc</a>&quot;引发了 PTSD 外，什么也没真正学到。</p>
<blockquote>
<p>我指的，当然，是经典教材<a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"><strong>Compilers: Principles, Techniques, and Tools</strong></a>。</p>
</blockquote>
<p>事实上，编译一个基于文本的语言并不那么糟糕，尽管把这个话题放进这里来要牵扯的东西有<strong>点</strong>多。但是，你不是非得那么做。
我说，我们需要的是<strong>工具</strong>——它并不一定是个输入格式是<strong>文本文件</strong>的<strong>编译器</strong>。</p>
<p>相反，我建议你考虑构建图形界面让用户定义自己的行为，
尤其是在使用它的人没有很高的技术水平时。
没有花几年时间习惯编译器怒吼的人很难写出没有语法错误的文本。</p>
<p>你可以建立一个应用程序，用户通过单击拖动小盒子，下拉菜单项，或任何有意义的行为创建“脚本”，从而创建行为。</p>
<p><img src="https://gpp.tkchu.me/images/bytecode-ui.png" alt="编写行为的树状结构UI" /></p>
<blockquote>
<p>我为<a href="http://en.wikipedia.org/wiki/Henry_Hatsworth_in_the_Puzzling_Adventure">Henry Hatsworth in the Puzzling Adventure</a>编写的脚本系统就是这么工作的。</p>
</blockquote>
<p>这样做的好处是，你的 UI 可以保证用户无法创建“无效的”程序。
与其向他们吐一大堆错误警告，不如主动禁用按钮或提供默认值，
以确保他们创造的东西在任何时间点上都有效。</p>
<blockquote>
<p>我想要强调错误处理是多么重要。作为程序员，我们趋向于将人为错误视为应当极力避免的的个人耻辱。</p>
<p>为了制作用户喜欢的系统，你需要接受人性，<strong>包括他们的失败</strong>。是人都会犯错误，但错误同时也是创作的固有基础。
用撤销这样的特性优雅地处理它们，这能让用户更有创意，创作出更好的成果。</p>
</blockquote>
<p>这免去了设计语法和编写解析器的工作。
但是我知道，你可能会发现 UI 设计同样令人不快。
好吧，如果这样，我就没啥办法啦。</p>
<p>毕竟，这种模式是关于使用对用户友好的高层方式表达行为。
你必须精心设计用户体验。
要有效地执行行为，又需要将其转换成底层形式。这是必做的，但如果你准备好迎接挑战，这终会有所回报。</p>
<h2><a class="header" href="#设计决策-3" id="设计决策-3">设计决策</a></h2>
<p>我想尽可能让本章简短，但我们所做的事情实际上可是创造语言啊。
那可是个宽泛的设计领域，你可以从中获得很多乐趣，所以别沉迷于此反而忘了完成你的游戏。</p>
<blockquote>
<p>这是本书中最长的章节，看来我失败了。</p>
</blockquote>
<h3><a class="header" href="#指令如何访问堆栈" id="指令如何访问堆栈">指令如何访问堆栈</a></h3>
<p>字节码虚拟机主要有两种：基于栈的和基于寄存器的。
栈式虚拟机中，指令总是操作栈顶，如同我们的示例代码所示。
例如，<code>INST_ADD</code>弹出两个值，将它们相加，将结果压入。</p>
<p>基于寄存器的虚拟机也有栈。唯一不同的是指令可以从栈的深处读取值。
不像<code>INST_ADD</code>始终<strong>弹出</strong>其操作数，
它在字节码中存储两个索引，指示了从栈的何处读取操作数。</p>
<ul>
<li>
<p><strong>基于栈的虚拟机：</strong></p>
<ul>
<li>
<p><strong>指令短小。</strong>
由于每个指令隐式认定在栈顶寻找参数，不需要为任何数据编码。
这意味着每条指令可能会非常短，一般只需一个字节。</p>
</li>
<li>
<p><strong>易于生成代码。</strong>
当你需要为生成字节码编写编译器或工具时，你会发现基于栈的字节码更容易生成。
由于每个指令隐式地在栈顶工作，你只需要以正确的顺序输出指令就可以在它们之间传递参数。</p>
</li>
<li>
<p><strong>会生成更多的指令。</strong>
每条指令只能看到栈顶。这意味着，产生像<code>a = b + c</code>这样的代码，
你需要单独的指令将<code>b</code>和<code>c</code>压入栈顶，执行操作，再将结果压入<code>a</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong>基于寄存器的虚拟机：</strong></p>
<ul>
<li>
<p><strong>指令较长。</strong>
由于指令需要参数记录栈偏移量，单个指令需要更多的位。
例如，一个 Lua 指令占用完整的 32 位——它可能是最著名的基于寄存器的虚拟机了。
它采用 6 位做指令类型，其余的是参数。</p>
<blockquote>
<p>Lua 作者没有指定 Lua 的字节码格式，它每个版本都会改变。现在描述的是 Lua 5.1。
要深究 Lua 的内部构造，
读读<a href="http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf">这个</a>。</p>
</blockquote>
</li>
<li>
<p><strong>指令较少。</strong>
由于每个指令可以做更多的工作，你不需要那么多的指令。
有人说，性能会得以提升，因为不需要将值在栈中移来移去了。</p>
</li>
</ul>
</li>
</ul>
<p>所以，应该选一种？我的建议是坚持使用基于栈的虚拟机。
它们更容易实现，也更容易生成代码。
Lua 转换为基于寄存器的虚拟机从而变得更快，这为寄存器虚拟机博得了声誉，
但是这<strong>强烈</strong>依赖于实际的指令和虚拟机的其他大量细节。</p>
<h3><a class="header" href="#你有什么指令" id="你有什么指令">你有什么指令</a></h3>
<p>指令集定义了在字节码中可以干什么，不能干什么，对虚拟机性能也有很大的影响。
这里有个清单，记录了你可能需要的不同种类的指令：</p>
<ul>
<li>
<p><strong>外部基本操作原语。</strong>
这是虚拟机与引擎其他部分交互，影响玩家所见的部分。
它们控制了字节码可以表达的真实行为。
如果没有这些，你的虚拟机除了消耗 CPU 循环以外一无所得。</p>
</li>
<li>
<p><strong>内部基本操作原语</strong>
这些语句在虚拟机内操作数值——文字，算术，比较操作，以及操纵栈的指令。</p>
</li>
<li>
<p><strong>控制流。</strong>
我们的例子没有包含这些，但当你需要有条件执行或循环执行，你就会需要控制流。
在字节码这样底层的语言中，它们出奇地简单：跳转。</p>
<p>在我们的指令循环中，需要索引来跟踪执行到了字节码的哪里。
跳转指令做的是修改这个索引并改变将要执行的指令。
换言之，这就是<code>goto</code>。你可以基于它制定各种更高级别的控制流。</p>
</li>
<li>
<p><strong>抽象。</strong>
如果用户开始在数据中定义<strong>很多</strong>的东西，最终要重用字节码的部分位，而不是复制和粘贴。
你也许会需要可调用过程这样的东西。</p>
<p>最简单的形式中，过程并不比跳转复杂。
唯一不同的是，虚拟机需要管理另一个<strong>返回</strong>栈。
当执行“call”指令时，将当前指令索引压入栈中，然后跳转到被调用的字节码。
当它到了“return”，虚拟机从堆栈弹出索引，然后跳回索引指示的位置。</p>
</li>
</ul>
<h3><a class="header" href="#数值是如何表示的" id="数值是如何表示的">数值是如何表示的</a></h3>
<p>我们的虚拟机示例只与一种数值打交道：整数。
回答这个问题很简单——栈只是一栈的<code>int</code>。
更加完整的虚拟机支持不同的数据类型：字符串，对象，列表等。
你必须决定在内部如何存储这些值。</p>
<ul>
<li>
<p><strong>单一数据类型：</strong></p>
<ul>
<li>
<p><strong>简单易用</strong>
你不必担心标记，转换，或类型检查。</p>
</li>
<li>
<p><strong>无法使用不同的数据类型。</strong>
这是明显的缺点。将不同类型成塞进单一的表示方式——比如将数字存储为字符串——这是自找麻烦。</p>
</li>
</ul>
</li>
<li>
<p><strong>带标记的类型：</strong></p>
<p>这是动态类型语言中常见的表示法。
所有的值有两部分。
第一部分是类型标识——一个存储了数据的类型的<code>enum</code>。其余部分会被解释为这种类型：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>  enum ValueType
  {
  TYPE_INT,
  TYPE_DOUBLE,
  TYPE_STRING
  };
  struct Value
  {
  ValueType type;
  union
  {
    int    intValue;
    double doubleValue;
    char*  stringValue;
  };
  };
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p><strong>数值知道其类型。</strong>
这个表示法的好处是可在运行时检查值的类型。
这对动态调用很重要，可以确保没有在类型上面执行其不支持的操作。</p>
</li>
<li>
<p><strong>消耗更多内存。</strong>
每个值都要带一些额外的位来标识类型。在像虚拟机这样的底层，这里几位，那里几位，总量就会快速增加。</p>
</li>
</ul>
</li>
<li>
<p><strong>无标识的 union：</strong></p>
<p>像前面一样使用 union，但是<strong>没有</strong>类型标识。
你可以将这些位表示为不同的类型，由你确保没有搞错值的类型。</p>
<p>这是静态类型语言在内存中表示事物的方式。
由于类型系统在编译时保证没弄错值的类型，不需要在运行时对其进行验证。</p>
<blockquote>
<p>这也是<strong>无类型</strong>语言，像汇编和 Forth 存储值的方式。
这些语言让<strong>用户</strong>保证不会写出误认值的类型的代码。毫无服务态度！</p>
</blockquote>
<ul>
<li>
<p><strong>结构紧凑。</strong>
找不到比只存储需要的值更加有效率的存储方式。</p>
</li>
<li>
<p><strong>速度快。</strong>
没有类型标识意味着在运行时无需消耗周期检查它们的类型。这是静态类型语言往往比动态类型语言快的原因之一。</p>
</li>
<li>
<p><strong>不安全。</strong> 这是真正的代价。一块错误的字节码，会让你误解一个值，把数字误解为指针，会破坏游戏安全性从而导致崩溃。</p>
<blockquote>
<p>如果你的字节码是由静态类型语言编译而来，你也许认为它是安全的，因为编译不会生成不安全的字节码。
那也许是真的，但记住恶意用户也许会手写恶意代码而不经过你的编译器。</p>
<p>举个例子，这就是为什么 Java 虚拟机在加载程序时要做<strong>字节码验证</strong>。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>接口：</strong></p>
<p>多种类型值的面向对象解决方案是通过多态。接口为不同的类型的测试和转换提供虚方法，如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Value
{
public:
virtual ~Value() {}

virtual ValueType type() = 0;

virtual int asInt() {
  // 只能在int上调用
  assert(false);
  return 0;
}

 // 其他转换方法……
};
<span class="boring">}
</span></code></pre></pre>
<p>然后你为每个特定的数据类型设计特定的类，如：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class IntValue : public Value
{
public:
IntValue(int value)
: value_(value)
{}

virtual ValueType type() { return TYPE_INT; }
virtual int asInt() { return value_; }

private:
int value_;
};
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><strong>开放。</strong>
可在虚拟机的核心之外定义新的值类型，只要它们实现了基本接口就行。</p>
</li>
<li>
<p><strong>面向对象。</strong>
如果你坚持 OOP 原则，这是“正确”的做法，为特定类型使用多态分配行为，而不是在标签上做 switch 之类的。</p>
</li>
<li>
<p><strong>冗长。</strong>
必须定义单独的类，包含了每个数据类型的相关行为。
注意在前面的例子中，这样的类定义了<strong>所有</strong>的类型。在这里，只包含了一个！</p>
</li>
<li>
<p><strong>低效。</strong>
为了使用多态，必须使用指针，这意味着即使是短小的值，如布尔和数字，也得裹在堆中分配的对象里。
每使用一个值，你就得做一次虚方法调用。</p>
<p>在虚拟机核心之类的地方，像这样的性能影响会迅速叠加。
事实上，这引起了许多我们试图在解释器模式中避免的问题。
只是现在的问题不在<strong>代码</strong>中，而是在<strong>值</strong>中。</p>
</li>
</ul>
<p>我的建议是：如果可以，只用单一数据类型。
除此以外，使用带标识的 union。这是世界上几乎每个语言解释器的选择。</p>
<h3><a class="header" href="#如何生成字节码" id="如何生成字节码">如何生成字节码</a></h3>
<p>我将最重要的问题留到最后。我们已经完成了<strong>消耗</strong>和<strong>解释</strong>字节码的部分，
但需你要写<strong>制造</strong>字节码的工具。
典型的解决方案是写个编译器，但它不是唯一的选择。</p>
<ul>
<li>
<p><strong>如果你定义了基于文本的语言：</strong></p>
<ul>
<li>
<p><strong>必须定义语法。</strong>
业余和专业的语言设计师小看这件事情的难度。让解析器高兴很简单，让<strong>用户</strong>快乐很<strong>难</strong>。</p>
<p>语法设计是用户界面设计，当你将用户界面限制到字符构成的字符串，这可没把事情变简单。</p>
</li>
<li>
<p><strong>必须实现解析器。</strong>
不管名声如何，这部分其实非常简单。无论使用 ANTLR 或 Bison，还是——像我一样——手写递归下降，都可以完成。</p>
</li>
<li>
<p><strong>必须处理语法错误。</strong>
这是最重要和最困难的部分。
当用户制造了语法和语义错误——他们总会这么干——引导他们返回到正确的道路是你的任务。
解析器只知道接到了意外的符号，给予有用的的反馈并不容易。</p>
</li>
<li>
<p><strong>可能会对非技术用户关上大门。</strong>
我们程序员喜欢文本文件。结合强大的命令行工具，我们把它们当作计算机的乐高积木——简单，有百万种方式组合。</p>
<p>大部分非程序员不这样想。
对他们来说，输入文本文件就像为愤怒机器人审核员填写税表，如果忘记了一个分号就会遭到痛斥。</p>
</li>
</ul>
</li>
<li>
<p><strong>如果你定义了一个图形化创作工具：</strong></p>
<ul>
<li>
<p><strong>必须实现用户界面。</strong>
按钮，点击，拖动，诸如此类。
有些人畏惧它，但我喜欢它。
如果沿着这条路走下去，设计用户界面和工作核心部分同等重要——而不是硬着头皮完成的乱七八糟工作。</p>
<p>每点额外工作都会让工具更容易更舒适地使用，并直接导致了游戏中更好的内容。
如果你看看很多游戏制作过程的内部解密，经常会发现制作有趣的创造工具是秘诀之一。</p>
</li>
<li>
<p><strong>有较少的错误情况。</strong>
由于用户通过交互式一步一步地设计行为，应用程序可以尽快引导他们走出错误。</p>
<p>而使用基于文本的语言时，直到用户输完整个文件<strong>才能</strong>看到用户的内容，预防和处理错误更加困难。</p>
</li>
<li>
<p><strong>更难移植。</strong>
文本编译器的好处是，文本文件是通用的。编译器简单地读入文件并写出。跨平台移植的工作实在微不足道。</p>
</li>
</ul>
<blockquote>
<p>除了换行符。还有编码。</p>
</blockquote>
<p>当你构建用户界面，你必须选择要使用的架构，其中很多是基于某个操作系统。
也有跨平台的用户界面工具包，但他们往往要为对所有平台同样适用付出代价——它们在不同的平台上同样差异很大。</p>
</li>
</ul>
<h2><a class="header" href="#参见-5" id="参见-5">参见</a></h2>
<ul>
<li>
<p>这一章节的近亲是 GoF 的<a href="http://en.wikipedia.org/wiki/Interpreter_pattern">解释器模式</a>。两种方式都能让你用数据组合行为。</p>
<p>事实上，最终你两种模式<strong>都</strong>会使用。你用来构造字节码的工具会有内部的对象树。这也是解释器模式所能做的。</p>
<p>为了编译到字节码，你需要递归回溯整棵树，就像用解释器模式去解释它一样。
<strong>唯一的</strong> 不同在于，不是立即执行一段行为，而是生成整个字节码再执行。</p>
</li>
<li>
<p><a href="http://www.lua.org/">Lua</a>是游戏中最广泛应用的脚本语言。
它的内部被实现为一个非常紧凑的，基于寄存器的字节码虚拟机。</p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/UnrealEd#Kismet">Kismet</a>是个可视化脚本编辑工具，应用于 Unreal 引擎的编辑器 UnrealEd。</p>
</li>
<li>
<p>我的脚本语言<a href="https://github.com/munificent/wren">Wren</a>，是一个简单的，基于栈的字节码解释器。</p>
</li>
</ul>
<h1><a class="header" href="#子类沙箱" id="子类沙箱">子类沙箱</a></h1>
<h2><a class="header" href="#意图-4" id="意图-4">意图</a></h2>
<p><em>用一系列由基类提供的操作定义子类中的行为。</em></p>
<h2><a class="header" href="#动机-4" id="动机-4">动机</a></h2>
<p>每个孩子都梦想过变成超级英雄，但是不幸的是，高能射线在地球上很短缺。
游戏是让你扮演超级英雄最简单的方法。
因为我们的游戏设计者从来没有学会说“不”，<strong>我们的</strong>超级英雄游戏中有成百上千种不同的超级能力可供选择。</p>
<p>我们的计划是创建一个<code>Superpower</code>基类。然后由它派生出各种超级能力的实现类。
我们在程序员队伍中分发设计文档，然后开始编程。
当我们完成时，我们就会有上百种超级能力类。</p>
<blockquote>
<p>当你发现像这个例子一样有<strong>很多</strong>子类时，那通常意味着数据驱动的方式更好。
不再用<strong>代码</strong>定义不同的能力，用<strong>数据</strong>吧。</p>
</blockquote>
<p>像<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>，<a href="05-1%E5%AD%97%E8%8A%82%E7%A0%81.html">字节码</a>，和<a href="http://en.wikipedia.org/wiki/Interpreter_pattern">解释器</a>模式都能帮忙。</p>
<p>我们想让玩家处于拥有无限可能的世界中。无论他们在孩童时想象过什么能力，我们都要在游戏中展现。
这就意味着这些超能力子类需要做任何事情：
播放声音，产生视觉刺激，与 AI 交互，创建和销毁其他游戏实体，与物理打交道。没有哪处代码是它们不会接触的。</p>
<p>假设我们让团队信马由缰地写超能力类。会发生什么？</p>
<ul>
<li>
<p><em>会有很多冗余代码。</em>
当超能力种类繁多，我们可以预期有很多重叠。
很多超能力都会用相同的方式产生视觉效果并播放声音。
当你坐下来看看，冷冻光线，热能光线，芥末酱光线都很相似。
如果人们实现这些的时候没有协同，那就会有很多冗余的代码和重复劳动。</p>
</li>
<li>
<p><em>游戏引擎中的每一部分都会与这些类耦合。</em>
没有深入了解的话，任何人都能写出直接调用子系统的代码，但子系统从来没打算直接与超能力类绑定。
就算渲染系统被好好组织成多个层次，只有一个能被外部的图形引擎使用，
我们可以打赌，最终超能力代码会与每一个接触。</p>
</li>
<li>
<p><em>当外部代码需要改变时，一些随机超能力代码有很大几率会损坏。</em>
一旦我们有了不同的超能力类绑定到游戏引擎的多个部分，改变那些部分必然影响超能力类。
这可不合理，因为图形，音频，UI 程序员很可能不想<strong>也</strong>成为玩法程序员。</p>
</li>
<li>
<p><em>很难定义所有超能力遵守的不变量。</em>
假设我们想保证超能力播放的所有音频都有正确的顺序和优先级。
如果我们的几百个类都直接调用音频引擎，就没什么好办法来完成这点。</p>
</li>
</ul>
<p>我们要的是给每个实现超能力的玩法程序员一系列可使用的基本单元。
你想要播放声音？这是你的<code>playSound()</code>函数。
你想要粒子效果？这是你的<code>spawnParticles()</code>函数。
我们保证了这些操作覆盖了你要做的事情，所以你不需要<code>#include</code>随机的头文件，干扰到代码库的其他部分。</p>
<p>我们实现的方法是通过定义这些操作为<code>Superpower</code><strong>基类</strong>的<strong>protected 方法</strong>。
将它们放在基类给了每个子类直接便捷的途径获取方法。
让它们成为 protected（很可能不是虚方法）方法暗示了它们存在就是为了被子类<strong>调用</strong>。</p>
<p>一旦有了这些东西来使用，我们需要一个地方使用他们。
为了做到这点，我们定义<strong>沙箱方法</strong>，这是子类必须实现的抽象的 protected 方法。
有了这些，要实现一种新的能力，你需要：</p>
<ol>
<li>创建从<code>Superpower</code>继承的新类。</li>
<li>重载沙箱方法<code>activate()</code>。</li>
<li>通过调用<code>Superpower</code>提供的 protected 方法实现主体。</li>
</ol>
<p>我们现在可以使用这些高层次的操作来解决冗余代码问题了。
当我们看到代码在多个子类间重复，我们总可以将其打包到<code>Superpower</code>中，作为它们都可以使用的新操作。</p>
<p>我们通过将耦合约束到一个地方解决了耦合问题。
<code>Superpower</code>最终与不同的系统耦合，但是继承它的几百个类不会。
相反，它们<strong>只</strong>耦合基类。
当游戏系统的某部分改变时，修改<code>Superpower</code>也许是必须的，但是众多的子类不需要修改。</p>
<p>这个模式带来浅层但是广泛的类层次。
你的继承链不<strong>深</strong>，但是有<strong>很多</strong>类与<code>Superpower</code>挂钩。
通过使用有很多直接子类的基类，我们在代码库中创造了一个支撑点。
我们投入到<code>Superpower</code>的时间和爱可以让游戏中众多类获益。</p>
<blockquote>
<p>最近，你会发现很多人批评面向对象语言中的继承。
继承<strong>是</strong>有问题——在代码库中没有比父类子类之间的耦合更深的了——但我发现<strong>扁平的</strong>继承树比起<strong>深的</strong>继承树更好处理。</p>
</blockquote>
<h2><a class="header" href="#模式-7" id="模式-7">模式</a></h2>
<p><strong>基类</strong>定义抽象的<strong>沙箱方法</strong>和几个<strong>提供的操作</strong>。
将操作标为 protected，表明它们只为子类所使用。
每个推导出的<strong>沙箱子类</strong>用提供的操作实现了沙箱函数。</p>
<h2><a class="header" href="#何时使用-4" id="何时使用-4">何时使用</a></h2>
<p>子类沙箱模式是潜伏在代码库中简单常用的模式，哪怕是在游戏之外的地方亦有应用。
如果你有一个非虚的 protected 方法，你可能已经在用类似的东西了。
沙箱方法在以下情况适用：</p>
<ul>
<li>
<p>你有一个能推导很多子类的基类。</p>
</li>
<li>
<p>基类可以提供子类需要的所有操作。</p>
</li>
<li>
<p>在子类中有行为重复，你想要更容易地在它们间分享代码。</p>
</li>
<li>
<p>你想要最小化子类和程序的其他部分的耦合。</p>
</li>
</ul>
<h2><a class="header" href="#记住-4" id="记住-4">记住</a></h2>
<p>“继承”近来在很多编程圈子为人诟病，原因之一是基类趋向于增加越来越多的代码
这个模式特别容易染上这个毛病。</p>
<p>由于子类通过基类接触游戏的剩余部分，基类最后和子类需要的<strong>每个</strong>系统耦合。
当然，子类也紧密地与基类相绑定。这种蛛网耦合让你很难在不破坏什么的情况下改变基类——你得到了<a href="http://en.wikipedia.org/wiki/Fragile_base_class">脆弱的基类问题（brittle base class problem）</a>。</p>
<p>硬币的另一面是由于你耦合的大部分都被推到了基类，子类现在与世界的其他部分分离。
理想的情况下，你大多数的行为都在子类中。这意味着你的代码库大部分是孤立的，很容易管理。</p>
<p>如果你发现这个模式正把你的基类变成一锅代码糊糊，
考虑将它提供的一些操作放入分离的类中，
这样基类可以分散它的责任。<a href="06-1%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html">组件模式</a>可以在这里帮上忙。</p>
<h2><a class="header" href="#示例代码-4" id="示例代码-4">示例代码</a></h2>
<p>因为这个模式太简单了，示例代码中没有太多东西。
这不是说它没用——这个模式关键在于“意图”，而不是它实现的复杂度。</p>
<p>我们从<code>Superpower</code>基类开始：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Superpower
{
public:
  virtual ~Superpower() {}

protected:
  virtual void activate() = 0;

  void move(double x, double y, double z)
  {
    // 实现代码……
  }

  void playSound(SoundId sound, double volume)
  {
    // 实现代码……
  }

  void spawnParticles(ParticleType type, int count)
  {
    // 实现代码……
  }
};
<span class="boring">}
</span></code></pre></pre>
<p><code>activate()</code>方法是沙箱方法。由于它是抽象虚函数，子类<strong>必须</strong>重载它。
这让那些需要创建子类的人知道要做哪些工作。</p>
<p>其他的 protected 函数<code>move()</code>，<code>playSound()</code>，和<code>spawnParticles()</code>都是提供的操作。
它们是子类在实现<code>activate()</code>时要调用的。</p>
<p>在这个例子中，我们没有实现提供的操作，但真正的游戏在那里有真正的代码。
那些代码中，<code>Superpower</code>与游戏中其他部分的耦合——<code>move()</code>也许调用物理代码，<code>playSound()</code>会与音频引擎交互，等等。
由于这都在基类的<strong>实现</strong>中，保证了耦合封闭在<code>Superpower</code>中。</p>
<p>好了，拿出我们的放射蜘蛛，创建个能力。像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class SkyLaunch : public Superpower
{
protected:
  virtual void activate()
  {
    // 空中滑行
    playSound(SOUND_SPROING, 1.0f);
    spawnParticles(PARTICLE_DUST, 10);
    move(0, 0, 20);
  }
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>好吧，也许<strong>跳跃</strong>不是<strong>超级能力</strong>，但我在这里讲的是基础知识。</p>
</blockquote>
<p>这种能力将超级英雄射向天空，播放合适的声音，扬起尘土。
如果所有的超能力都这样简单——只是声音，粒子效果，动作的组合——那么就根本不需要这个模式了。
相反，<code>Superpower</code>有内置的<code>activate()</code>能获取声音 ID，粒子类型和运动的字段。
但是这只在所有能力运行方式相同，只在数据上不同时才可行。让我们精细一些：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Superpower
{
protected:
  double getHeroX()
  {
    // 实现代码……
  }

  double getHeroY()
  {
    // 实现代码……
  }

  double getHeroZ()
  {
    // 实现代码……
  }

  // 退出之类的……
};
<span class="boring">}
</span></code></pre></pre>
<p>这里我们增加了些方法获取英雄的位置。我们的<code>SkyLaunch</code>现在可以使用它们了：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class SkyLaunch : public Superpower
{
protected:
  virtual void activate()
  {
    if (getHeroZ() == 0)
    {
      // 在地面上，冲向空中
      playSound(SOUND_SPROING, 1.0f);
      spawnParticles(PARTICLE_DUST, 10);
      move(0, 0, 20);
    }
    else if (getHeroZ() &lt; 10.0f)
    {
      // 接近地面，再跳一次
      playSound(SOUND_SWOOP, 1.0f);
      move(0, 0, getHeroZ() + 20);
    }
    else
    {
      // 正在空中，跳劈攻击
      playSound(SOUND_DIVE, 0.7f);
      spawnParticles(PARTICLE_SPARKLES, 1);
      move(0, 0, -getHeroZ());
    }
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>由于我们现在可以访问状态，沙箱方法可以做有用有趣的控制流了。
这还需要几个简单的<code>if</code>声明，
但你可以做任何你想做的东西。
使用包含任意代码的成熟沙箱方法，天高任鸟飞了。</p>
<blockquote>
<p>早先，我建议以数据驱动的方式建立超能力。
这里是你可能<strong>不</strong>想那么做的原因之一。
如果你的行为复杂而使用命令式风格，它更难在数据中定义。</p>
</blockquote>
<h2><a class="header" href="#设计决策-4" id="设计决策-4">设计决策</a></h2>
<p>如你所见，子类沙箱是一个“软”模式。它表述了一个基本思路，但是没有很多细节机制。
这意味着每次使用都面临着一些有趣的选择。这里是一些需要思考的问题。</p>
<h3><a class="header" href="#应该提供什么操作" id="应该提供什么操作">应该提供什么操作</a></h3>
<p>这是最大的问题。这深深影响了模式感觉上和实际上有多好。
在一个极端，基类几乎不提供<strong>任何</strong>操作。只有一个沙箱方法。
为了实现功能，总是需要调用基类外部的系统。如果你这样做，很难说你在使用这个模式。</p>
<p>另一个极端，基类提供了<strong>所有</strong>子类也许需要的操作。
子类<strong>只</strong>与基类耦合，不调用任何外部系统的东西。</p>
<blockquote>
<p>具体来说，这意味着每个子类的源文件只需要<code>#include</code>它的基类头文件。</p>
</blockquote>
<p>在这两个极端之间，操作由基类提供还是向外部直接调用有很大的操作余地。
你提供的操作越多，外部系统与子类耦合越少，但是与基类耦合<strong>越多</strong>。
从子类中移除了耦合是通过将耦合推给基类完成的。</p>
<p>如果你有一堆与外部系统耦合的子类的话，这很好。
通过将耦合移到提供的操作中，你将其移动到了一个地方：基类。但是你越这么做，基类就越大越难管理。</p>
<p>所以分界线在哪里？这里是一些首要原则：</p>
<ul>
<li>
<p>如果提供的操作只被一个或几个子类使用，将操作加入基类获益不会太多。
你向基类添加了会影响所有事物的复杂性，但是只有少数几个类受益。</p>
<p>让该操作与其他提供的操作保持一致或许有价值，但让使用操作的子类直接调用外部系统也许更简单明了。</p>
</li>
<li>
<p>当你调用游戏中其他地方的方法，如果方法没有修改状态就有更少的干扰。
它仍然制造耦合，但是这是“安全的”耦合，因为它没有破坏游戏中的任何东西。</p>
<blockquote>
<p>“安全的”在这里打了引号是因为严格来说，接触数据也能造成问题。
如果你的游戏是多线程的，读取的数据可能正在被修改。如果你不小心，就会读入错误的数据。</p>
<p>另一个不愉快的情况是，如果你的游戏状态是严格确定性的（很多在线游戏为了保持玩家同步都是这样的）。
接触了游戏同步状态之外的东西会造成极糟的不确定性漏洞。</p>
</blockquote>
</li>
</ul>
<p>另一方面，修改状态的调用会和代码库的其他方面紧密绑定，你需要三思。打包他们成基类提供的操作是个好的候选项。</p>
<ul>
<li>
<p>如果操作只是增加了向外部系统的转发调用，那它就没增加太多价值。那种情况下，也许直接调用外部系统的方法更简单。</p>
<p>但是，简单的转发也是有用的——那些方法接触了基类不想直接暴露给子类的状态。
举个例子，假设<code>Superpower</code>提供这个：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void playSound(SoundId sound, double volume)
{
soundEngine_.play(sound, volume);
}
<span class="boring">}
</span></code></pre></pre>
<p>它只是转发调用给<code>Superpower</code>中<code>soundEngine_</code>字段。
但是，好处是将字段封装在<code>Superpower</code>中，避免子类接触。</p>
</li>
</ul>
<h3><a class="header" href="#方法应该直接提供还是包在对象中提供" id="方法应该直接提供还是包在对象中提供">方法应该直接提供，还是包在对象中提供</a></h3>
<p>这个模式的挑战是基类中最终加入了很多方法。
你可以将一些方法移到其他类中来缓和。基类通过返回对象提供方法。</p>
<p>举个例子，为了让超能力播放声音，我们可以直接将它们加到<code>Superpower</code>中：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Superpower
{
protected:
  void playSound(SoundId sound, double volume)
  {
    // 实现代码……
  }

  void stopSound(SoundId sound)
  {
    // 实现代码……
  }

  void setVolume(SoundId sound)
  {
    // 实现代码……
  }

  // 沙盒方法和其他操作……
};
<span class="boring">}
</span></code></pre></pre>
<p>但是如果<code>Superpower</code>已经很庞杂了，我们也许想要避免这样。
取而代之的是创建<code>SoundPlayer</code>类暴露该函数：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class SoundPlayer
{
  void playSound(SoundId sound, double volume)
  {
    // 实现代码……
  }

  void stopSound(SoundId sound)
  {
    // 实现代码……
  }

  void setVolume(SoundId sound)
  {
    // 实现代码……
  }
};
<span class="boring">}
</span></code></pre></pre>
<p><code>Superpower</code>提供了对其的接触：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Superpower
{
protected:
  SoundPlayer&amp; getSoundPlayer()
  {
    return soundPlayer_;
  }

  // 沙箱方法和其他操作……

private:
  SoundPlayer soundPlayer_;
};
<span class="boring">}
</span></code></pre></pre>
<p>将提供的操作分流到辅助类可以为你做一些事情：</p>
<ul>
<li>
<p><em>减少了基类中的方法。</em>
在这里的例子中，将三个方法变成了一个简单的获取函数。</p>
</li>
<li>
<p><em>在辅助类中的代码通常更好管理。</em>
像<code>Superpower</code>的核心基类，不管意图如何好，它被太多的类依赖而很难改变。
通过将函数移到耦合较少的次要类，代码变得更容易被使用而不破坏任何东西。</p>
</li>
<li>
<p><em>减少了基类和其他系统的耦合度。</em>
当<code>playSound()</code>方法直接在<code>Superpower</code>时，基类与<code>SoundId</code>以及其他涉及的音频代码直接绑定。
将它移动到<code>SoundPlayer</code>中，减少了<code>Superpower</code>与<code>SoundPlayer</code>类的耦合，这就封装了它其他的依赖。</p>
</li>
</ul>
<h3><a class="header" href="#基类如何获得它需要的状态" id="基类如何获得它需要的状态">基类如何获得它需要的状态</a></h3>
<p>你的基类经常需要将对子类隐藏的数据封装起来。
在第一个例子中，<code>Superpower</code>类提供了<code>spawnParticles()</code>方法。
如果方法的实现需要一些粒子系统对象，怎么获得呢？</p>
<ul>
<li>
<p><strong>将它传给基类构造器：</strong></p>
<p>最简单的解决方案是让基类将其作为构造器变量：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>  class Superpower
{
public:
  Superpower(ParticleSystem** particles)
  : particles_(particles)
  {}

  // 沙箱方法和其他操作……

private:
  ParticleSystem** particles_;
};
<span class="boring">}
</span></code></pre></pre>
<p>这安全地保证了每个超能力在构造时能得到粒子系统。但让我们看看子类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class SkyLaunch : public Superpower
{
public:
  SkyLaunch(ParticleSystem** particles)
  : Superpower(particles)
  {}
};
<span class="boring">}
</span></code></pre></pre>
<p>我们在这儿看到了问题。每个子类都需要构造器调用基类构造器并传递变量。这让子类接触了我们不想要它知道的状态。</p>
<p>这也造成了维护的负担。如果我们后续向基类添加了状态，每个子类都需要修改并传递这个状态。</p>
</li>
<li>
<p><strong>使用两阶初始化：</strong></p>
<p>为了避免通过构造器传递所有东西，我们可以将初始化划分为两个部分。
构造器不接受任何参数，只是创建对象。然后，我们调用定义在基类的分离方法传入必要的数据：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Superpower** power = new SkyLaunch();
power-&gt;init(particles);
<span class="boring">}
</span></code></pre></pre>
<p>注意我们没有为<code>SkyLaunch</code>的构造器传入任何东西，它与<code>Superpower</code>中想要保持私有的任何东西都不耦合。
这种方法的问题在于，你要保证永远记得调用<code>init()</code>，如果忘了，你会获得处于半完成的，无法运行的超能力。</p>
<p>你可以将整个过程封装到一个函数中来修复这一点，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Superpower** createSkyLaunch(ParticleSystem** particles)
{
  Superpower** power = new SkyLaunch();
  power-&gt;init(particles);
  return power;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>使用一点像私有构造器和友类的技巧，你可以保证<code>createSkylaunch()</code>函数是唯一能够创建能力的函数。这样，你不会忘记任何初始化步骤。</p>
</blockquote>
</li>
<li>
<p><strong>让状态静态化：</strong></p>
<p>在先前的例子中，我们用粒子系统初始化每一个<code>Superpower</code><em>实例</em>。
在每个能力都需要自己独特的状态时这是有意义的。但是如果粒子系统是<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例</a>，那么每个能力都会分享相同的状态。</p>
<p>如果是这样，我们可以让状态是基类私有而<strong>静态</strong>的。
游戏仍然要保证初始化状态，但是它只需要为整个游戏初始化<code>Superpower</code><strong>类</strong>一遍，而不是为每个实例初始化一遍。</p>
<blockquote>
<p>记住单例仍然有很多问题。你在很多对象中分享了状态（所有的<code>Superpower</code>实例）。
粒子系统被封装了，因此它不是全局<strong>可见的</strong>，这很好，但它们都访问同一对象，这让分析更加困难了。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Superpower
{
public:
  static void init(ParticleSystem** particles)
  {
    particles_ = particles;
  }

  // 沙箱方法和其他操作……

private:
  static ParticleSystem** particles_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意这里的<code>init()</code>和<code>particles_</code>都是静态的。
只要游戏早先调用过一次<code>Superpower::init()</code>，每种能力都能接触粒子系统。
同时，可以调用正确的推导类构造器来自由创建<code>Superpower</code>实例。</p>
<p>更棒的是，现在<code>particles_</code>是<strong>静态</strong>变量，
我们不需要在每个<code>Superpower</code>中存储它，这样我们的类占据的内存更少了。</p>
</li>
<li>
<p><strong>使用服务定位器：</strong></p>
<p>前一选项中，外部代码要在基类请求前压入基类需要的全部状态。
初始化的责任交给了周围的代码。另一选项是让基类拉取它需要的状态。
而做到这点的一种实现方法是使用<a href="06-3%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8.html">服务定位器</a>模式：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>  class Superpower
{
protected:
  void spawnParticles(ParticleType type, int count)
  {
    ParticleSystem&amp; particles = Locator::getParticles();
    particles.spawn(type, count);
  }

  // 沙箱方法和其他操作……
};
<span class="boring">}
</span></code></pre></pre>
<p>这儿，<code>spawnParticles()</code>需要粒子系统，不是外部系统<strong>给</strong>它，而是它自己从服务定位器中拿了一个。</p>
</li>
</ul>
<h2><a class="header" href="#参见-6" id="参见-6">参见</a></h2>
<ul>
<li>
<p>当你使用<a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a>时，你的更新函数通常也是沙箱方法。</p>
</li>
<li>
<p>这个模式与<a href="http://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a>正相反。
两种模式中，都使用一系列受限操作实现方法。
使用子类沙箱时，方法在推导类中，受限操作在基类中。
使用模板方法时，<em>基类</em> 有方法，而受限操作在<strong>推导</strong>类中。</p>
</li>
<li>
<p>你也可以认为这个模式是<a href="http://en.wikipedia.org/wiki/Facade_Pattern">外观模式</a>的变形。
外观模式将一系列不同系统藏在简化的 API 后。使用子类沙箱，基类起到了在子类前隐藏整个游戏引擎的作用。</p>
</li>
</ul>
<h1><a class="header" href="#类型对象" id="类型对象">类型对象</a></h1>
<h1><a class="header" href="#组件模式" id="组件模式">组件模式</a></h1>
<h1><a class="header" href="#服务定位器" id="服务定位器">服务定位器</a></h1>
<h1><a class="header" href="#数据局部性" id="数据局部性">数据局部性</a></h1>
<h2><a class="header" href="#连续数组" id="连续数组">连续数组</a></h2>
<h1><a class="header" href="#脏标识模式" id="脏标识模式">脏标识模式</a></h1>
<h1><a class="header" href="#对象池模式" id="对象池模式">对象池模式</a></h1>
<h1><a class="header" href="#空间分区" id="空间分区">空间分区</a></h1>
<h1><a class="header" href="#附录一" id="附录一">附录一</a></h1>
<p>正则</p>
<pre><code class="language-reg">(\*+?)(?!\*)
</code></pre>

				</main>

				<nav class="nav-wrapper" aria-label="Page navigation">
					<!-- Mobile navigation buttons -->
					

					

					<div style="clear: both"></div>
				</nav>
			</div>
		</div>

		<nav class="nav-wide-wrapper" aria-label="Page navigation">
			

			
		</nav>

	</div>

	

	

	

	
	<script type="text/javascript">
		window.playpen_copyable = true;
	</script>
	

	

	
	<script defer src="https://cdn.staticfile.org/clipboard.js/2.0.4/clipboard.min.js"></script>
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/languages/basic.min.js"></script>
	<script defer src="https://cdn.staticfile.org/lazysizes/5.2.0/lazysizes.min.js"></script>
	<script defer src="https://cdn.staticfile.org/mermaid/8.4.6/mermaid.min.js"></script>
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/src/theme/book.js"></script>
	<!-- Custom JS scripts -->
	
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@c9b85a6/plugin/init.js"></script>
	
	
	
	
	<script type="text/javascript">
		window.addEventListener('load', function () {
			window.setTimeout(window.print, 100);
		});
	</script>
	
	

</body>

</html>
