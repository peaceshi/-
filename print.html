<!DOCTYPE HTML>
<html lang="cmn-Hans" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>游戏编程模式</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="游戏编程模式">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/theme.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="00致谢.html">致谢</a></li><li class="expanded affix "><a href="01序.html">作者序</a></li><li class="expanded affix "><a href="01-1序2.html">序</a></li><li class="expanded affix "><a href="02架构，性能和游戏.html">架构，性能和游戏</a></li><li class="expanded "><a href="03重返设计模式.html"><strong aria-hidden="true">1.</strong> 重返设计模式</a></li><li><ol class="section"><li class="expanded "><a href="03-1命令模式.html"><strong aria-hidden="true">1.1.</strong> 命令模式</a></li><li class="expanded "><a href="03-2享元模式.html"><strong aria-hidden="true">1.2.</strong> 享元模式</a></li><li class="expanded "><a href="03-3观察者模式.html"><strong aria-hidden="true">1.3.</strong> 观察者模式</a></li><li class="expanded "><a href="03-4原型模式.html"><strong aria-hidden="true">1.4.</strong> 原型模式</a></li><li class="expanded "><a href="03-5单例模式.html"><strong aria-hidden="true">1.5.</strong> 单例模式</a></li><li class="expanded "><a href="03-6状态模式.html"><strong aria-hidden="true">1.6.</strong> 状态模式</a></li></ol></li><li class="expanded "><a href="04序列模式.html"><strong aria-hidden="true">2.</strong> 序列模式</a></li><li><ol class="section"><li class="expanded "><a href="04-1双缓冲模式.html"><strong aria-hidden="true">2.1.</strong> 双缓冲模式</a></li><li class="expanded "><a href="04-2游戏循环.html"><strong aria-hidden="true">2.2.</strong> 游戏循环</a></li><li class="expanded "><a href="04-3更新方法.html"><strong aria-hidden="true">2.3.</strong> 更新方法</a></li></ol></li><li class="expanded "><a href="05行为模式.html"><strong aria-hidden="true">3.</strong> 行为模式</a></li><li><ol class="section"><li class="expanded "><a href="05-1字节码.html"><strong aria-hidden="true">3.1.</strong> 字节码</a></li><li class="expanded "><a href="05-2子类沙箱.html"><strong aria-hidden="true">3.2.</strong> 子类沙箱</a></li><li class="expanded "><a href="05-3类型对象.html"><strong aria-hidden="true">3.3.</strong> 类型对象</a></li></ol></li><li class="expanded "><a href="06解耦模式.html"><strong aria-hidden="true">4.</strong> 解耦模式</a></li><li><ol class="section"><li class="expanded "><a href="06-1组件模式.html"><strong aria-hidden="true">4.1.</strong> 组件模式</a></li><li class="expanded "><a href="06-2事件队列.html"><strong aria-hidden="true">4.2.</strong> 事件队列</a></li><li class="expanded "><a href="06-3服务定位器.html"><strong aria-hidden="true">4.3.</strong> 服务定位器</a></li></ol></li><li class="expanded "><a href="07优化模式.html"><strong aria-hidden="true">5.</strong> 优化模式</a></li><li><ol class="section"><li class="expanded "><a href="07-1数据局部性.html"><strong aria-hidden="true">5.1.</strong> 数据局部性</a></li><li class="expanded "><a href="07-2脏标识模式.html"><strong aria-hidden="true">5.2.</strong> 脏标识模式</a></li><li class="expanded "><a href="07-3对象池模式.html"><strong aria-hidden="true">5.3.</strong> 对象池模式</a></li><li class="expanded "><a href="07-3空间分区.html"><strong aria-hidden="true">5.4.</strong> 空间分区</a></li></ol></li><li class="expanded "><a href="附录一.html">附录一</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">游戏编程模式</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#致谢" id="致谢">致谢</a></h1>
<p>据说只有作家知道写作中会遇到什么，
但还有另外一群人知道内情——那些不幸与作家有亲密关系的人。
我的妻子 Megan 从岩石般致密的生活中，为我开凿出写作时间。
洗盘子，给孩子洗澡也许不是“写作”，
但没有她的这些付出，这本书永远没法写出来。</p>
<p>我在 EA 做程序员时开始写作这本书。
我认为公司不知道这回事，
我要感谢 Michael Malone, Olivier Nallet, 以及 Richard Wifall。
他们为书籍的前几章提供了详尽有益的建议。</p>
<p>写到一半时，我决定放弃传统的出版方式。
我知道，这意味着没有编辑的指导，但有成打的读者通过邮件告诉我书该怎么写；
这意味着没有校对，但有超过 250 个 bug 报告来帮我改进；
这意味着没有写作期限的鼓舞，但当我完成一章，读者会拍着我的背鼓励，我会有更强的动力。</p>
<blockquote>
<p>我没有失去文字编辑。Lauren Briese 在我需要的时候出现并杰出地完成了工作。</p>
</blockquote>
<p>人们称之为“自出版”，但是“众出版”更加接近事实。
写作是件孤独的事，但我从没感到孤单。
哪怕是我停止写作两年后，仍有人来鼓励我。
没有那些提醒我他们期待更多章节的人，我不会重拾工作并完成此书。</p>
<blockquote>
<p>特别感谢 Colm Sloan，完全出于内心的善意，他认真阅读了书中每个章节<em>两遍</em>，给了我众多超赞的反馈。我欠他一份人情，也许是两份。</p>
</blockquote>
<p>那些写过邮件或者发过评论的人，
那些点过赞或者收藏的人，
那些发过推特的人，那些与我交流的人，
那些向朋友宣传这本书的人，那些向我发送错误报告的人，
我要对你们说：我心中充满了对你的感激。
完成这本书是我人生中最大的目标之一，是你让我梦想成真。</p>
<p>谢谢！</p>
<h1><a class="header" href="#作者序" id="作者序">作者序</a></h1>
<p>在五年级时，我和我的朋友被准许使用一间存放有几台非常破旧的 TRS-80s 的房间。
为了鼓舞我们，一位老师给我们找了一些简单的 BASIC 程序打印文档。</p>
<p>电脑的磁带驱动器已经坏掉了，所以每当我们想要运行代码，就得小心地从头开始输入它们。
因此，我们更喜欢那些只有几行长的程序：</p>
<pre><code class="language-basic">    10 PRINT &quot;BOBBY IS RADICAL!!!&quot;
    20 GOTO 10
</code></pre>
<blockquote>
<p>如果电脑打印的次数足够多，也许这句话就会魔法成真。</p>
</blockquote>
<p>哪怕这样，过程也充满了困难。我们不知道如何编程，所以小小的语法错误对我们来说也是天险。
如果程序没有工作，我们就得从头再来一遍——这经常发生。</p>
<p>文档的最后几页是个真正的怪物：一个占据了几页篇幅的程序。
我们得花些时间才能鼓起勇气去试一试，但它实在太诱人——它的标题是“地道与巨魔”。
我们不知道它能做什么，但听起来像是个游戏，还有什么比自己编个电脑游戏更酷的吗？</p>
<p>我们从来没能让它运行起来，一年以后，我们离开了那间教室。
（很久以后，当我真的学会了点 BASIC，我意识到那只是个桌面游戏角色生成器，而不是游戏。）
但是命运的车轮已经开始转动——自那时起，我就想要成为一名游戏程序员。</p>
<p>青少年时，我家有了一台能运行 QuickBASIC 的 Macintosh，之后 THINK C 也能在其上运行。
几乎整个暑假我都在用它编游戏。
自学缓慢而痛苦。
我能轻松地编写并运行某些部分——地图或者小谜题——但随着程序代码量的增长，这越来越难。</p>
<blockquote>
<p>暑假中的不少时间我都花在在路易斯安那州南部的沼泽里逮蛇和乌龟上了。
如果外面不是那么酷热，很有可能这就会是一本讲爬虫而不是编程的书了。</p>
</blockquote>
<p>起初，挑战之处仅仅在于让程序成功运行。然后，是搞明白怎样写出内容超出我大脑容量的代码。
我不再只阅读关于“如何用 C++编程”的书籍，而开始尝试找那些讲如何<strong>组织</strong>程序的书。</p>
<p>几年过后，一位朋友给我一本书：《设计模式：可复用面向对象软件的基础》。
终于！这正是我从青年时期就在寻找的书。
我一口气从头读到尾。虽然我仍然挣扎于自己的程序中，但看到别人也在挣扎并提出了解决方案是一种解脱。
我意识到手无寸铁的我终于有件像样的<strong>工具</strong>了。</p>
<blockquote>
<p>那是我首次见到这位朋友，相互介绍五分钟后，我坐在他的沙发上，在接下来的几个小时中无视他并全神贯注地阅读。
我想自那以后我的社交技能还是有所提高的。</p>
</blockquote>
<p>在 2001 年，我获得了梦想中的工作：EA 的软件工程师。
我等不及要看看真正的游戏，还有专业人士是如何组织一切的。
像实况足球这样的大型游戏使用了什么样的架构？不同的系统是如何交互的？一套代码库是如何在多个平台上运行的？</p>
<p>分析理解源代码是种震颤的体验。图形，AI，动画，视觉效果皆有杰出代码。
有专家知道如何榨干 CPU 的最后一个循环并好好使用。
那些我都不知道是否<strong>可行</strong>的事情，这些人在午饭前就能完成。</p>
<p>但是这些杰出代码依赖的<strong>架构</strong>通常是事后设计。
他们太注重<strong>功能</strong>而忽视了架构。耦合充斥在模块间。
新功能被塞到任何能塞进去的地方。
在梦想幻灭的我看来，这和其他程序员没什么不同，
如果他们阅读过《设计模式》，最多也就用用<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例模式</a>。</p>
<p>当然，没那么糟。我曾幻想游戏程序员坐在白板包围的象牙塔里，为架构冷静地讨论上几周。
而实际情况是，我看到的代码是努力应对紧张截止期限的人赶工完成的。
他们已经竭尽全力，而且就像我慢慢意识到的那样，他们全力以赴的结果通常很好。
我花在游戏代码上的时间越多，我越能发现藏在表面下的天才之处。</p>
<p>不幸的是，“藏”是普遍现象。
宝石埋在代码中，但人们从未意识到它们的存在。
我看到同事重复寻找解决方案，而需要的示例代码就埋在他们所用的代码库中。</p>
<p>这个问题正是这本书要解决的。
我挖出了游戏代码库中能找到的设计模式，打磨然后在这里展示它们，这样可以节约时间用在发明新事物上，而非<strong>重新</strong>发明它们。</p>
<h2><a class="header" href="#书店里已有的书籍" id="书店里已有的书籍">书店里已有的书籍</a></h2>
<p>书店里已经有很多游戏编程书籍了。为什么要再写一本呢？</p>
<p>我看到的很多编程书籍可以归为这两类：</p>
<ul>
<li>
<p><strong>特定领域的书籍。</strong> 这些关于细分领域的书籍带你深入理解游戏开发的某一特定层面。
它们会教授你 3D 图形，实时渲染，物理模拟，人工智能，或者音频播放。
那些很多程序员穷其一生研究的细分领域。</p>
</li>
<li>
<p><strong>完整引擎的书籍。</strong> 另一个方向，还有书籍试图包含游戏引擎的各个部分。
它们倾向于构建特定种类游戏的完整引擎，通常是 3D FPS 游戏。</p>
</li>
</ul>
<p>这两种书我都喜欢，但我认为它们并未覆盖全部空间。
特定领域的书籍很少告诉你这些代码如何与游戏的其他部分打交道。
你擅长物理或者渲染，但是你知道怎么将两者优雅地组合吗？</p>
<p>第二类书包含这些，但是我发现完整引擎的书籍通常过于整体，过于专注某类游戏了。
特别是，随着手游和休闲游戏的兴起，我们正处于众多游戏类型欣欣向荣的时刻。
我们不再只是复制 Quake 了。如果<strong>你的</strong>游戏与该类游戏不同，那些介绍单一引擎的书就不那么有用了。</p>
<p>相反，我在这里做的更<strong>à la carte</strong> 。
每一章都是独立的、可应用到代码上的思路。
这样，你可以用<strong>你</strong>认为最好的方式组合这些思路，用到你的游戏上去。</p>
<blockquote>
<p>另一个广泛使用这种<strong>à la carte</strong>风格的例子是<a href="http://www.satori.org/game-programming-gems/"><em>Game Programming Gems</em></a>系列。</p>
</blockquote>
<h2><a class="header" href="#和设计模式的关联" id="和设计模式的关联">和设计模式的关联</a></h2>
<p>任何名字中有“模式”的编程书都与 Erich Gamma，Richard Helm，Ralph Johnson，和 John Vlissides（通常被称为 GoF）合著的经典书籍：
《设计模式：可复用面向对象软件要素》相关。</p>
<blockquote>
<p>《设计模式》也受到之前的书籍的启发。
创建一种模式语言来描述问题的开放式解法，
这思路来自 <a href="http://en.wikipedia.org/wiki/A_Pattern_Language"><em>A Pattern Language</em></a>，
作者是 Christopher Alexander (还有 Sarah Ishikawa 和 Murray Silverstein).</p>
<p>他们的书是关于架构的（建筑和墙那样的<strong>真正的</strong>框架结构），
但他们希望其他人能使用相同的方法描述其他领域的解决方案。
《设计模式》正是是 GoF 用这一方法在软件业做出的努力。</p>
</blockquote>
<p>称这本书为“游戏编程模式”，我不是暗示 GoF 的模式不适用于游戏编程。
相反：本书的<a href="03%E9%87%8D%E8%BF%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">重返设计模式</a>一节包含了《设计模式》中的很多模式，
但强调了这些模式在游戏编程中的特定使用。</p>
<p>同样地，我认为本书也适用于非游戏软件。
我可以依样画瓢称本书为《更多设计模式》，但是我认为举游戏编程为例子更为契合。
你真的想要另一本介绍员工记录和银行账户的书吗？</p>
<p>也就是说，虽然这里介绍的模式在其他软件上也很有用，但它们更合适于处理游戏中常见的工程挑战：</p>
<ul>
<li>
<p>时间和顺序通常是游戏架构的核心部分。事物必须在正确的时间按正确的顺序发生。</p>
</li>
<li>
<p>高度压缩的开发周期，大量程序员需要能快速构建和迭代一系列不同的行为，同时保证不烦扰他人，也不污染代码库。</p>
</li>
<li>
<p>在定义所有的行为后，游戏开始互动。怪物攻击英雄，药物相互混合，炸弹炸飞敌人或者友军。
实现这些互动不能把代码库搞成一团乱麻。</p>
</li>
<li>
<p>最后，游戏中性能很重要。
游戏开发者处于一场榨干平台性能的竞赛中。
节约 CPU 循环的技巧区分了 A 级百万销量游戏和掉帧差评游戏。</p>
</li>
</ul>
<h2><a class="header" href="#如何阅读这本书" id="如何阅读这本书">如何阅读这本书</a></h2>
<p>《游戏编程模式》分为三大块。
第一部分介绍并划分本书的框架。包含你现在阅读的这章和<a href="02%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%80%A7%E8%83%BD%E5%92%8C%E6%B8%B8%E6%88%8F.html">下一章</a>。</p>
<p>第二部分，<a href="03%E9%87%8D%E8%BF%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">重返设计模式</a>，复习了 GoF 书籍里的很多模式。
在每一章中，我给出我对这个模式的看法，以及我认为它和游戏编程有什么关系。</p>
<p>最后一部分是这本书最肥美的部分。
它展示了十三种我发现有用的模式。它们被分为四类：</p>
<p><a href="04%E5%BA%8F%E5%88%97%E6%A8%A1%E5%BC%8F.html">序列模式</a>, <a href="05%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F.html">行为模式</a>, <a href="06%E8%A7%A3%E8%80%A6%E6%A8%A1%E5%BC%8F.html">解耦模式</a>,和<a href="07%E4%BC%98%E5%8C%96%E6%A8%A1%E5%BC%8F.html">优化模式</a>。</p>
<p>每种模式都使用固定的格式表述，这样你可以将这本书当成引用，快速找到你需要的：</p>
<ul>
<li>
<p><strong>意图</strong> 部分提供这个模式想要解决什么问题的简短介绍。<br />
将它放在首位，这样你可以快速翻阅，找到你现在需要的模式。</p>
</li>
<li>
<p><strong>动机</strong> 部分描述了模式处理的问题示例。<br />
不同于具体的算法，模式通常不针对某个特定问题。
不用示例教授模式，就像不用面团教授烘烤。动机部分提供了面团，而下部分会教你烘烤。</p>
</li>
<li>
<p><strong>模式</strong> 部分将模式从示例中剥离出来。<br />
如果你想要一段对模式的教科书式简短介绍，那就是这部分了。
如果你已经熟悉了这种模式，想要确保你没有拉下什么，这部分也是很好的提示。</p>
</li>
</ul>
<p>到目前为止，模式只是用一两个示例解释。但是如何知道模式对<strong>你的</strong>问题有没有用呢？</p>
<ul>
<li>
<p><strong>何时使用</strong> 部分提供了这个模式在何时使用何时不用的指导。<br />
<strong>记住</strong> 部分指出了使用模式的结果和风险。</p>
</li>
<li>
<p>如果你像我一样需要具体的例子来真正地<strong>理解</strong>某物，那么<strong>示例代码</strong>部分能让你称心如意。<br />
它描述模式的一步步具体实现，来展现模式是如何工作的。</p>
</li>
<li>
<p>模式与算法不同的是它们是开放的。每次你使用模式，可以用不同的方式实现。<br />
下一部分<strong>设计决策</strong>，讨论这些方式，告诉你应用模式时可供考虑的不同选项。</p>
</li>
<li>
<p>作为结尾，这里有<strong>参见</strong>部分展示了这一模式与其他模式的关联，以及那些使用它的真实代码。</p>
</li>
</ul>
<h2><a class="header" href="#关于示例代码" id="关于示例代码">关于示例代码</a></h2>
<p>这本书的示例代码使用 C++ 写就，但这并不意味着这些模式只在 C++ 中有用，或 C++ 比其他语言更适合使用这些模式。
这些模式适用于几乎每种编程语言，虽然有的模式假设编程语言有对象和类。</p>
<p>我选择 C++ 有几个原因。首先，这是在游戏制作中最流行的语言，是业界的<strong>通用语</strong>。
通常，C++ 基于的 C 语法也是 Java，C#，JavaScript 和其他很多语言的基础。
哪怕你不懂 C++ ，你也只需一点点努力就能理解这里的示例代码。</p>
<p>这本书的目标<strong>不是</strong>教会你 C++ 。
示例代码尽可能地简单，不一定符合好的 C++ 风格或规范。
示例代码展示的是意图，而不是代码。</p>
<p>特别地，代码没用“现代的”——C++11 或者更新的——标准。
没有使用标准库，很少使用模板。
它们是“糟糕” C++ 代码，但我希望保持这样，这样那些使用 C，Objective-C，Java 和其他语言的人更容易理解它们。</p>
<p>为了避免花费时间在你已经看过或者是与模式无关的代码上，示例中省略了部分代码。
如果是那样，示例代码中的省略号表明这里隐藏了一些代码。</p>
<p>假设有个函数，做了些工作然后返回值。
而用它作示例的模式只关心返回的值，而不是完成了什么工作。那样的话，示例代码长得像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>bool update()
{
  // 做点工作……
  return isDone();
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#接下来呢" id="接下来呢">接下来呢</a></h2>
<p>设计模式在软件开发过程中不断地改变和扩展。
这本书继续了 GoF 记录分享设计模式的旅程，而这旅程也不会终于本书。</p>
<p>你是这段旅程的关键部分。改良（或者否决）了这本书中的模式，你就是为软件开发社区做贡献。
如果你有任何建议，更正，或者任何反馈，保持联络！</p>
<h1><a class="header" href="#序" id="序">序</a></h1>
<p>这个项目是在<a href="https://github.com/tkchu/Game-Programming-Patterns-CN">《游戏编程模式》中文版</a>基础上修改的.</p>
<p>先重新排版.之后根据原文进行补充.</p>
<h1><a class="header" href="#架构性能和游戏" id="架构性能和游戏">架构，性能和游戏</a></h1>
<p>在一头扎进一堆设计模式之前，我想先讲一些我对软件架构及如何将其应用到游戏之中的理解，
这也许能帮你更好地理解这本书的其余部分。
至少，在你被卷入一场关于设计模式和软件架构有多么糟糕（或多么优秀）的辩论时，
这可以给你一些火力支援。</p>
<blockquote>
<p>注意我没有建议你在战斗中选哪一边。就像任何军火贩子一样，我愿意向作战双方出售武器。</p>
</blockquote>
<h2><a class="header" href="#什么是软件架构" id="什么是软件架构">什么是软件架构</a></h2>
<p>如果把本书从头到尾读一遍，
你不会学会 3D 图形背后的线性代数或者游戏物理背后的微积分。
本书不会告诉你如何用 α-β 修剪你的 AI 树，也不会告诉你如何在音频播放中模拟房间中的混响。</p>
<blockquote>
<p>Wow，这段给这本书打了个糟糕的广告啊。</p>
</blockquote>
<p>相反，这本书告诉你在这些<strong>之间</strong>的代码的事情。
与其说这本书是关于如何写代码，不如说是关于如何<strong>架构</strong>代码的。
每个程序都有<strong>一定</strong>架构，哪怕这架构是“将所有东西都塞到<code>main()</code>中看看如何”，
所以我认为讲讲什么造成了<strong>好</strong>架构是很有意思的。我们如何区分好架构和坏架构呢？</p>
<p>我思考这个问题五年了。当然，像你一样，我有对好的设计有一种直觉。
我们都被糟糕的代码折磨得不轻，你唯一能做的好事就是删掉它们，结束它们的痛苦。</p>
<blockquote>
<p>不得不承认，我们中大多数人都该对一些糟糕代码<strong>负责</strong>。</p>
</blockquote>
<p>少数幸运儿有相反的经验，有机会在好好设计的代码库上工作。
那种代码库看上去是间豪华酒店，里面的门房随时准备满足你心血来潮的需求。
这两者之间的区别是什么呢？</p>
<h3><a class="header" href="#什么是好的软件架构" id="什么是好的软件架构">什么是<strong>好的</strong>软件架构</a></h3>
<p>对我而言，好的设计意味着当我作出改动，整个程序就好像正等着这种改动。
我可以仅调用几个函数就完成任务，而代码库本身无需改动。</p>
<p>这听起来很棒，但实际上不可行。“把代码写成改动不会影响其表面上的和谐。”就好。</p>
<p>让我们通俗些。第一个关键点是<strong>架构是关于改动的</strong>。
总会有人改动代码。如果没人碰代码，那么它的架构设计就无关紧要——无论是因为代码至善至美，还是因为代码糟糕透顶以至于没人会为了修改它而玷污自己的文本编辑器。
评价架构设计的好坏就是评价它应对改动有多么轻松。
没有了改动，架构好似永远不会离开起跑线的运动员。</p>
<h3><a class="header" href="#如何处理改动" id="如何处理改动">如何处理改动</a></h3>
<p>在你改动代码去添加新特性，去修复漏洞，或者随便用文本编辑器干点什么的时候，
你需要理解代码正在做什么。当然，你不需要理解整个程序，
但你需要将所有相关的东西装进你的大脑。</p>
<blockquote>
<p>有点诡异，这字面上是一个 OCR 过程。</p>
</blockquote>
<p>我们通常无视了这步，但这往往是编程中最耗时的部分。
如果你认为将数据从磁盘上分页到 RAM 上很慢，
那么通过一对神经纤维将数据分页到大脑中无疑更慢。</p>
<p>一旦把所有正确的上下文都记到了你的大脑里，
想一会，你就能找到解决方案。
可能有时也需要反复斟酌，但通常比较简单。
一旦理解了问题和需要改动的代码，实际的编码工作有时是微不足道的。</p>
<p>用手指在键盘上敲打一阵，直到屏幕上闪着正确的光芒，
搞定了，对吧？还没呢！
在你为之写测试并发送到代码评审之前，通常有些清理工作要做。</p>
<blockquote>
<p>我是不是说了“测试”？噢，是的。为有些游戏代码写单元测试很难，但代码库的大部分是完全可以测试的。</p>
<p>我不会在这里发表演说，但是我建议你，如果还没有做自动测试，请考虑一下。
除了手动验证以外你就没更重要的事要做了吗？</p>
</blockquote>
<p>你将一些代码加入了游戏，但肯定不想下一个人被留下来的小问题绊倒。
除非改动很小，否则就还需要一些微调新代码的工作，使之无缝对接到程序的其他部分。
如果你做对了，那么下个编写代码的人无法察觉到哪些代码是新加入的。</p>
<p>简而言之，编程的流程图看起来是这样的：</p>
<p><img src="https://gpp.tkchu.me/images/architecture-cycle.png" alt="令人震惊的死循环" /></p>
<blockquote>
<p>令人震惊的死循环，我看到了。</p>
</blockquote>
<h3><a class="header" href="#解耦帮了什么忙" id="解耦帮了什么忙">解耦帮了什么忙</a></h3>
<p>虽然并不明显，但我认为很多软件架构都是关于研究代码的阶段。
将代码载入到神经元太过缓慢，找些策略减少载入的总量是件很值得做的事。
这本书有整整一章是关于<a href="06%E8%A7%A3%E8%80%A6%E6%A8%A1%E5%BC%8F.html"><strong>解耦</strong>模式</a>，
还有很多<strong>设计模式</strong>是关于同样的主题。</p>
<p>可以用多种方式定义“解耦”，但我认为如果有两块代码是耦合的，
那就意味着无法只理解其中一个。
如果<strong>解</strong>耦了它们俩，就可以单独地理解某一块。
这当然很好，因为只有一块与问题相关，
只需将<strong>这一块</strong>加载到你的大脑中而不需要加载另外一块。</p>
<p>对我来说，这是软件架构的关键目标：<strong>最小化在编写代码前需要了解的信息</strong>。</p>
<p>当然，也可以从后期阶段来看。
解耦的另一种定义是：当一块代码有<strong>改动</strong>时，不需要修改另一块代码。
肯定也得修改<strong>一些东西</strong>，但耦合程度越小，改动会波及的范围就越小。</p>
<h2><a class="header" href="#代价" id="代价">代价</a></h2>
<p>听起来很棒，对吧？解耦任何东西，然后就可以像风一样编码。
每个改动都只需修改一两个特定方法，你可以在代码库上行云流水地编写代码。</p>
<p>这就是抽象、模块化、设计模式和软件架构使人们激动不已的原因。
在架构优良的程序上工作是极佳的体验，每个人都希望能更有效率地工作。
好架构能造成生产力上<strong>巨大的</strong>不同。它的影响大得无以复加。</p>
<p>但是，天下没有免费的午餐。好的设计需要汗水和纪律。
每次做出改动或是实现特性，你都需要将它优雅的集成到程序的其他部分。
需要花费大量的努力去管理代码，
使得程序在开发过程中面对千百次变化仍能<strong>保持</strong>它的结构。</p>
<blockquote>
<p>第二部分——管理代码——需要特别关注。
我看到无数程序有优雅的开始，然后死于程序员一遍又一遍添加的“微小黑魔法”。</p>
<p>就像园艺，仅仅种植是不够的，还需要除草和修剪。</p>
</blockquote>
<p>你得考虑程序的哪部分需要解耦，然后再引入抽象。
同样，你需要决定哪部分能支持扩展来应对未来的改动。</p>
<p>人们对这点变得狂热。
他们设想，未来的开发者（或者他们自己）进入代码库，
发现它极为开放，功能强大，只需扩展。
他们想要有“至尊代码应众求”。（译著：这里是“至尊魔戒御众戒”的梗，很遗憾翻译不出来）</p>
<p>但是，事情从这里开始变得棘手。
每当你添加了抽象或者扩展支持，你就是在<strong>赌</strong>以后这里需要灵活性。
你向游戏中添加的代码和复杂性是需要时间来开发、调试和维护的。</p>
<p>如果你赌对了，后来使用了这些代码，那么功夫不负有心人。
但预测未来<strong>很难</strong>，模块化如果最终无益，那就有害。
毕竟，你得处理更多的代码。</p>
<blockquote>
<p>有些人喜欢使用术语“YAGNI”——<a href="http://en.wikipedia.org/wiki/You_aren&#x27;t_gonna_need_it">You aren't gonna need it（你不需要那个）</a>——来对抗这种预测将来需求的强烈冲动。</p>
</blockquote>
<p>当你过分关注这点时，代码库就失控了。
接口和抽象无处不在。插件系统，抽象基类，虚方法，还有各种各样的扩展点，它们遍地都是。</p>
<p>你要消耗无尽的时间回溯所有的脚手架，去找真正做事的代码。
当需要作出改动时，当然，有可能某个接口能帮上忙，但能不能找到就只能听天由命了。
理论上，解耦意味着在修改代码之前需要了解更少的代码，
但抽象层本身也会填满大脑。</p>
<p>像这样的代码库会使得人们<strong>反对</strong>软件架构，特别是设计模式。
人们很容易沉浸在代码中，忽略了目标是要发布<strong>游戏</strong>。
对可扩展性的过分强调使得无数的开发者花费多年时间制作“引擎”，
却没有搞清楚做引擎是<strong>为了什么</strong>。</p>
<h2><a class="header" href="#性能和速度" id="性能和速度">性能和速度</a></h2>
<p>软件架构和抽象有时因损伤性能而被批评，而游戏开发尤甚。
让代码更灵活的许多模式依靠虚拟调度、 接口、 指针、 消息和其他机制，
它们都会加大运行时开销。</p>
<blockquote>
<p>一个有趣的反面例子是 C++中的模板。模板编程有时可以带来没有运行时开销的抽象接口。</p>
<p>这是灵活性的两极。
当写代码调用类中的具体方法时，你就是在<strong>写</strong>的时候指定类——硬编码了调用的是哪个类。
当使用虚方法或接口时，直到<strong>运行</strong>时才知道调用的类。这更加灵活但增加了运行时开销。</p>
<p>模板编程是在两极之间。在<strong>编译时</strong>初始化模板，决定调用哪些类。</p>
</blockquote>
<p>还有一个原因。很多软件架构的目的是使程序更加灵活，作出改动需要更少的付出，编码时对程序有更少的假设。
使用接口可以让代码可与<strong>任何</strong>实现了接口的类交互，而不仅仅是<strong>现在</strong>写的类。
今天，你可以使用<a href="03-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html">观察者模式</a>和<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">消息队列</a>让游戏的两部分相互交流，
以后可以很容易地扩展为三个或四个部分相互交流。</p>
<p>但性能与假设相关。实现优化需要基于确定的限制。
敌人永远不会超过 256 个？好，可以将敌人 ID 编码为一个字节。
只在这种类型上调用方法吗？好，可以做静态调度或内联。
所有实体都是同一类？太好了，可以使用 <a href="07-1%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7.html#%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84">连续数组</a>存储它们。</p>
<p>但这并不意味着灵活性不好！它可以让我们快速改进游戏，
<strong>开发</strong>速度对创造更好的游戏体验来说是很重要的。
没有人能在纸面上构建一个平衡的游戏，哪怕是 Will Wright。这需要迭代和实验。</p>
<p>尝试想法并查看效果的速度越快，能尝试的东西就越多，也就越可能找到有价值的东西。
就算找到正确的机制，你也需要足够的时间调试。
一个微小的不平衡就有可能破坏整个游戏的乐趣。</p>
<p>这里没有普适的答案。
要么在损失一点点性能的前提下，让你的程序更加灵活以便更快地做出原型；
要么就优化性能，损失一些灵活性。</p>
<p>就我个人经验而言，让有趣的游戏变得高效比让高效的游戏变有趣简单得多。
一种折中的办法是保持代码灵活直到确定设计，再去除抽象层来提高性能。</p>
<h2><a class="header" href="#糟糕代码的优势" id="糟糕代码的优势">糟糕代码的优势</a></h2>
<p>下一观点：不同的代码风格各有千秋。
这本书的大部分是关于保持干净可控的代码，所以我坚持应该用<strong>正确</strong>方式写代码，但糟糕的代码也有一定的优势。</p>
<p>编写架构良好的代码需要仔细地思考，这会消耗时间。
在项目的整个周期中<strong>保持</strong>良好的架构需要花费大量的努力。
你需要像露营者处理营地一样小心处理代码库：总是让它比之前更好些。</p>
<p>当你要在项目上花费很久时间的时这是很好的。
但就像早先提到的，游戏设计需要很多实验和探索。
特别是在早期，写一些你<strong>知道</strong>将会扔掉的代码是很普遍的事情。</p>
<p>如果只想试试游戏的某些点子是否可行，
良好的架构就意味着在屏幕上看到和获取反馈之前要消耗很长时间。
如果最后证明这点子不对，那么删除代码时，那些让代码更优雅的工夫就付诸东流了。</p>
<p>原型——一坨勉强拼凑在一起，只能完成某个点子的简单代码——是个完全合理的编程实践。
虽然当你写一次性代码时，<em>必须</em> 保证将来可以扔掉它。
我见过很多次糟糕的经理人在玩这种把戏：</p>
<blockquote>
<p>老板：“嗨，我有些想试试的点子。只要原型，不需要做得很好。你能多快搞定？”</p>
<p>开发者：“额，如果删掉这些部分，不测试，不写文档，允许很多的漏洞，那么几天能给你临时的代码文件。”
老板：“太好了。”</p>
</blockquote>
<p>几天后</p>
<blockquote>
<p>老板：“嘿，原型很棒，你能花上几个小时清理一下然后变为成品吗？”</p>
</blockquote>
<p>你得让人们清楚，可抛弃的代码即使看上去能工作，也不能被<strong>维护</strong>，<em>必须</em> 重写。
如果<strong>有可能</strong>要维护这段代码，就得防御性地好好编写它。</p>
<blockquote>
<p>一个小技巧能保证原型代码不会变成真正用的代码：使用和游戏实现不同的编程语言。
这样，在将其实际应用于游戏中之前必须重写。</p>
</blockquote>
<h2><a class="header" href="#保持平衡" id="保持平衡">保持平衡</a></h2>
<p>有些因素在相互角力：</p>
<ol>
<li>为了在项目的整个生命周期保持其可读性，需要好的架构。</li>
<li>需要更好的运行时性能。</li>
<li>需要让现在想要的特性更快地实现。</li>
</ol>
<blockquote>
<p>有趣的是，这些都是速度：长期开发的速度，游戏运行的速度，和短期开发的速度。</p>
</blockquote>
<p>这些目标至少是部分对立的。
好的架构长期来看提高了生产力，
也意味着每个改动都需要消耗更多努力保持代码整洁。</p>
<p>草就的代码很少是<strong>运行时</strong>最快的。
相反，提升性能需要很多的开发时间。
一旦完成，它就会污染代码库：高度优化的代码不灵活，很难改动。</p>
<p>总有今日事今日毕的压力。但是如果尽可能快地实现特性，
代码库就会充满黑魔法，漏洞和混乱，阻碍未来的产出。</p>
<p>没有简单的答案，只有权衡。
从我收到的邮件看，这伤了很多人的心，特别是那些只是想做个游戏的人。
这似乎是在恐吓，“没有正确的答案，只有不同的错误。”</p>
<p>但对我而言，这让人兴奋！看看任何人们从事的领域，
你总能发现某些相互抵触的限制。无论如何，如果有简单的答案，每个人都会那么做。
一周就能掌握的领域是很无聊的。你从来没有听说过有人讨论挖坑。</p>
<blockquote>
<p>也许你会讨论挖坑；我没有深究这个类比。
可能有挖坑热爱者，挖坑规范，以及一整套亚文化。
我算什么人，能在此大放厥词？</p>
</blockquote>
<p>对我来说，这和游戏有很多相似之处。
国际象棋之类的游戏永远不能被掌握，因为每个棋子都很完美地与其他棋子相平衡。
这意味你可以花费一生探索广阔的可选策略。糟糕的游戏就像井字棋，玩上几遍就会厌倦地退出。</p>
<h2><a class="header" href="#简单" id="简单">简单</a></h2>
<p>最近，我感觉如果有什么能简化这些限制，那就是<strong>简单</strong>。
在我现在的代码中，我努力去写最简单，最直接的解决方案。
你读过这种代码后，完全理解了它在做什么，想不到其他完成的方法。</p>
<p>我的目标是正确获得数据结构和算法（大致是这样的先后），然后再从那里开始。
我发现如果能让事物变得简单，最终的代码就更少，
就意味着改动时有更少的代码载入脑海。</p>
<p>它通常跑的很快，因为没什么开销，也没什么代码需要执行。
（虽然大部分时候事实并非如此。你可以在一小段代码里加入大量的循环和递归。）</p>
<p>但是，注意我并没有说简单的代码需要更少的时间<strong>编写</strong>。
你会这么觉得是因为最终得到了更少的代码，但是好的解决方案不是往代码中注水，而是<strong>蒸干</strong>代码。</p>
<blockquote>
<p>Blaise Pascal 有句著名的信件结尾，“我没时间写得更短。”</p>
<p>另一句名言来自 Antoine de Saint-Exupery：“臻于完美之时，不是加无可加，而是减无可减。”</p>
<p>言归正传，我发现每次重写本书，它就变得更短。有些章节比刚完成时短了 20%。</p>
</blockquote>
<p>我们很少遇到优雅表达的问题，一般反而是一堆用况。
你想要 X 在 Z 情况下做 Y，在 A 情况下做 W，诸如此类。换言之，一长列不同行为。</p>
<p>最节约心血的方法是为每段用况编写一段代码。
看看新手程序员，他们经常这么干：为每种情况编写条件逻辑。</p>
<p>但这一点也不优雅，那种风格的代码遇到一点点没想到的输入就会崩溃。
当我们想象优雅的代码时，想的是<strong>通用</strong>的那一个：
只需要很少的逻辑就可以覆盖整个用况。</p>
<p>找到这样的方法有点像模式识别或者解决谜题。
需要努力去识别散乱的用例下隐藏的规律。
完成时你会感觉好得不能再好。</p>
<h2><a class="header" href="#就快完了" id="就快完了">就快完了</a></h2>
<p>几乎每个人都会跳过介绍章节，所以祝贺你看到这里。
我没有太多东西回报你的耐心，但还有些建议给你，希望对你有用：</p>
<ul>
<li>
<p>抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。</p>
</li>
<li>
<p>在整个开发周期中为性能考虑并做好设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。</p>
</li>
</ul>
<blockquote>
<p>相信我，发布前两个月<strong>不是</strong>开始思考“游戏运行只有 1FPS”这种问题的时候。</p>
</blockquote>
<ul>
<li>
<p>快速地探索游戏的设计空间，但不要跑得太快，在身后留下烂摊子。毕竟你总得回来打扫。</p>
</li>
<li>
<p>如果打算抛弃这段代码，就不要尝试将其写完美。摇滚明星将旅店房间弄得一团糟，因为他们知道明天就走人了。</p>
</li>
<li>
<p>但最重要的是，<strong>如果你想要做出让人享受的东西，那就享受做它的过程。</strong></p>
</li>
</ul>
<h1><a class="header" href="#重返设计模式" id="重返设计模式">重返设计模式</a></h1>
<p>《设计模式：可复用面向对象软件的基础》出版已经二十年了。
除非你比我从业还久，否则《设计模式》已经酝酿成一坛足以饮用的老酒了。
对于像软件行业这样快速发展的行业，它已经是老古董了。
这本书的持久流行证明了设计方法比框架和方法论更经久不衰。</p>
<p>虽然我认为<strong>设计模式</strong>仍然有意义，但在过去几十年我们学到了很多。
在这一部分，我们会遇到 GoF 记载的一些模式。
对于每个模式，我希望能讲些有用有趣的东西。</p>
<p>我认为有些模式被过度使用了(<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例模式</a>），
而另一些被冷落了（<a href="03-1%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html">命令模式</a>）。
有些模式在这里是因为我想探索其在游戏上的特殊应用（<a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a>和<a href="03-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html">观察者模式</a>）。
最后，我认为看看有些模式在更广的编程领域是如何运用的是很有趣的（<a href="03-4%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">原型模式</a>和<a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a>）。</p>
<h2><a class="header" href="#模式" id="模式">模式</a></h2>
<ul>
<li><a href="03-1%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html">命令模式</a></li>
<li><a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a></li>
<li><a href="03-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html">观察者模式</a></li>
<li><a href="03-4%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html">原型模式</a></li>
<li><a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例模式</a></li>
<li><a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a></li>
</ul>
<h1><a class="header" href="#命令模式" id="命令模式">命令模式</a></h1>
<p>命令模式是我最喜欢的模式之一。
大多数我写的游戏或者别的什么之类的大型程序，都会在某处用到它。
当在正确的地方使用时，它可以将复杂的代码清理干净。
对于这样一个了不起的模式，不出所料地，GoF 有个深奥的定义：</p>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；
对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>我想你也会觉得这个句子晦涩难懂。
第一，它的比喻难以理解。
在词语可以指代任何事物的狂野软件世界之外，“客户”是一个<strong>人</strong>——那些和你做生意的人。
据我查证，人类不能被“参数化”。</p>
<p>然后，句子余下的部分介绍了可能会使用这个模式的场景。
如果你的场景不在这个列表中，那么这对你就没什么用处。
<strong>我的</strong>命令模式精简定义为：</p>
<blockquote>
<blockquote>
<p>命令是具现化的方法调用。</p>
<p>A command is a reified method call.</p>
</blockquote>
<p>“Reify（具现化）”来自于拉丁语“res”，意为“thing”（事物），加上英语后缀“-fy”。
所以它意为“thingify”，没准用“thingify”更合适。</p>
</blockquote>
<p>当然，“精简”往往意味着着“缺少必要信息”，所以这可能没有太大的改善。
让我扩展一下。如果你没有听说过“具现化”的话，它的意思是“实例化，对象化”。
具现化的另外一种解释方式是将某事物作为“第一公民”对待。</p>
<blockquote>
<p>在某些语言中的<strong>反射</strong>允许你在程序运行时命令式地和类型交互。
你可以获得类的类型对象，可以与其交互看看这个类型能做什么。换言之，反射是<strong>具现化类型的系统</strong>。</p>
</blockquote>
<p>两种术语都意味着将<strong>概念</strong>变成<strong>数据</strong>
——一个对象——可以存储在变量中，传给函数。
所以称命令模式为“具现化方法调用”，意思是方法调用被存储在对象中。</p>
<p>这听起来有些像“回调”，“第一公民函数”，“函数指针”，“闭包”，“偏函数”，
取决于你在学哪种语言，事实上大致上是同一个东西。GoF 随后说：</p>
<blockquote>
<p>命令模式是一种回调的面向对象实现。</p>
</blockquote>
<p>这是一种对命令模式更好的解释。</p>
<p>但这些都既抽象又模糊。我喜欢用实际的东西作为章节的开始，不好意思，搞砸了。
作为弥补，从这里开始都是命令模式能出色应用的例子。</p>
<h2><a class="header" href="#配置输入" id="配置输入">配置输入</a></h2>
<p>在每个游戏中都有一块代码读取用户的输入——按钮按下，键盘敲击，鼠标点击，诸如此类。
这块代码会获取用户的输入，然后将其变为游戏中有意义的行为：</p>
<p><img src="https://gpp.tkchu.me/images/command-buttons-one.png" alt="配置输入" /></p>
<p>下面是一种简单的实现：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) lurchIneffectively();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>专家建议：不要太经常地按 B。</p>
</blockquote>
<p>这个函数通常在<a href="04-2%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF.html">游戏循环</a>中每帧调用一次，我确信你可以理解它做了什么。
在我们想将用户的输入和程序行为硬编码在一起时，这段代码可以正常工作，但是许多游戏允许玩家<strong>配置</strong>按键的功能。</p>
<p>为了支持这点，需要将这些对<code>jump()</code>和<code>fireGun()</code>的直接调用转化为可以变换的东西。
“变换”听起来有点像变量干的事，因此我们需要表示游戏行为的<strong>对象</strong>。进入：命令模式。</p>
<p>我们定义了一个基类代表可触发的游戏行为：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>当你有接口只包含一个没有返回值的方法时，很可能你可以使用命令模式。</p>
</blockquote>
<p>然后我们为不同的游戏行为定义相应的子类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class JumpCommand : public Command
{
public:
  virtual void execute() { jump(); }
};

class FireCommand : public Command
{
public:
  virtual void execute() { fireGun(); }
};

// 你知道思路了吧
<span class="boring">}
</span></code></pre></pre>
<p>在代码的输入处理部分，为每个按键存储一个指向命令的指针。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class InputHandler
{
public:
  void handleInput();

  // 绑定命令的方法……

private:
  Command** buttonX_;
  Command** buttonY_;
  Command** buttonA_;
  Command** buttonB_;
};
<span class="boring">}
</span></code></pre></pre>
<p>现在输入处理部分这样处理：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) buttonX_-&gt;execute();
  else if (isPressed(BUTTON_Y)) buttonY_-&gt;execute();
  else if (isPressed(BUTTON_A)) buttonA_-&gt;execute();
  else if (isPressed(BUTTON_B)) buttonB_-&gt;execute();
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意在这里没有检测<code>NULL</code>了吗？这假设每个按键都与<strong>某些</strong>命令相连。</p>
<p>如果想支持不做任何事情的按键又不想显式检测<code>NULL</code>，我们可以定义一个命令类，它的<code>execute()</code>什么也不做。
这样，某些按键处理器不必设为<code>NULL</code>，只需指向这个类。这种模式被称为<a href="http://en.wikipedia.org/wiki/Null_Object_pattern">空对象</a>。</p>
</blockquote>
<p>以前每个输入直接调用函数，现在会有一层间接寻址：</p>
<p><img src="https://gpp.tkchu.me/images/command-buttons-two.png" alt="间接寻址" /></p>
<p>这是命令模式的简短介绍。如果你能够看出它的好处，就把这章剩下的部分作为奖励吧。</p>
<h2><a class="header" href="#角色说明" id="角色说明">角色说明</a></h2>
<p>我们刚才定义的类可以在之前的例子上正常工作，但有很大的局限。
问题在于假设了顶层的<code>jump()</code>, <code>fireGun()</code>之类的函数可以找到玩家角色，然后像木偶一样操纵它。</p>
<p>这些假定的耦合限制了这些命令的用处。<code>JumpCommand</code><em>只能</em> 让玩家的角色跳跃。让我们放松这个限制。
不让函数去找它们控制的角色，我们将函数控制的角色对象<strong>传进去</strong>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute(GameActor&amp; actor) = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p>这里的<code>GameActor</code>是代表游戏世界中角色的“游戏对象”类。
我们将其传给<code>execute()</code>，这样命令类的子类就可以调用所选游戏对象上的方法，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class JumpCommand : public Command
{
public:
  virtual void execute(GameActor&amp; actor)
  {
    actor.jump();
  }
};
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们可以使用这个类让游戏中的任何角色跳来跳去了。
在输入控制部分和在对象上调用命令部分之间，我们还缺了一块代码。
第一，我们修改<code>handleInput()</code>，让它可以<strong>返回</strong>命令：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** InputHandler::handleInput()
{
  if (isPressed(BUTTON_X)) return buttonX_;
  if (isPressed(BUTTON_Y)) return buttonY_;
  if (isPressed(BUTTON_A)) return buttonA_;
  if (isPressed(BUTTON_B)) return buttonB_;

  // 没有按下任何按键，就什么也不做
  return NULL;
}
<span class="boring">}
</span></code></pre></pre>
<p>这里不能立即执行，因为还不知道哪个角色会传进来。
这里我们享受了命令是具体调用的好处——<code>延迟</code>到调用执行时再知道。</p>
<p>然后，需要一些接受命令的代码，作用在玩家角色上。像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** command = inputHandler.handleInput();
if (command)
{
  command-&gt;execute(actor);
}
<span class="boring">}
</span></code></pre></pre>
<p>将<code>actor</code>视为玩家角色的引用，它会正确地按着玩家的输入移动，
所以我们赋予了角色和前面例子中相同的行为。
通过在命令和角色间增加了一层重定向，
我们获得了一个灵巧的功能：<em>我们可以让玩家控制游戏中的任何角色，只需向命令传入不同的角色。</em></p>
<p>在实践中，这个特性并不经常使用，但是<strong>经常</strong>会有类似的用例跳出来。
到目前为止，我们只考虑了玩家控制的角色，但是游戏中的其他角色呢？
它们被游戏 AI 控制。我们可以在 AI 和角色之间使用相同的命令模式；AI 代码只需生成<code>Command</code>对象。</p>
<p>在选择命令的 AI 和展现命令的游戏角色间解耦给了我们很大的灵活度。
我们可以对不同的角色使用不同的 AI，或者为了不同的行为而混合 AI。
想要一个更加有攻击性的对手？插入一个更加有攻击性的 AI 为其生成命令。
事实上，我们甚至可以为<strong>玩家角色</strong>加上 AI，
在展示阶段，游戏需要自动演示时，这是很有用的。</p>
<p>把控制角色的命令变为第一公民对象，去除直接方法调用中严厉的束缚。
将其视为命令队列，或者是命令流：</p>
<blockquote>
<p>队列能为你做的更多事情，请看<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">事件队列</a>。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/command-stream.png" alt="一条连接AI到角色的管道" /></p>
<blockquote>
<p>为什么我觉得需要为你画一幅“流”的图像？又是为什么它看上去像是管道？</p>
</blockquote>
<p>一些代码（输入控制器或者 AI）产生一系列命令放入流中。
另一些代码（调度器或者角色自身）调用并消耗命令。
通过在中间加入队列，我们解耦了消费者和生产者。</p>
<blockquote>
<p>如果将这些指令<strong>序列化</strong>，我们可以通过网络流传输它们。
我们可以接受玩家的输入，将其通过网络发送到另外一台机器上，然后重现之。这是网络多人游戏的基础。</p>
</blockquote>
<h2><a class="header" href="#撤销和重做" id="撤销和重做">撤销和重做</a></h2>
<p>最后的这个例子是这种模式最广为人知的使用情况。
如果一个命令对象可以<strong>做</strong>一件事，那么它亦可以<strong>撤销</strong>这件事。
在一些策略游戏中使用撤销，这样你就可以回滚那些你不喜欢的操作。
它是<strong>创造</strong>游戏时<strong>必不可少的</strong>工具。
一个不能撤销误操作导致的错误的编辑器，肯定会让游戏设计师恨你。</p>
<blockquote>
<p>这是经验之谈。</p>
</blockquote>
<p>没有了命令模式，实现撤销非常困难，有了它，就是小菜一碟。
假设我们在制作单人回合制游戏，想让玩家能撤销移动，这样他们就可以集中注意力在策略上而不是猜测上。</p>
<p>我们已经使用了命令来抽象输入控制，所以每个玩家的举动都已经被封装其中。
举个例子，移动一个单位的代码可能如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit** unit, int x, int y)
  : unit_(unit),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    unit_-&gt;moveTo(x_, y_);
  }

private:
  Unit** unit_;
  int x_, y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意这和前面的命令有些许不同。
在前面的例子中，我们需要从修改的角色那里<strong>抽象</strong>命令。
在这个例子中，我们将命令<strong>绑定</strong>到要移动的单位上。
这条命令的实例不是通用的“移动某物”命令；而是游戏回合中特殊的一次移动。</p>
<p>这展现了命令模式应用时的一种情形。
就像之前的例子，指令在某些情形中是可重用的对象，代表了<strong>可执行的事件</strong>。
我们早期的输入控制器将其实现为一个命令对象，然后在按键按下时调用其<code>execute()</code>方法。</p>
<p>这里的命令更加特殊。它们代表了特定时间点能做的特定事件。
这意味着输入控制代码可以在玩家下决定时<strong>创造</strong>一个实例。就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Command** handleInput()
{
  Unit** unit = getSelectedUnit();

  if (isPressed(BUTTON_UP)) {
    // 向上移动单位
    int destY = unit-&gt;y() - 1;
    return new MoveUnitCommand(unit, unit-&gt;x(), destY);
  }

  if (isPressed(BUTTON_DOWN)) {
    // 向下移动单位
    int destY = unit-&gt;y() + 1;
    return new MoveUnitCommand(unit, unit-&gt;x(), destY);
  }

  // 其他的移动……

  return NULL;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>当然，在像 C++这样没有垃圾回收的语言中，这意味着执行命令的代码也要负责释放内存。</p>
</blockquote>
<p>命令的一次性为我们很快地赢得了一个优点。
为了让指令可被取消，我们为每个类定义另一个需要实现的方法：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Command
{
public:
  virtual ~Command() {}
  virtual void execute() = 0;
  virtual void undo() = 0;
};
<span class="boring">}
</span></code></pre></pre>
<p><code>undo()</code>方法回滚了<code>execute()</code>方法造成的游戏状态改变。
这里是添加了撤销功能后的移动命令：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class MoveUnitCommand : public Command
{
public:
  MoveUnitCommand(Unit** unit, int x, int y)
  : unit_(unit),
    xBefore_(0),
    yBefore_(0),
    x_(x),
    y_(y)
  {}

  virtual void execute()
  {
    // 保存移动之前的位置
    // 这样之后可以复原。

    xBefore_ = unit_-&gt;x();
    yBefore_ = unit_-&gt;y();

    unit_-&gt;moveTo(x_, y_);
  }

  virtual void undo()
  {
    unit_-&gt;moveTo(xBefore_, yBefore_);
  }

private:
  Unit** unit_;
  int xBefore_, yBefore_;
  int x_, y_;
};
<span class="boring">}
</span></code></pre></pre>
<p>注意我们为类添加了更多的状态。
当单位移动时，它忘记了它之前是什么样的。
如果我们想要撤销这个移动，我们需要记得单位之前的状态，也就是<code>xBefore_</code>和<code>yBefore_</code>的作用。</p>
<blockquote>
<p>这看上去是<a href="http://en.wikipedia.org/wiki/Memento_pattern">备忘录</a>模式使用的地方，它从来没有有效地工作过。
由于命令趋向于修改对象状态的一小部分，对数据其他部分的快照就是浪费内存。手动内存管理的消耗更小。</p>
<p><a href="http://en.wikipedia.org/wiki/Persistent_data_structure"><strong>持久化数据结构</strong></a>是另一个选项。
使用它，每次修改对象都返回一个新对象，保持原来的对象不变。巧妙的实现下，这些新对象与之前的对象共享数据，所以比克隆整个对象开销更小。</p>
<p>使用持久化数据结构，每条命令都存储了命令执行之前对象的引用，而撤销只是切换回之前的对象。</p>
</blockquote>
<p>为了让玩家撤销移动，我们记录了执行的最后命令。当他们按下<code>control + z</code>时，我们调用命令的<code>undo()</code>方法。
（如果他们已经撤销了，那么就变成了“重做”，我们会再一次执行命令。）</p>
<p>支持多重的撤销也不太难。
我们不单单记录最后一条指令，还要记录指令列表，然后用一个引用指向“当前”的那个。
当玩家执行一条命令，我们将其添加到列表，然后将代表“当前”的指针指向它。</p>
<p><img src="https://gpp.tkchu.me/images/command-undo.png" alt="多重撤销" /></p>
<p>当玩家选择“撤销”，我们撤销现在的命令，将代表当前的指针往后退。
当他们选择“重做”，我们将代表当前的指针往前进，执行该指令。
如果在撤销后选择了新命令，那么清除命令列表中当前的指针所指命令之后的全部命令。</p>
<p>第一次在关卡编辑器中实现这点时，我觉得自己简直就是个天才。
我惊讶于它如此的简明有效。
你需要约束自己，保证每个数据修改都通过命令完成，一旦你做到了，余下的都很简单。</p>
<blockquote>
<p>重做在游戏中并不常见，但重<strong>放</strong>常见。
一种简单的重放实现是记录游戏每帧的状态，这样它可以回放，但那会消耗太多的内存。</p>
<p>相反，很多游戏记录每个实体每帧运行的命令。
为了重放游戏，引擎只需要正常运行游戏，执行之前存储的命令。</p>
</blockquote>
<h2><a class="header" href="#用类还是用函数" id="用类还是用函数">用类还是用函数</a></h2>
<p>早些时候，我说过命令与第一公民函数或者闭包类似，
但是在这里展现的每个例子都是通过类完成的。
如果你更熟悉函数式编程，你也许会疑惑函数都在哪里。</p>
<p>我用这种方式写例子是因为 C++ 对第一公民函数支持非常有限。
函数指针没有状态，函子很奇怪而且仍然需要定义类，
在 C++11 中的 lambda 演算需要大量的人工记忆辅助才能使用。</p>
<p>这并<strong>不是</strong>说你在其他语言中不可以用函数来完成命令模式。
如果你使用的语言支持闭包，不管怎样，快去用它！
在某种程度上说，命令模式是为一些没有闭包的语言模拟闭包。</p>
<blockquote>
<p>我说<strong>某种程度上</strong>是因为，即使是那些支持闭包的语言，为命令建立真正的类或者结构也是很有用的。
如果你的命令拥有多重操作（比如可撤销的命令），将其全部映射到同一函数中并不优雅。</p>
<p>定义一个有字段的真实类能帮助读者理解命令包含了什么数据。
闭包是自动包装状态的完美解决方案，但它们过于自动化而很难看清包装的真正状态有哪些。</p>
</blockquote>
<p>举个例子，如果我们使用 javascript 来写游戏，那么我们可以用这种方式来写让单位移动的命令：</p>
<pre><code class="language-javascript">function makeMoveUnitCommand(unit, x, y) {
  // 这个函数就是命令对象:
  return function() {
    unit.moveTo(x, y);
  };
}
</code></pre>
<p>我们可以通过一对闭包来为撤销提供支持：</p>
<pre><code class="language-javascript">function makeMoveUnitCommand(unit, x, y) {
  var xBefore, yBefore;
  return {
    execute: function() {
      xBefore = unit.x();
      yBefore = unit.y();
      unit.moveTo(x, y);
    },
    undo: function() {
      unit.moveTo(xBefore, yBefore);
    }
  };
}
</code></pre>
<p>如果你习惯了函数式编程风格，这种做法是很自然的。
如果你没有，我希望这章可以帮你了解一些。
对于我而言，命令模式展现了函数式范式在很多问题上的高效性。</p>
<h2><a class="header" href="#参见" id="参见">参见</a></h2>
<ul>
<li>
<p>你最终可能会得到很多不同的命令类。
为了更容易实现这些类，定义一个具体的基类，包含一些能定义行为的高层方法，往往会有帮助。
这将命令的主体<code>execute()</code>转到<a href="05-2%E5%AD%90%E7%B1%BB%E6%B2%99%E7%AE%B1.html">子类沙箱</a>中。</p>
</li>
<li>
<p>在上面的例子中，我们明确地指定哪个角色会处理命令。
在某些情况下，特别是当对象模型分层时，也可以不这么简单粗暴。
对象可以响应命令，或者将命令交给它的从属对象。
如果你这样做，你就完成了一个<a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">职责链模式</a>。</p>
</li>
<li>
<p>有些命令是无状态的纯粹行为，比如第一个例子中的<code>JumpCommand</code>。
在这种情况下，有多个实例是在浪费内存，因为所有的实例是等价的。
可以用<a href="03-2%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html">享元模式</a>解决。</p>
</li>
</ul>
<blockquote>
<p>你可以将其实现为<a href="03-5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">单例</a>，但真朋友不会让你用单例。</p>
</blockquote>
<h1><a class="header" href="#享元模式" id="享元模式">享元模式</a></h1>
<p>迷雾散尽，露出了古朴庄严的森林。古老的铁杉，在头顶编成绿色穹顶。
阳光在树叶间破碎成金色顶棚。从树干间远眺，远处的森林渐渐隐去。</p>
<p>这是我们游戏开发者梦想的超凡场景，这样的场景通常由一个模式支撑着，它的名字低调至极：享元模式。</p>
<h2><a class="header" href="#森林" id="森林">森林</a></h2>
<p>用几句话就能描述一片巨大的森林，但是在实时游戏中做这件事就完全是另外一件事了。
当屏幕上需要显示一整个森林时，图形程序员看到的是每秒需要送到 GPU 六十次的百万多边形。</p>
<p>我们讨论的是成千上万的树，每棵都由上千的多边形组成。
就算有足够的<strong>内存</strong>描述森林，渲染的过程中，CPU 到 GPU 的部分也太过繁忙了。</p>
<p>每棵树都有一系列与之相关的位：</p>
<ul>
<li>定义树干，树枝和树叶形状的多边形网格。</li>
<li>树皮和树叶的纹理。</li>
<li>在森林中树的位置和朝向。</li>
<li>大小和色彩之类的调节参数，让每棵树都看起来与众不同。</li>
</ul>
<p>如果用代码表示，那么会得到这样的东西：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Tree
{
private:
  Mesh mesh_;
  Texture bark_;
  Texture leaves_;
  Vector position_;
  double height_;
  double thickness_;
  Color barkTint_;
  Color leafTint_;
};
<span class="boring">}
</span></code></pre></pre>
<p>这是一大堆数据，多边形网格和纹理体积非常大。
描述整个森林的对象在一帧的时间就交给 GPU 实在是太过了。
幸运的是，有一种老办法来处理它。</p>
<p>关键点在于，哪怕森林里有千千万万的树，它们大多数长得一模一样。
它们使用了相同的网格和纹理。
这意味着这些树的实例的大部分字段是<strong>一样的</strong>。</p>
<blockquote>
<p>你要么是疯了，要么是亿万富翁，才能让美术给森林里每棵树建立独立模型。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/flyweight-trees.png" alt="一行树，每棵都有自己的网格、纹理、树叶，调节参数和位置朝向。" /></p>
<blockquote>
<p>注意每一棵树的小盒子中的东西都是一样的。</p>
</blockquote>
<p>我们可以通过显式地将对象切为两部分来更加明确地模拟。
第一，将树共有的数据拿出来分离到另一个类中：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class TreeModel
{
private:
  Mesh mesh_;
  Texture bark_;
  Texture leaves_;
};
<span class="boring">}
</span></code></pre></pre>
<p>游戏只需要一个这种类，
因为没有必要在内存中把相同的网格和纹理重复一千遍。
游戏世界中每个树的实例只需有一个对这个共享<code>TreeModel</code>的<strong>引用</strong>。
留在<code>Tree</code>中的是那些实例相关的数据：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Tree
{
private:
  TreeModel* model_;

  Vector position_;
  double height_;
  double thickness_;
  Color barkTint_;
  Color leafTint_;
};
<span class="boring">}
</span></code></pre></pre>
<p>你可以将其想象成这样：</p>
<p><img src="https://gpp.tkchu.me/images/flyweight-tree-model.png" alt="一行树，每个都有自己的参数和位置朝向，指向另一个有网格、纹理、树叶的树模型。" /></p>
<blockquote>
<p>这有点像<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>模式。
两者都涉及将一个类中的状态委托给另外的类，来达到在不同实例间分享状态的目的。
但是，这两种模式背后的意图不同。</p>
<p>使用类型对象，目标是通过将类型引入对象模型，减少需要定义的类。
伴随而来的内容分享是额外的好处。享元模式则是纯粹的为了效率。</p>
</blockquote>
<p>把所有的东西都存在主存里没什么问题，但是这对渲染也毫无帮助。
在森林到屏幕上之前，它得先到 GPU。我们需要用显卡可以识别的方式共享数据。</p>
<h2><a class="header" href="#一千个实例" id="一千个实例">一千个实例</a></h2>
<p>为了减少需要推送到 GPU 的数据量，我们想把共享的数据——<code>TreeModel</code>——只发送<strong>一次</strong>。
然后，我们分别发送每个树独特的数据——位置，颜色，大小。
最后，我们告诉 GPU，“使用同一模型渲染每个实例”。</p>
<p>幸运的是，今日的图形接口和显卡正好支持这一点。
这些细节很繁琐且超出了这部书的范围，但是 Direct3D 和 OpenGL 都可以做<a href="http://en.wikipedia.org/wiki/Geometry_instancing"><em>实例渲染</em></a>。</p>
<p>在这些 API 中，你需要提供两部分数据流。
第一部分是一块需要渲染多次的共同数据——在例子中是树的网格和纹理。
第二部分是实例的列表以及绘制第一部分时需要使用的参数。
然后调用一次渲染，绘制整个森林。</p>
<blockquote>
<p>这个 API 是由显卡直接实现的，意味着享元模式也许是唯一的有硬件支持的 GoF 设计模式。</p>
</blockquote>
<h2><a class="header" href="#享元" id="享元">享元</a></h2>
<p>好了，我们已经看了一个具体的例子，下面我介绍模式的通用部分。
享元，就像它的名字暗示的那样，
当你需要共享类时使用，通常是因为你有太多这种类了。</p>
<p>实例渲染时，每棵树通过总线送到 GPU 消耗的更多是<strong>时间</strong>而非内存，但是基本要点是一样的。</p>
<p>这个模式通过将对象的数据分为两种来解决这个问题。
第一种数据没有特定指明是哪个对象的<strong>实例</strong>，因此可以在它们间分享。
Gof 称之为<strong>固有</strong>状态，但是我更喜欢将其视为“上下文无关”部分。
在这里的例子中，是树的网格和纹理。</p>
<p>数据的剩余部分是<strong>变化</strong>状态，那些每个实例独一无二的东西。
在这个例子中，是每棵树的位置，拉伸和颜色。
就像这里的示例代码块一样，这种模式通过在每个对象出现时共享一份固有状态来节约内存。</p>
<p>就目前而言，这看上去像是基础的资源共享，很难被称为一种模式。
部分原因是在这个例子中，我们可以为共享状态划出一个清晰的<strong>身份</strong>：<code>TreeModel</code>。</p>
<p>我发现，当共享对象没有有效定义的实体时，使用这种模式就不那么明显（使用它也就越发显得精明）。
在那些情况下，这看上去是一个对象被魔术般地同时分配到了多个地方。
让我展示给你另外一个例子。</p>
<h2><a class="header" href="#扎根之所" id="扎根之所">扎根之所</a></h2>
<p>这些树长出来的地方也需要在游戏中表示。
这里可能有草，泥土，丘陵，湖泊，河流，以及其它任何你可以想到的地形。
我们<strong>基于区块</strong>建立地表：世界的表面被划分为由微小区块组成的巨大网格。
每个区块都由一种地形覆盖。</p>
<p>每种地形类型都有一系列特性会影响游戏玩法：</p>
<ul>
<li>决定了玩家能够多快地穿过它的移动开销。</li>
<li>表明能否用船穿过的水域标识。</li>
<li>用来渲染它的纹理。</li>
</ul>
<p>因为我们游戏程序员偏执于效率，我们不会在每个区块中保存这些状态。
相反，一个通用的方式是为每种地形使用一个枚举。</p>
<blockquote>
<p>再怎么样，我们也已经从树的例子吸取教训了。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Terrain
{
  TERRAIN_GRASS,
  TERRAIN_HILL,
  TERRAIN_RIVER
  // 其他地形
};
<span class="boring">}
</span></code></pre></pre>
<p>然后，世界管理巨大的网格：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class World
{
private:
  Terrain tiles_[WIDTH][HEIGHT];
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里我使用嵌套数组存储 2D 网格。
在 C/C++中这样是很有效率的，因为它会将所有元素打包在一起。
在 Java 或者其他内存管理语言中，那样做会实际给你一个数组，其中每个元素都是对数组的列的<strong>引用</strong>，那就不像你想要的那样内存友好了。</p>
<p>反正，隐藏 2D 网格数据结构背后的实现细节，能使代码更好地工作。
我这里这样做只是为了让其保持简单。</p>
</blockquote>
<p>为了获得区块的实际有用的数据，我们做了一些这样的事情：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>int World::getMovementCost(int x, int y)
{
  switch (tiles_[x][y])
  {
    case TERRAIN_GRASS: return 1;
    case TERRAIN_HILL:  return 3;
    case TERRAIN_RIVER: return 2;
      // 其他地形……
  }
}

bool World::isWater(int x, int y)
{
  switch (tiles_[x][y])
  {
    case TERRAIN_GRASS: return false;
    case TERRAIN_HILL:  return false;
    case TERRAIN_RIVER: return true;
      // 其他地形……
  }
}
你知道我的意思了。这可行，但是我觉
<span class="boring">}
</span></code></pre></pre>
<p>你知道我的意思了。这可行，但是我觉得很丑。
移动开销和水域标识是区块的<strong>数据</strong>，但在这里它们散布在代码中。
更糟的是，简单地形的数据被众多方法拆开了。
如果能够将这些包裹起来就好了。毕竟，那是我们设计对象的目的。</p>
<p>如果我们有实际的地形<strong>类</strong>就好了，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Terrain
{
public:
  Terrain(int movementCost,
          bool isWater,
          Texture texture)
  : movementCost_(movementCost),
    isWater_(isWater),
    texture_(texture)
  {}

  int getMovementCost() const { return movementCost_; }
  bool isWater() const { return isWater_; }
  const Texture&amp; getTexture() const { return texture_; }

private:
  int movementCost_;
  bool isWater_;
  Texture texture_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>你会注意这里所有的方法都是<code>const</code>。这不是巧合。
由于同一对象在多处引用，如果你修改了它，改变会同时在多个地方出现。</p>
<p>这也许不是你想要的。
通过分享对象来节约内存的这种优化，不应该影响到应用的显性行为。
因此，享元对象几乎总是不可变的。</p>
</blockquote>
<p>但是我们不想为每个区块都保存一个实例。
如果你看看这个类内部，你会发现里面实际上<strong>什么也没有</strong>，
唯一特别的是区块在<strong>哪里</strong>。
用享元的术语讲，区块的<strong>所有</strong>状态都是“固有的”或者说“上下文无关的”。</p>
<p>鉴于此，我们没有必要保存多个同种地形类型。
地面上的草区块两两无异。
我们不用地形区块对象枚举构成世界网格，而是用<code>Terrain</code>对象<strong>指针</strong>组成网格：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class World
{
private:
  Terrain* tiles_[WIDTH][HEIGHT];

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>每个相同地形的区块会指向相同的地形实例。</p>
<p><img src="https://gpp.tkchu.me/images/flyweight-tiles.png" alt="一行区块，每个区块指向共享的草、河、山丘对象。" /></p>
<p>由于地形实例在很多地方使用，如果你想要动态分配，它们的生命周期会有点复杂。
因此，我们直接在游戏世界中存储它们。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class World
{
public:
  World()
  : grassTerrain_(1, false, GRASS_TEXTURE),
    hillTerrain_(3, false, HILL_TEXTURE),
    riverTerrain_(2, true, RIVER_TEXTURE)
  {}

private:
  Terrain grassTerrain_;
  Terrain hillTerrain_;
  Terrain riverTerrain_;

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>然后我们可以像这样来描绘地面：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void World::generateTerrain()
{
  // 将地面填满草皮.
  for (int x = 0; x &lt; WIDTH; x++)
  {
    for (int y = 0; y &lt; HEIGHT; y++)
    {
      // 加入一些丘陵
      if (random(10) == 0)
      {
        tiles_[x][y] = &amp;hillTerrain_;
      }
      else
      {
        tiles_[x][y] = &amp;grassTerrain_;
      }
    }
  }

  // 放置河流
  int x = random(WIDTH);
  for (int y = 0; y &lt; HEIGHT; y++) {
    tiles_[x][y] = &amp;riverTerrain_;
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>我承认这不是世界上最好的地形生成算法。</p>
</blockquote>
<p>现在不需要<code>World</code>中的方法来接触地形属性，我们可以直接暴露出<code>Terrain</code>对象。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const Terrain&amp; World::getTile(int x, int y) const
{
  return *tiles_[x][y];
}
<span class="boring">}
</span></code></pre></pre>
<p>用这种方式，<code>World</code>不再与各种地形的细节耦合。
如果你想要某一区块的属性，可直接从那个对象获得：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>int cost = world.getTile(2, 3).getMovementCost();
<span class="boring">}
</span></code></pre></pre>
<p>我们回到了操作实体对象的 API，几乎没有额外开销——指针通常不比枚举大。</p>
<h2><a class="header" href="#性能如何" id="性能如何">性能如何</a></h2>
<p>我在这里说几乎，是因为性能偏执狂肯定会想要知道它和枚举比起来如何。
通过解引用指针获取地形需要一次间接跳转。
为了获得移动开销这样的地形数据，你首先需要跟着网格中的指针找到地形对象，
然后再找到移动开销。跟踪这样的指针会导致缓存不命中，降低运行速度。</p>
<blockquote>
<p>需要更多指针追逐和缓存不命中的相关信息，看看<a href="07-1%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7.html">数据局部性</a>这章。</p>
</blockquote>
<p>就像往常一样，优化的金科玉律是<strong>需求优先</strong>。
现代计算机硬件过于复杂，性能只是游戏的一个考虑方面。
在我这章做的测试中，享元较枚举没有什么性能上的损失。
享元实际上明显更快。但是这完全取决于内存中的事物是如何排列的。</p>
<p>我<strong>可以</strong>自信地说使用享元对象不会搞到不可收拾。
它给了你面向对象的优势，而且没有产生一堆对象。
如果你创建了一个枚举，又在它上面做了很多分支跳转，考虑一下这个模式吧。
如果你担心性能，那么至少在把代码编程为难以维护的风格之前先做些性能分析。</p>
<h2><a class="header" href="#参见-1" id="参见-1">参见</a></h2>
<ul>
<li>
<p>在区块的例子中，我们只是为每种地形创建一个实例然后存储在<code>World</code>中。
这也许能更好找到和重用这些实例。
但是在多数情况下，你不会在一开始就创建<strong>所有</strong>享元。</p>
<p>如果你不能预料哪些是实际上需要的，最好在需要时才创建。
为了保持共享的优势，当你需要一个时，首先看看是否已经创建了一个相同的实例。
如果确实如此，那么只需返回那个实例。</p>
<p>这通常意味需要将构造函数封装在查询对象是否存在的接口之后。<br />
像这样隐藏构造指令是<a href="http://en.wikipedia.org/wiki/Factory_method_pattern">工厂方法</a>的一个例子。</p>
</li>
<li>
<p>为了返回一个早先创建的享元，需要追踪那些已经实例化的对象池。<br />
正如其名，这意味着<a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池</a>是存储它们的好地方。</p>
</li>
<li>
<p>当使用<a href="03-6%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html">状态模式</a>时，
经常会出现一些没有任何特定字段的“状态对象”。
这个状态的标识和方法都很有用。
在这种情况下，你可以使用这个模式，然后在不同的状态机上使用相同的对象实例。</p>
</li>
</ul>
<h1><a class="header" href="#观察者模式" id="观察者模式">观察者模式</a></h1>
<p>随便打开电脑中的一个应用，很有可能它就使用了<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC 架构</a>，而究其根本，是因为观察者模式。
观察者模式应用广泛，Java 甚至将其放到了核心库之中（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Observer.html"><code>java.util.Observer</code></a>），而 C#直接将其嵌入了<strong>语法</strong>（<a href="http://msdn.microsoft.com/en-us/library/8627sbea.aspx"><code>event</code></a>关键字）。</p>
<blockquote>
<p>就像软件中的很多东西，MVC 是 Smalltalkers 在七十年代创造的。
Lisp 程序员也许会说其实是他们在六十年代发明的，但是他们懒得记下来。</p>
</blockquote>
<p>观察者模式是应用最广泛和最广为人知的 GoF 模式，但是游戏开发世界与世隔绝，
所以对你来说，它也许是全新的。
假设你与世隔绝，让我给你举个形象的例子。</p>
<h2><a class="header" href="#成就解锁" id="成就解锁">成就解锁</a></h2>
<p>假设我们向游戏中添加了成就系统。
它存储了玩家可以完成的各种各样的成就，比如“杀死 1000 只猴子恶魔”，“从桥上掉下去”，或者“一命通关”。</p>
<blockquote>
<p><img src="https://gpp.tkchu.me/images/observer-weasel-wielder.png" alt="成就：一无所成" /></p>
<p>我发誓画的这个没有第二个意思，(笑。</p>
</blockquote>
<p>要实现这样一个包含各种行为来解锁成就的系统是很有技巧的。
如果我们不够小心，成就系统会缠绕在代码库的每个黑暗角落。
当然，“从桥上掉落”和物理引擎相关，
但我们并不想看到在处理撞击代码的线性代数时，
有个对<code>unlockFallOffBridge()</code>的调用是不？</p>
<blockquote>
<p>这只是随口一说。<br />
有自尊的物理程序员绝不会允许像<strong>游戏玩法</strong>这样的平凡之物玷污他们优美的算式。</p>
</blockquote>
<p>我们喜欢的是，照旧，让关注游戏一部分的所有代码集成到一块。
挑战在于，成就在游戏的不同层面被触发。怎么解耦成就系统和其他部分呢？</p>
<p>这就是观察者模式出现的原因。
这让代码宣称有趣的事情发生了，<em>而不必关心到底是谁接受了通知。</em></p>
<p>举个例子，有物理代码处理重力，追踪哪些物体待在地表，哪些坠入深渊。
为了实现“桥上掉落”的徽章，我们可以直接把成就代码放在那里，但那就会一团糟。
相反，可以这样做：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Physics::updateEntity(Entity&amp; entity)
{
  bool wasOnSurface = entity.isOnSurface();
  entity.accelerate(GRAVITY);
  entity.update();
  if (wasOnSurface &amp;&amp; !entity.isOnSurface())
  {
    notify(entity, EVENT_START_FALL);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>它做的就是声称，“额，我不知道有谁感兴趣，但是这个东西刚刚掉下去了。做你想做的事吧。”</p>
<blockquote>
<p>物理引擎确实决定了要发送什么通知，所以这并没有完全解耦。但在架构这个领域，通常只能让系统变得<strong>更好</strong>，而不是<strong>完美</strong>。</p>
</blockquote>
<p>成就系统注册它自己为观察者，这样无论何时物理代码发送通知，成就系统都能收到。
它可以检查掉落的物体是不是我们的失足英雄，
他之前有没有做过这种不愉快的与桥的经典力学遭遇。
如果满足条件，就伴着礼花和炫光解锁合适的成就，而这些都无需牵扯到物理代码。</p>
<p>事实上，我们可以改变成就的集合或者删除整个成就系统，而不必修改物理引擎。
它仍然会发送它的通知，哪怕实际没有东西接收。</p>
<blockquote>
<p>当然，如果我们<strong>永久</strong>移除成就，没有任何东西需要物理引擎的通知，
我们也同样可以移除通知代码。但是在游戏的演进中，最好保持这里的灵活性。</p>
</blockquote>
<h2><a class="header" href="#它如何运作" id="它如何运作">它如何运作</a></h2>
<p>如果你还不知道如何实现这个模式，你可能可以从之前的描述中猜到，但是为了减轻你的负担，我还是过一遍代码吧。</p>
<h3><a class="header" href="#观察者" id="观察者">观察者</a></h3>
<p>我们从那个需要知道别的对象做了什么事的类开始。
这些好打听的对象用如下接口定义：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Observer
{
public:
  virtual ~Observer() {}
  virtual void onNotify(const Entity&amp; entity, Event event) = 0;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>onNotify()</code>的参数取决于你。这就是为什么是观察者<strong>模式</strong>，
而不是“可以粘贴到游戏中的真实代码”。
典型的参数是发送通知的对象和一个装入其他细节的“数据”参数。</p>
<p>如果你用泛型或者模板编程，你可能会在这里使用它们，但是根据你的特殊用况裁剪它们也很好。
这里，我将其硬编码为接受一个游戏实体和一个描述发生了什么的枚举。</p>
</blockquote>
<p>任何实现了这个的具体类就成为了观察者。
在我们的例子中，是成就系统，所以我们可以像这样实现：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Achievements : public Observer
{
public:
  virtual void onNotify(const Entity&amp; entity, Event event)
  {
    switch (event)
    {
    case EVENT_ENTITY_FELL:
      if (entity.isHero() &amp;&amp; heroIsOnBridge_)
      {
        unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
      }
      break;

      // 处理其他事件，更新heroIsOnBridge_变量……
    }
  }

private:
  void unlock(Achievement achievement)
  {
    // 如果还没有解锁，那就解锁成就……
  }

  bool heroIsOnBridge_;
};
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#被观察者" id="被观察者">被观察者</a></h3>
<p>被观察的对象拥有通知的方法函数，用 GoF 的说法，那些对象被称为“主题”。
它有两个任务。首先，它有一个列表，保存默默等它通知的观察者：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
private:
  Observer* observers_[MAX_OBSERVERS];
  int numObservers_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>在真实代码中，你会使用动态大小的集合而不是一个定长数组。
在这里，我使用这种最基础的形式是为了那些不了解 C++标准库的人们。</p>
</blockquote>
<p>重点是被观察者暴露了<strong>公开的</strong>API 来修改这个列表：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
public:
  void addObserver(Observer* observer)
  {
    // 添加到数组中……
  }

  void removeObserver(Observer* observer)
  {
    // 从数组中移除……
  }

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>这就允许了外界代码控制谁接收通知。
被观察者与观察者交流，但是不与它们<strong>耦合</strong>。
在我们的例子中，没有一行物理代码会提及成就。
但它仍然可以与成就系统交流。这就是这个模式的聪慧之处。</p>
<p>被观察者有一<strong>列表</strong>观察者而不是单个观察者也是很重要的。
这保证了观察者不会相互干扰。
举个例子，假设音频引擎也需要观察坠落事件来播放合适的音乐。
如果客体只支持单个观察者，当音频引擎注册时，就会<strong>取消</strong>成就系统的注册。</p>
<p>这意味着这两个系统需要相互交互——而且是用一种极其糟糕的方式，
第二个注册时会使第一个的注册失效。
支持一列表的观察者保证了每个观察者都是被独立处理的。
就它们各自的视角来看，自己是这世界上唯一看着被观察者的。</p>
<p>被观察者的剩余任务就是发送通知：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
protected:
  void notify(const Entity&amp; entity, Event event)
  {
    for (int i = 0; i &lt; numObservers_; i++)
    {
      observers_[i]-&gt;onNotify(entity, event);
    }
  }

  // 其他代码…………
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意，代码假设了观察者不会在它们的<code>onNotify()</code>方法中修改观察者列表。
更加可靠的实现方法会阻止或优雅地处理这样的并发修改。</p>
</blockquote>
<h3><a class="header" href="#可被观察的物理系统" id="可被观察的物理系统">可被观察的物理系统</a></h3>
<p>现在，我们只需要给物理引擎和这些挂钩，这样它可以发送消息，
成就系统可以和引擎连线来接受消息。
我们按照传统的<strong>设计模式</strong>方法实现，继承<code>Subject</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Physics : public Subject
{
public:
  void updateEntity(Entity&amp; entity);
};
<span class="boring">}
</span></code></pre></pre>
<p>这让我们将<code>notify()</code>实现为了<code>Subject</code>内的保护方法。
这样派生的物理引擎类可以调用并发送通知，但是外部的代码不行。
同时，<code>addObserver()</code>和<code>removeObserver()</code>是公开的，
所以任何可以接触物理引擎的东西都可以观察它。</p>
<blockquote>
<p>在真实代码中，我会避免使用这里的继承。
相反，我会让<code>Physics</code> <em>有</em> 一个<code>Subject</code>的实例。
不再是观察物理引擎本身，被观察的会是独立的“下落事件”对象。
观察者可以用像这样注册它们自己：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>physics.entityFell()
   .addObserver(this);

<span class="boring">}
</span></code></pre></pre>
<p>对我而言，这是“观察者”系统与“事件”系统的不同之处。
使用前者，你观察<strong>做了有趣事情的事物</strong>。
使用后者，你观察的对象代表了<strong>发生的有趣事情</strong>。</p>
</blockquote>
<p>现在，当物理引擎做了些值得关注的事情，它调用<code>notify()</code>，就像之前的例子。
它遍历了观察者列表，通知所有观察者。</p>
<p><img src="https://gpp.tkchu.me/images/observer-list.png" alt="被观察者包含一列表观察者的指针。前两个指向成就和音频系统。" /></p>
<p>很简单，对吧？只要一个类管理一列表指向接口实例的指针。
难以置信的是，如此直观的东西是无数程序和应用框架交流的主心骨。</p>
<p>观察者模式不是完美无缺的。当我问其他程序员怎么看，他们提出了一些抱怨。
让我们看看可以做些什么来处理这些抱怨。</p>
<h2><a class="header" href="#太慢了" id="太慢了">太慢了</a></h2>
<p>我经常听到这点，通常是从那些不知道模式具体细节的程序员那里。
他们有一种假设，任何东西只要沾到了“设计模式”，那么一定包含了一堆类，跳转和浪费 CPU 循环其他行为。</p>
<p>观察者模式的名声特别坏，一些坏名声的事物与它如影随形，
比如“事件”，“消息”，甚至“数据绑定”。
其中的一些系统<strong>确实会</strong>慢。（通常是故意的，出于好的意图）。
他们使用队列，或者为每个通知动态分配内存。</p>
<blockquote>
<p>这就是为什么我认为设计模式文档化很重要。
当我们没有统一的术语，我们就失去了简洁明确表达的能力。
你说“观察者”，我以为是“事件”，他以为是“消息”，
因为没人花时间记下差异，也没人阅读。</p>
<p>而那就是在这本书中我要做的。
本书中也有一章关于事件和消息：<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">事件队列</a>.</p>
</blockquote>
<p>现在你看到了模式是如何真正被实现的，
你知道事实并不如他们所想的这样。
发送通知只需简单地遍历列表，调用一些虚方法。
是的，这比静态调用慢<strong>一点</strong>，除非是性能攸关的代码，否则这点消耗都是微不足道的。</p>
<p>我发现这个模式在代码性能瓶颈以外的地方能有很好的应用，
那些你可以承担动态分配消耗的地方。
除那以外，使用它几乎毫无限制。
我们不必为消息分配对象，也无需使用队列。这里只多了一个用在同步方法调用上的额外跳转。</p>
<h3><a class="header" href="#太快" id="太快">太<strong>快</strong></a></h3>
<p>事实上，你得小心，观察者模式<strong>是</strong>同步的。
被观察者直接调用了观察者，这意味着直到所有观察者的通知方法返回后，
被观察者才会继续自己的工作。观察者会阻塞被观察者的运行。</p>
<p>这听起来很疯狂，但在实践中，这可不是世界末日。
这只是值得注意的事情。
UI 程序员——那些使用基于事件的编程的程序员已经这么干了很多年了——有句经典名言：</p>
<blockquote>
<blockquote>
<p>“远离 UI 线程”。</p>
</blockquote>
</blockquote>
<p>如果要对事件同步响应，你需要完成响应，尽可能快地返回，这样 UI 就不会锁死。
当你有耗时的操作要执行时，将这些操作推到另一个线程或工作队列中去。</p>
<p>你需要小心地在观察者中混合线程和锁。
如果观察者试图获得被观察者拥有的锁，游戏就进入死锁了。
在多线程引擎中，你最好使用<a href="06-2%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97.html">事件队列</a>来做异步通信。</p>
<h2><a class="header" href="#它做了太多动态分配" id="它做了太多动态分配">“它做了太多动态分配”</a></h2>
<p>整个程序员社区——包括很多游戏开发者——转向了拥有垃圾回收机制的语言，
动态分配今昔非比。
但在像游戏这样性能攸关的软件中，哪怕是在有垃圾回收机制的语言，内存分配也依然重要。
动态分配需要时间，回收内存也需要时间，哪怕是自动运行的。</p>
<blockquote>
<p>很多游戏开发者不怎么担心分配,但很担心<strong>分页</strong>。
当游戏需要不崩溃地连续运行多日来获得发售资格，不断增加的分页堆会影响游戏的发售。</p>
</blockquote>
<p><a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池模式</a>一章介绍了避免这点的常用技术，以及更多其他细节。</p>
<p>在上面的示例代码中，我使用的是定长数组，因为我想尽可能保证简单。
在真实的项目中中，观察者列表随着观察者的添加和删除而动态地增长和缩短。
这种内存的分配吓坏了一些人。</p>
<p>当然，第一件需要注意的事情是只在观察者加入时分配内存。
<strong>发送</strong>通知无需内存分配——只需一个方法调用。
如果你在游戏一开始就加入观察者而不乱动它们，分配的总量是很小的。</p>
<p>如果这仍然困扰你，我会介绍一种无需任何动态分配的方式来增加和删除观察者。</p>
<h3><a class="header" href="#链式观察者" id="链式观察者">链式观察者</a></h3>
<p>我们现在看到的所有代码中，<code>Subject</code>拥有一列指针指向观察它的<code>Observer</code>。
<code>Observer</code>类本身没有对这个列表的引用。
它是纯粹的虚接口。优先使用接口，而不是有状态的具体类，这大体上是一件好事。</p>
<p>但是如果我们<strong>确实</strong>愿意在<code>Observer</code>中放一些状态，
我们可以将观察者的列表分布到<strong>观察者自己</strong>中来解决动态分配问题。
不是被观察者保留一列表分散的指针，观察者对象本身成为了链表中的一部分：</p>
<p><img src="https://gpp.tkchu.me/images/observer-linked.png" alt="一个观察者的列表。每个都有一个next_字段指向下一个。被观察者有一个head_字段指向首个观察者。" /></p>
<p>为了实现这一点，我们首先要摆脱<code>Subject</code>中的数组，然后用链表头部的指针取而代之：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Subject
{
  Subject()
  : head_(NULL)
  {}

  // 方法……
private:
  Observer* head_;
};
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们在<code>Observer</code>中添加指向链表中下一观察者的指针。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Observer
{
  friend class Subject;

public:
  Observer()
  : next_(NULL)
  {}

  // 其他代码……
private:
  Observer* next_;
};
<span class="boring">}
</span></code></pre></pre>
<p>这里我们也让<code>Subject</code>成为了友类。
被观察者拥有增删观察者的 API，但是现在链表在<code>Observer</code>内部管理。
最简单的实现办法就是让被观察者类成为友类。</p>
<p>注册一个新观察者就是将其连到链表中。我们用更简单的实现方法，将其插到开头：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Subject::addObserver(Observer* observer)
{
  observer-&gt;next_ = head_;
  head_ = observer;
}
<span class="boring">}
</span></code></pre></pre>
<p>另一个选项是将其添加到链表的末尾。这么做增加了一定的复杂性。
<code>Subject</code>要么遍历整个链表来找到尾部，要么保留一个单独<code>tail_</code>指针指向最后一个节点。</p>
<p>加在在列表的头部很简单，但也有另一副作用。
当我们遍历列表给每个观察者发送一个通知，
最<strong>新</strong>注册的观察者最<strong>先</strong>接到通知。
所以如果以 A，B，C 的顺序来注册观察者，它们会以 C，B，A 的顺序接到通知。</p>
<p>理论上，这种还是那种方式没什么差别。
在好的观察者设计中，观察同一被观察者的两个观察者互相之间不该有任何顺序相关。
如果顺序<strong>确实</strong>有影响，这意味着这两个观察者有一些微妙的耦合，最终会害了你。</p>
<p>让我们完成删除操作：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Subject::removeObserver(Observer* observer)
{
  if (head_ == observer)
  {
    head_ = observer-&gt;next_;
    observer-&gt;next_ = NULL;
    return;
  }

  Observer* current = head_;
  while (current != NULL)
  {
    if (current-&gt;next_ == observer)
    {
      current-&gt;next_ = observer-&gt;next_;
      observer-&gt;next_ = NULL;
      return;
    }

    current = current-&gt;next_;
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>如你所见，从链表移除一个节点通常需要处理一些丑陋的特殊情况，应对头节点。
还可以使用指针的指针，实现一个更优雅的方案。</p>
<p>我在这里没有那么做，是因为半数看到这个方案的人都迷糊了。
但这是一个很值得做的练习：它能帮助你深入思考指针。</p>
</blockquote>
<p>因为使用的是链表，所以我们得遍历它才能找到要删除的观察者。
如果我们使用普通的数组，也得做相同的事。
如果我们使用<strong>双向</strong>链表，每个观察者都有指向前面和后面的指针，
就可以用常量时间移除观察者。在实际项目中，我会这样做。</p>
<p>剩下的事情只有发送通知了，这和遍历列表同样简单；</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Subject::notify(const Entity&amp; entity, Event event)
{
  Observer* observer = head_;
  while (observer != NULL)
  {
    observer-&gt;onNotify(entity, event);
    observer = observer-&gt;next_;
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里，我们遍历了整个链表，通知了其中每一个观察者。
这保证了所有的观察者相互独立并有同样的优先级。</p>
<p>我们可以这样实现，当观察者接到通知，它返回了一个标识，表明被观察者是否应该继续遍历列表。
如果这样做，你就接近了<a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">职责链模式</a>。</p>
</blockquote>
<p>不差嘛，对吧？被观察者现在想有多少观察者就有多少观察者，无需动态内存。
注册和取消注册就像使用简单数组一样快。
但是，我们牺牲了一些小小的功能特性。</p>
<p>由于我们使用观察者对象作为链表节点，这暗示它只能存在于一个观察者链表中。
换言之，一个观察者一次只能观察一个被观察者。
在传统的实现中，每个被观察者有独立的列表，一个观察者同时可以存在于多个列表中。</p>
<p>你也许可以接受这一限制。
通常是一个<strong>被观察者</strong>有多个<strong>观察者</strong>，反过来就很少见了。
如果这<strong>真是</strong>一个问题，这里还有一种不必使用动态分配的解决方案。
详细介绍的话，这章就太长了，但我会大致描述一下，其余的你可以自行填补……</p>
<h3><a class="header" href="#链表节点池" id="链表节点池">链表节点池</a></h3>
<p>就像之前，每个被观察者有一链表的观察者。
但是，这些链表节点不是观察者本身。
相反，它们是分散的小“链表节点”对象，
包含了指向观察者的指针和指向链表下一节点的指针。</p>
<p><img src="https://gpp.tkchu.me/images/observer-nodes.png" alt="一链表的节点。每个节点都有一个observer_字段指向观察者，一个next_字段指向列表中的下一个节点。被观察者的head_字段指向第一个节点。" /></p>
<p>由于多个节点可以指向同一观察者，这就意味着观察者可以同时在超过多个被观察者的列表中。
我们可以同时观察多个对象了。</p>
<blockquote>
<p>链表有两种风格。学校教授的那种，节点对象包含数据。
在我们之前的观察者链表的例子中，是另一种：<em>数据</em>（这个例子中是观察者）包含了<strong>节点</strong>（<code>next_</code>指针）。</p>
<p>后者的风格被称为“侵入式”链表，因为在对象内部使用链表侵入了对象本身的定义。
侵入式链表灵活性更小，但如我们所见，也更有效率。
在 Linux 核心这样的地方这种风格很流行。</p>
</blockquote>
<p>避免动态分配的方法很简单：由于这些节点都是同样大小和类型，
可以预先在<a href="07-3%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F.html">对象池</a>中分配它们。
这样你只需处理固定大小的列表节点，可以随你所需使用和重用，
而无需牵扯到真正的内存分配器。</p>
<h2><a class="header" href="#剩余的问题" id="剩余的问题">剩余的问题</a></h2>
<p>我认为该模式将人们吓阻的三个主要问题已经被搞定了。
它简单，快速，对内存管理友好。
但是这意味着你总该使用观察者吗？</p>
<p>现在，这是另一个的问题。
就像所有的设计模式，观察者模式不是万能药。
哪怕可以正确高效地的实现，它也不一定是好的解决方案。
设计模式声名狼藉的原因之一就是人们将好模式用在错误的问题上，得到了糟糕的结果。</p>
<p>还有两个挑战，一个是关于技术，另一个更偏向于可维护性。
我们先处理关于技术的挑战，因为关于技术的问题总是更容易处理。</p>
<h3><a class="header" href="#销毁被观察者和观察者" id="销毁被观察者和观察者">销毁被观察者和观察者</a></h3>
<p>我们看到的样例代码健壮可用，但有一个严重的副作用：
当删除一个被观察者或观察者时会发生什么？
如果你不小心在某些观察者上面调用了<code>delete</code>，被观察者也许仍然持有指向它的指针。
那是一个指向一片已释放区域的悬空指针。
当被观察者试图发送一个通知，额……就说发生的事情会出乎你的意料之外吧。</p>
<blockquote>
<p>不是谴责，但我注意到<strong>设计模式</strong>完全没提这个问题。</p>
</blockquote>
<p>删除被观察者更容易些，因为在大多数实现中，观察者没有对它的引用。
但是即使这样，将被观察者所占的字节直接回收可能还是会造成一些问题。
这些观察者也许仍然期待在以后收到通知，而这是不可能的了。
它们没法继续观察了，真的，它们只是认为它们可以。</p>
<p>你可以用好几种方式处理这点。
最简单的就是像我做的那样，以后一脚踩空。
在被删除时取消注册是观察者的职责。
多数情况下，观察者<strong>确实</strong>知道它在观察哪个被观察者，
所以通常需要做的只是给它的析构器添加一个<code>removeObserver()</code>。</p>
<blockquote>
<p>通常在这种情况下，难点不在如何做，而在<strong>记得</strong>做。</p>
</blockquote>
<p>如果在删除被观察者时，你不想让观察者处理问题，这也很好解决。
只需要让被观察者在它被删除前发送一个最终的“死亡通知”。
这样，任何观察者都可以接收到，然后做些合适的行为。</p>
<blockquote>
<p>默哀，献花，挽歌……</p>
</blockquote>
<p>人——哪怕是那些花费在大量时间在机器前，拥有让我们黯然失色的才能的人——也是绝对不可靠的。
这就是为什么我们发明了电脑：它们不像我们那样经常犯错误。</p>
<p>更安全的方案是在每个被观察者销毁时，让观察者自动取消注册。
如果你在观察者基类中实现了这个逻辑，每个人不必记住就可以使用它。
这确实增加了一定的复杂度。
这意味着每个<strong>观察者</strong>都需要有它在观察的<strong>被观察者</strong>的列表。
最终维护一个双向指针。</p>
<h3><a class="header" href="#别担心我有垃圾回收器" id="别担心我有垃圾回收器">别担心，我有垃圾回收器</a></h3>
<p>你们那些装备有垃圾回收系统的孩子现在一定很洋洋自得。
觉得你不必担心这个，因为你从来不必显式删除任何东西？再仔细想想！</p>
<p>想象一下：你有 UI 显示玩家角色情况的状态，比如健康和道具。
当玩家在屏幕上时，你为其初始化了一个对象。
当 UI 退出时，你直接忘掉这个对象，交给 GC 清理。</p>
<p>每当角色脸上（或者其他什么地方）挨了一拳，就发送一个通知。
UI 观察到了，然后更新健康槽。很好。
当玩家离开场景，但你没有取消观察者的注册，会发生什么？</p>
<p>UI 界面不再可见，但也不会进入垃圾回收系统，因为角色的观察者列表还保存着对它的引用。
每一次场景加载后，我们给那个不断增长的观察者列表添加一个新实例。</p>
<p>玩家玩游戏时，来回跑动，打架，角色的通知发送给<strong>所有</strong>的界面。
它们不在屏幕上，但它们接受通知，这样就浪费 CPU 循环在不可见的 UI 元素上了。
如果它们会播放声音之类的，这样的错误就会被人察觉。</p>
<p>这在通知系统中非常常见，甚至专门有个名字：<em>失效监听者问题</em>。
由于被观察者保留了对观察者的引用，最终有 UI 界面对象僵死在内存中。
这里的教训是要及时删除观察者。</p>
<blockquote>
<p>它甚至有专门的<a href="http://en.wikipedia.org/wiki/Lapsed_listener_problem">维基条目</a>。</p>
</blockquote>
<h3><a class="header" href="#然后呢" id="然后呢">然后呢</a></h3>
<p>观察者的另一个深层次问题是它的意图直接导致的。
我们使用它是因为它帮助我们放松了两块代码之间的耦合。
它让被观察者与没有静态绑定的观察者间接交流。</p>
<p>当你要理解被观察者的行为时，这很有价值，任何不相关的事情都是在分散注意力。
如果你在处理物理引擎，你根本不想要编辑器——或者你的大脑——被一堆成就系统的东西而搞糊涂。</p>
<p>另一方面，如果你的程序没能运行，漏洞散布在多个观察者之间，理清信息流变得更加困难。
显式耦合中更易于查看哪一个方法被调用了。
这是因为耦合是静态的，IDE 分析它轻而易举。</p>
<p>但是如果耦合发生在观察者列表中，想要知道哪个观察者被通知到了，唯一的办法是看看哪个观察者在列表中，而且<strong>处于运行中</strong>。
你得理清它的<strong>命令式，动态</strong>行为而非理清程序的<strong>静态</strong>交流结构。</p>
<p>处理这个的指导原则很简单。
如果为了理解程序的一部分，两个交流的模块<strong>都</strong>需要考虑，
那就不要使用观察者模式，使用其他更加显式的东西。</p>
<p>当你在某些大型程序上用黑魔法时，你会感觉这样处理很笨拙。
我们有很多术语用来描述，比如“关注点分离”，“一致性和内聚性”和“模块化”，
总归就是“这些东西待在一起，而不是与那些东西待在一起。”</p>
<p>观察者模式是一个让这些不相关的代码块互相交流，而不必打包成更大的块的好方法。
这在专注于一个特性或层面的单一代码块<strong>内</strong>不会太有用。</p>
<p>这就是为什么它能很好地适应我们的例子：
成就和物理是几乎完全不相干的领域，通常被不同的人实现。
我们想要它们之间的交流最小化，
这样无论在哪一个上工作都不需要另一个的太多信息。</p>
<h2><a class="header" href="#今日观察者" id="今日观察者">今日观察者</a></h2>
<p><strong>设计模式</strong>源于 1994。
那时候，面向对象语言<strong>正是</strong>热门的编程范式。
每个程序员都想要“30 天学会面向对象编程”，
中层管理员根据程序员创建类的数量为他们支付工资。
工程师通过继承层次的深度评价代码质量。</p>
<blockquote>
<p>同一年，Ace of Base 的畅销单曲发行了<strong>三首</strong>而不是一首，这也许能让你了解一些我们那时的品味和洞察力。</p>
</blockquote>
<p>观察者模式在那个时代中很流行，所以构建它需要很多类就不奇怪了。
但是现代的主流程序员更加适应函数式语言。
实现一整套接口只是为了接受一个通知不再符合今日的美学了。</p>
<p>它看上去是又沉重又死板。它<strong>确实</strong>又沉重又死板。
举个例子，在观察者类中，你不能为不同的被观察者调用不同的通知方法。</p>
<blockquote>
<p>这就是为什么被观察者经常将自身传给观察者。
观察者只有单一的<code>onNotify()</code>方法，
如果它观察多个被观察者，它需要知道哪个被观察者在调用它的方法。</p>
</blockquote>
<p>现代的解决办法是让“观察者”只是对方法或者函数的引用。
在函数作为第一公民的语言中，特别是那些有闭包的，
这种实现观察者的方式更为普遍。</p>
<blockquote>
<p>今日，几乎<strong>每种</strong>语言都有闭包。C++克服了在没有垃圾回收的语言中构建闭包的挑战，甚至 Java 都在 JDK8 中引入了闭包。</p>
</blockquote>
<p>举个例子，C#有“事件”嵌在语言中。
通过这样，观察者是一个“委托”，
（“委托”是方法的引用在 C#中的术语）。
在 JavaScript 事件系统中，观察者<strong>可以</strong>是支持了特定<code>EventListener</code>协议的类，
但是它们也可以是函数。
后者是人们常用的方式。</p>
<p>如果设计今日的观察者模式，我会让它基于函数而不是基于类。
哪怕是在 C++中，我倾向于让你注册一个成员函数指针作为观察者，而不是<code>Observer</code>接口的实例。</p>
<blockquote>
<p><a href="http://molecularmusings.wordpress.com/2011/09/19/generic-type-safe-delegates-and-events-in-c/">这里</a>的一篇有趣博文以某种方式在 C++上实现了这一点。</p>
</blockquote>
<h2><a class="header" href="#明日观察者" id="明日观察者">明日观察者</a></h2>
<p>事件系统和其他类似观察者的模式如今遍地都是。
它们都是成熟的方案。
但是如果你用它们写一个稍微大一些的应用，你会发现一件事情。
在观察者中很多代码最后都长得一样。通常是这样：</p>
<ol>
<li>获知有状态改变了。</li>
<li>下命令改变一些 UI 来反映新的状态。</li>
</ol>
<p>就是这样，“哦，英雄的健康现在是 7 了？让我们把血条的宽度设为 70 像素。
过上一段时间，这会变得很沉闷。
计算机科学学术界和软件工程师已经用了<strong>很长</strong>时间尝试结束这种状况了。
这些方式被赋予了不同的名字：“数据流编程”，“函数反射编程”等等。</p>
<p>即使有所突破，一般也局限在特定的领域中，比如音频处理或芯片设计，我们还没有找到万能钥匙。
与此同时，一个更脚踏实地的方式开始获得成效。那就是现在的很多应用框架使用的“数据绑定”。</p>
<p>不像激进的方式，数据绑定不再指望完全终结命令式代码，
也不尝试基于巨大的声明式数据图表架构整个应用。
它做的只是自动改变 UI 元素或计算某些数值来反映一些值的变化。</p>
<p>就像其他声明式系统，数据绑定也许太慢，嵌入游戏引擎的核心也太复杂。
但是如果说它不会侵入游戏不那么性能攸关的部分，比如 UI，那我会很惊讶。</p>
<p>与此同时，经典观察者模式仍然在那里等着我们。
是的，它不像其他的新热门技术一样在名字中填满了“函数”，“反射”，
但是它超简单而且能正常工作。对我而言，这通常是解决方案最重要的条件。</p>
<h1><a class="header" href="#原型模式" id="原型模式">原型模式</a></h1>
<p>我第一次听到“原型”这个词是在<strong>设计模式</strong>中。
如今，似乎每个人都在用这个词，但他们讨论的实际上不是<a href="http://en.wikipedia.org/wiki/Prototype_pattern">设计模式</a>。
我们会讨论他们所说的原型，也会讨论术语“原型”的有趣之处，和其背后的理念。
但首先，让我们重访传统的设计模式。</p>
<blockquote>
<p>“传统的”一词可不是随便用的。</p>
<p><strong>设计模式</strong>引自<strong>1963 年</strong> Ivan Sutherland 的<a href="http://en.wikipedia.org/wiki/Sketchpad">Sketchpad</a>传奇项目，那是这个模式首次出现。
当其他人在听迪伦和甲壳虫乐队时，Sutherland 正忙于，你知道的，发明 CAD，交互图形和面向对象编程的基本概念。</p>
<p>看看这个<a href="http://www.youtube.com/watch?v=USyoT_Ha_bA">demo</a>，跪服吧。</p>
</blockquote>
<h2><a class="header" href="#原型设计模式" id="原型设计模式">原型设计模式</a></h2>
<p>假设我们要用《圣铠传说》的风格做款游戏。
野兽和恶魔围绕着英雄，争着要吃他的血肉。
这些可怖的同行者通过“生产者”进入这片区域，每种敌人有不同的生产者。</p>
<p>在这个例子中，假设我们游戏中每种怪物都有不同的类——<code>Ghost</code>，<code>Demon</code>，<code>Sorcerer</code>等等，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Monster
{
  // 代码……
};

class Ghost : public Monster {};
class Demon : public Monster {};
class Sorcerer : public Monster {};
<span class="boring">}
</span></code></pre></pre>
<p>生产者构造特定种类怪物的实例。
为了在游戏中支持每种怪物，我们<strong>可以</strong>用一种暴力的实现方法，
让每个怪物类都有生产者类，得到平行的类结构：</p>
<p><img src="https://gpp.tkchu.me/images/prototype-hierarchies.png" alt="平行的类结构，恶灵，恶魔，巫师都继承怪物。恶灵生产者。恶魔生产者，巫师生产者都继承生产者。" /></p>
<blockquote>
<p>我得翻出落满灰尘的 UML 书来画这个图表。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/arrow-inherits.png" alt="一个UML箭头" />代表“继承”。</p>
<p>实现后看起来像是这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Spawner
{
public:
  virtual ~Spawner() {}
  virtual Monster* spawnMonster() = 0;
};

class GhostSpawner : public Spawner
{
public:
  virtual Monster* spawnMonster()
  {
    return new Ghost();
  }
};

class DemonSpawner : public Spawner
{
public:
  virtual Monster* spawnMonster()
  {
    return new Demon();
  }
};

// 你知道思路了……
<span class="boring">}
</span></code></pre></pre>
<p>除非你会根据代码量来获得工资，
否则将这些焊在一起很明显不是好方法。
众多类，众多引用，众多冗余，众多副本，众多重复自我……</p>
<p>原型模式提供了一个解决方案。
关键思路是<strong>一个对象可以产出与它自己相近的对象。</strong>
如果你有一个恶灵，你可以制造更多恶灵。
如果你有一个恶魔，你可以制造其他恶魔。
任何怪物都可以被视为<strong>原型</strong>怪物，产出其他版本的自己。</p>
<p>为了实现这个功能，我们给基类<code>Monster</code>添加一个抽象方法<code>clone()</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Monster
{
public:
  virtual ~Monster() {}
  virtual Monster* clone() = 0;

  // 其他代码……
};
<span class="boring">}
</span></code></pre></pre>
<p>每个怪兽子类提供一个特定实现，返回与它自己的类和状态都完全一样的新对象。举个例子：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Ghost : public Monster {
public:
  Ghost(int health, int speed)
  : health_(health),
    speed_(speed)
  {}

  virtual Monster* clone()
  {
    return new Ghost(health_, speed_);
  }

private:
  int health_;
  int speed_;
};
<span class="boring">}
</span></code></pre></pre>
<p>一旦我们所有的怪物都支持这个，
我们不再需要为每个怪物类创建生产者类。我们只需定义一个类：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Spawner
{
public:
  Spawner(Monster* prototype)
  : prototype_(prototype)
  {}

  Monster* spawnMonster()
  {
    return prototype_-&gt;clone();
  }

private:
  Monster* prototype_;
};
<span class="boring">}
</span></code></pre></pre>
<p>它内部存有一个怪物，一个隐藏的怪物，
它唯一的任务就是被生产者当做模板，去产生更多一样的怪物，
有点像一个从来不离开巢穴的蜂后。</p>
<p><img src="https://gpp.tkchu.me/images/prototype-spawner.png" alt="一个生产者包含一个对怪物应用的原型字段。他调用原型的clone()方法来产生新的怪物。" /></p>
<p>为了得到恶灵生产者，我们创建一个恶灵的原型实例，然后创建拥有这个实例的生产者：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Monster* ghostPrototype = new Ghost(15, 3);
Spawner* ghostSpawner = new Spawner(ghostPrototype);
<span class="boring">}
</span></code></pre></pre>
<p>这个模式的灵巧之处在于它不但拷贝原型的<strong>类</strong>，也拷贝它的<strong>状态</strong>。
这就意味着我们可以创建一个生产者，生产快速鬼魂，虚弱鬼魂，慢速鬼魂，而只需创建一个合适的原型鬼魂。</p>
<p>我在这个模式中找到了一些既优雅又令人惊叹的东西。
我无法想象自己是如何创造出它们的，但我更无法想象<strong>不知道</strong>这些东西的自己该如何是好。</p>
<h3><a class="header" href="#效果如何" id="效果如何">效果如何</a></h3>
<p>好吧，我们不需要为每个怪物创建单独的生产者类，那很好。
但我们<strong>确实</strong>需要在每个怪物类中实现<code>clone()</code>。
这和使用生产者方法比起来也没节约多少代码量。</p>
<p>当你坐下来试着写一个正确的<code>clone()</code>，会遇见令人不快的语义漏洞。
做深层拷贝还是浅层拷贝呢？换言之，如果恶魔拿着叉子，克隆恶魔也要克隆叉子吗？</p>
<p>同时，这看上去没减少已存问题上的代码，
事实上还增添了些<strong>人为的问题</strong>。
我们需要将每个怪物有独立的类作为前提条件。
这绝对<strong>不是</strong>当今大多数游戏引擎运作的方法。</p>
<p>我们中大部分痛苦地学到，这样庞杂的类层次管理起来很痛苦，
那就是我们为什么用<a href="06-1%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F.html">组件模式</a>和<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>为不同的实体建模，这样无需一一建构自己的类。</p>
<h3><a class="header" href="#生产函数" id="生产函数">生产函数</a></h3>
<p>哪怕我们确实需要为每个怪物构建不同的类，这里还有其他的实现方法。
不是使用为每个怪物建立分离的生产者<strong>类</strong>，我们可以创建生产<strong>函数</strong>，就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Monster* spawnGhost()
{
  return new Ghost();
}
<span class="boring">}
</span></code></pre></pre>
<p>这比构建怪兽生产者类更简洁。生产者类只需简单地存储一个函数指针：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>typedef Monster* (*SpawnCallback)();

class Spawner
{
public:
  Spawner(SpawnCallback spawn)
  : spawn_(spawn)
  {}

  Monster* spawnMonster()
  {
    return spawn_();
  }

private:
  SpawnCallback spawn_;
};
<span class="boring">}
</span></code></pre></pre>
<p>为了给恶灵构建生产者，你需要做：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Spawner* ghostSpawner = new Spawner(spawnGhost);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#模板" id="模板">模板</a></h3>
<p>如今，大多数 C++开发者已然熟悉模板了。
生产者类需要为某类怪物构建实例，但是我们不想硬编码是哪类怪物。
自然的解决方案是将它作为模板中的<strong>类型参数</strong>：</p>
<blockquote>
<p>我不太确定程序员是学着喜欢 C++模板还是完全畏惧并远离了 C++。
不管怎样，今日我见到的程序员中，使用 C++的也都会使用模板。</p>
<p>这里的<code>Spawner</code>类不必考虑将生产什么样的怪物，
它总与指向<code>Monster</code>的指针打交道。</p>
<p>如果我们只有<code>SpawnerFor&lt;T&gt;</code>类，模板类型没有办法共享父模板，
这样的话，如果一段代码需要与产生多种怪物类型的生产者打交道，就都得接受模板参数。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Spawner
{
public:
  virtual ~Spawner() {}
  virtual Monster* spawnMonster() = 0;
};

template &lt;class T&gt;
class SpawnerFor : public Spawner
{
public:
  virtual Monster* spawnMonster() { return new T(); }
};
<span class="boring">}
</span></code></pre></pre>
<p>像这样使用它：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Spawner* ghostSpawner = new SpawnerFor&lt;Ghost&gt;();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第一公民类型" id="第一公民类型">第一公民类型</a></h3>
<p>前面的两个解决方案使用类完成了需求，<code>Spawner</code>使用类型进行参数化。
在 C++中，类型不是第一公民，所以需要一些改动。
如果你使用 JavaScript，Python，或者 Ruby 这样的动态类型语言，
它们的类<strong>是</strong>可以传递的对象，你可以用更直接的办法解决这个问题。</p>
<blockquote>
<p>某种程度上，<a href="05-3%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1.html">类型对象</a>也是为了弥补第一公民类型的缺失。
但那个模式在拥有第一公民类型的语言中也有用，因为它让<strong>你</strong>决定什么是“类型”。
你也许想要与语言内建的类不同的语义。</p>
</blockquote>
<p>当你完成一个生产者，直接向它传递要构建的怪物类——那个代表了怪物类的运行时对象。超容易的，对吧。</p>
<p>综上所述，老实说，我不能说找到了一种情景，而在这个情景下，原型<strong>设计模式</strong>是最好的方案。
也许你的体验有所不同，但现在把它搁到一边，我们讨论点别的：将原型作为一种<strong>语言范式</strong>。</p>
<h2><a class="header" href="#原型语言范式" id="原型语言范式">原型语言范式</a></h2>
<p>很多人认为“面向对象编程”和“类”是同义词。
OOP 的定义却让人感觉正好相反，
毫无疑问，<em>OOP 让你定义“对象”，将数据和代码绑定在一起。</em>
与 C 这样的结构化语言相比，与 Scheme 这样的函数语言相比，
OOP 的特性是它将状态和行为紧紧地绑在一起。</p>
<p>你也许认为类是完成这个的唯一方式方法，
但是包括 Dave Ungar 和 Randall Smith 的一大堆家伙一直在拼命区分 OOP 和类。
他们在 80 年代创建了一种叫做 Self 的语言。它不用类实现了 OOP。</p>
<h3><a class="header" href="#self-语言" id="self-语言">Self 语言</a></h3>
<p>就单纯意义而言，Self 比基于类的语言<strong>更加</strong>面向对象。
我们认为 OOP 将状态和行为绑在一起，但是基于类的语言实际将状态和行为割裂开来。</p>
<p>拿你最喜欢的基于类的语言的语法来说。
为了接触对象中的一些状态，你需要在实例的内存中查询。状态<strong>包含</strong>在实例中。</p>
<p>但是，为了调用方法，你需要找到实例的类，
然后在<strong>那里</strong>调用方法。行为包含在<strong>类</strong>中。
获得方法总需要通过中间层，这意味着字段和方法是不同的。</p>
<p><img src="https://gpp.tkchu.me/images/prototype-class.png" alt="一个类，包含了一系列方法。一个实例，包含了一系列字段和指向类的指针。" /></p>
<blockquote>
<p>举个例子，为了调用 C++中的虚方法，你需要在实例中找指向虚方法表的指针，然后再在那里找方法。</p>
</blockquote>
<p>Self 结束了这种分歧。<em>无论你要找啥</em>，都只需在对象中找。
实例同时包含状态和行为。你可以构建拥有完全独特方法的对象。</p>
<p><img src="https://gpp.tkchu.me/images/prototype-object.png" alt="一个对象中同时包含了字段和方法。" /></p>
<blockquote>
<p>没有人能与世隔绝，但这个对象是。</p>
</blockquote>
<p>如果这就是 Self 语言的全部，那它将很难使用。
基于类的语言中的继承，不管有多少缺陷，总归提供了有用的机制来重用代码，避免重复。
为了不使用类而实现一些类似的功能，Self 语言加入了<strong>委托（delegation）</strong>。</p>
<p>如果要在对象中寻找字段或者调用方法，首先在对象内部查找。
如果能找到，那就成了。如果找不到，在对象的<strong>父对象</strong>中寻找。
这里的父类仅仅是一个对其他对象的引用。
当我们没能在第一个对象中找到属性，我们尝试它的父对象，然后父类的父对象，继续下去直到找到或者没有父对象为止。
换言之，失败的查找被<strong>委托</strong>给对象的父对象。</p>
<blockquote>
<p>我在这里简化了。Self 实际上支持多个父对象。
父对象只是特别标明的字段，意味着你可以继承它们或者在运行时改变他们，
你最终得到了“动态继承”。</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/prototype-delegate.png" alt="一个对象包含了字段和方法，以及一个指向委托对象的指针。" /></p>
<p>父对象让我们在不同对象间重用行为（还有状态！），这样就完成了类的公用功能。
类做的另一个关键事情就是给出了创建实例的方法。
当你需要新的某物，你可以直接<code>new Thingamabob()</code>，或者随便什么你喜欢的表达法。
类是实例的生产工厂。</p>
<p>不用类，我们怎样创建新的实例？
特别地，我们如何创建一堆有共同点的新东西？
就像这个设计模式，在 Self 中，达到这点的方式是使用<strong>克隆</strong>。</p>
<p>在 Self 语言中，就好像<strong>每个</strong>对象都自动支持原型设计模式。
任何对象都能被克隆。为了获得一堆相似的对象，你：</p>
<ol>
<li>将对象塑造成你想要的状态。你可以直接克隆系统内建的基本<code>Object</code>，然后向其中添加字段和方法。</li>
<li>克隆它来产出……额……随你想要多少就克隆多少个对象。</li>
</ol>
<p>无需烦扰自己实现<code>clone()</code>；我们就实现了优雅的原型模式，原型被内建在系统中。</p>
<p>这个系统美妙，灵巧，而且小巧，
一听说它，我就开始创建一个基于原型的语言来进一步学习。</p>
<blockquote>
<p>我知道从头开始构建一种编程语言语言不是学习它最有效率的办法，但我能说什么呢？我可算是个怪人。
如果你很好奇，我构建的语言叫<a href="http://finch.stuffwithstuff.com/">Finch</a>.</p>
</blockquote>
<h3><a class="header" href="#它的实际效果如何" id="它的实际效果如何">它的实际效果如何</a></h3>
<p>能使用纯粹基于原型的语言让我很兴奋，但是当我真正上手时，
我发现了一个令人不快的事实：用它编程没那么有趣。</p>
<blockquote>
<p>从小道消息中，我听说很多 Self 程序员得出了相同的结论。
但这项目并不是一无是处。
Self 非常的灵活，为此创造了很多虚拟机的机制来保持高速运行。</p>
<p>他们发明了 JIT 编译，垃圾回收，以及优化方法分配——这都是由同一批人实现的——
这些新玩意让动态类型语言能快速运行，构建了很多大受欢迎的应用。</p>
</blockquote>
<p>是的，语言本身很容易实现，那是因为它把复杂度甩给了用户。
一旦开始试着使用这语言，我发现我想念基于类语言中的层次结构。
最终，在构建语言缺失的库概念时，我放弃了。</p>
<p>鉴于我之前的经验都来自基于类的语言，因此我的头脑可能已经固定在它的范式上了。
但是直觉上，我认为大部分人还是喜欢有清晰定义的“事物”。</p>
<p>除去基于类的语言自身的成功以外，看看有多少游戏用类建模描述玩家角色，以及不同的敌人、物品、技能。
不是游戏中的每个怪物都与众不同，你不会看到“洞穴人和哥布林还有雪混合在一起”这样的怪物。</p>
<p>原型是非常酷的范式，我希望有更多人了解它，
但我很庆幸不必天天用它编程。
完全皈依原型的代码是一团浆糊，难以阅读和使用。</p>
<blockquote>
<p>这同时证明，<em>很少</em> 有人使用原型风格的代码。我查过了。</p>
</blockquote>
<h3><a class="header" href="#javascript-又怎么样呢" id="javascript-又怎么样呢">JavaScript 又怎么样呢？</a></h3>
<p>好吧，如果基于原型的语言不那么友好，怎么解释 JavaScript 呢？
这是一个有原型的语言，每天被数百万人使用。运行 JavaScript 的机器数量超过了地球上其他所有的语言。</p>
<p>Brendan Eich，JavaScript 的缔造者，从 Self 语言中直接汲取灵感，很多 JavaScript 的语义都是基于原型的。
每个对象都有属性的集合，包含字段和“方法”（事实上只是存储为字段的函数）。
A 对象可以拥有 B 对象，B 对象被称为 A 对象的“原型”，
如果 A 对象的字段获取失败就会委托给 B 对象。</p>
<blockquote>
<p>作为语言设计者，原型的诱人之处是它们比类更易于实现。
Eich 充分利用了这一点，他在十天内创建了 JavaScript 的第一个版本。</p>
</blockquote>
<p>但除那以外，我相信在实践中，JavaScript 更像是基于类的而不是基于原型的语言。
JavaScript 与 Self 有所偏离，其中一个要点是除去了基于原型语言的核心操作“克隆”。</p>
<p>在 JavaScript 中没有方法来克隆一个对象。
最接近的方法是<code>Object.create()</code>，允许你创建新对象作为现有对象的委托。
这个方法在 ECMAScript5 中才添加，而那已是 JavaScript 出现后的第十四年了。
相对于克隆，让我带你参观一下 JavaScript 中定义类和创建对象的经典方法。
我们从<strong>构造器函数</strong>开始：</p>
<pre><code class="language-javascript">function Weapon(range, damage) {
  this.range = range;
  this.damage = damage;
}
</code></pre>
<p>这创建了一个新对象，初始化了它的字段。你像这样引入它：</p>
<pre><code class="language-javascript">var sword = new Weapon(10, 16);
</code></pre>
<p>这里的<code>new</code>调用<code>Weapon()</code>函数，而<code>this</code>绑定在新的空对象上。
函数为新对象添加了一系列字段，然后返回填满的对象。</p>
<p><code>new</code>也为你做了另外一件事。
当它创建那个新的空对象时，它将空对象的委托和一个原型对象连接起来。
你可以用<code>Weapon.prototype</code>来获得原型对象。</p>
<p>属性是添加到构造器中的，而定义<strong>行为</strong>通常是通过向原型对象添加方法。就像这样：</p>
<pre><code class="language-javascript">Weapon.prototype.attack = function(target) {
  if (distanceTo(target) &gt; this.range) {
    console.log(&quot;Out of range!&quot;);
  } else {
    target.health -= this.damage;
  }
};
</code></pre>
<p>这给武器原型添加了<code>attack</code>属性，其值是一个函数。
由于<code>new Weapon()</code>返回的每一个对象都有给<code>Weapon.prototype</code>的委托，
你现在可以通过调用<code>sword.attack()</code> 来调用那个函数。
看上去像是这样：</p>
<p><img src="https://gpp.tkchu.me/images/prototype-weapon.png" alt="一个武器原型包含一个 attack() 方法和其他方法。一个宝剑对象包含一个指向武器的委托和其他字段。" /></p>
<p>让我们复习一下：</p>
<ul>
<li>通过“new”操作创建对象，该操作引入代表类型的对象——构造器函数。</li>
<li>状态存储在实例中。</li>
<li>行为通过间接层——原型的委托——被存储在独立的对象中，代表了一系列特定类型对象的共享方法。</li>
</ul>
<p>说我疯了吧，但这听起来很像是我之前描述的类。
你<strong>可以</strong>在 JavaScript 中写原型风格的代码（<em>不用</em> 克隆），
但是语言的语法和惯用法更鼓励基于类的实现。</p>
<p>个人而言，我认为这是好事。
就像我说的，我发现如果一切都使用原型，就很难编写代码，
所以我喜欢 JavaScript，它将整个核心语义包上了一层糖衣。</p>
<h2><a class="header" href="#为数据模型构建原型" id="为数据模型构建原型">为数据模型构建原型</a></h2>
<p>好吧，我之前不断地讨论我<strong>不喜欢</strong>原型的原因，这让这一章读起来令人沮丧。
我认为这本书应该更欢乐些，所以在最后，让我们讨论讨论原型<strong>确实</strong>有用，或者更加精确，<em>委托</em> 有用的地方。</p>
<p>随着编程的进行，如果你比较程序与数据的字节数，
那么你会发现数据的占比稳定地增长。
早期的游戏在程序中生成几乎所有东西，这样程序可以塞进磁盘和老式游戏卡带。
在今日的游戏中，代码只是驱动游戏的“引擎”，游戏是完全由数据定义的。</p>
<p>这很好，但是将内容推到数据文件中并不能魔术般地解决组织大项目的挑战。
它只能把这挑战变得更难。
我们使用编程语言就因为它们有办法管理复杂性。</p>
<p>不再是将一堆代码拷来拷去，我们将其移入函数中，通过名字调用。
不再是在一堆类之间复制方法，我们将其放入单独的类中，让其他类可以继承或者组合。</p>
<p>当游戏数据达到一定规模时，你真的需要考虑一些相似的方案。
我不指望在这里能说清数据模式这个问题，
但我确实希望提出个思路，让你在游戏中考虑考虑：使用原型和委托来重用数据。</p>
<p>假设我们为早先提到的山寨版《圣铠传说》定义数据模型。
游戏设计者需要在很多文件中设定怪物和物品的属性。</p>
<blockquote>
<p>这标题是我原创的，没有受到任何已存的多人地下城游戏的影响。<br />
请不要起诉我。</p>
</blockquote>
<p>一个常用的方法是使用 JSON。
数据实体一般是<strong>字典</strong>，或者<strong>属性集合</strong>，或者其他什么术语，
因为程序员就喜欢为旧事物发明新名字。</p>
<blockquote>
<p>我们重新发明了太多次，Steve Yegge 称之为<a href="http://steve-yegge.blogspot.com/2008/10/universal-design-pattern.html">&quot;通用设计模式&quot;</a>.</p>
</blockquote>
<p>所以游戏中的哥布林也许被定义为像这样的东西：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;goblin grunt&quot;,
  &quot;minHealth&quot;: 20,
  &quot;maxHealth&quot;: 30,
  &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
  &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]
}
</code></pre>
<p>这看上去很易懂，哪怕是最讨厌文本的设计者也能使用它。
所以，你可以给哥布林大家族添加几个兄弟分支：</p>
<pre><code class="language-json">    {
      &quot;name&quot;: &quot;goblin wizard&quot;,
      &quot;minHealth&quot;: 20,
      &quot;maxHealth&quot;: 30,
      &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
      &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],
      &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]
    }

    {
      &quot;name&quot;: &quot;goblin archer&quot;,
      &quot;minHealth&quot;: 20,
      &quot;maxHealth&quot;: 30,
      &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
      &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;],
      &quot;attacks&quot;: [&quot;short bow&quot;]
    }
</code></pre>
<p>现在，如果这是代码，我们会闻到了臭味。
在实体间有很多的重复，训练优良的程序员<strong>讨厌</strong>重复。
它浪费了空间，消耗了作者更多时间。
你需要仔细阅读代码才知道这些数据<strong>是不是</strong>相同的。
这难以维护。
如果我们决定让所有哥布林变强，需要记得将三个哥布林都更新一遍。糟糕糟糕糟糕。</p>
<p>如果这是代码，我们会为“哥布林”构建抽象，并在三个哥布林类型中重用。
但是无能的 JSON 没法这么做。所以让我们把它做得更加巧妙些。</p>
<p>我们可以为对象添加<code>&quot;prototype&quot;</code>字段，记录委托对象的名字。
如果在此对象内没找到一个字段，那就去委托对象中查找。</p>
<blockquote>
<p>这让<code>&quot;prototype&quot;</code>不再是数据，而成为了<strong>元</strong>数据。
哥布林有绿色疣皮和黄色牙齿。它们没有原型。
原型是<strong>表示哥布林的数据模型</strong>的属性，而不是哥布林本身的属性。</p>
</blockquote>
<p>这样，我们可以简化我们的哥布林 JSON 内容：</p>
<pre><code class="language-json">    {
      &quot;name&quot;: &quot;goblin grunt&quot;,
      &quot;minHealth&quot;: 20,
      &quot;maxHealth&quot;: 30,
      &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;],
      &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]
    }

    {
      &quot;name&quot;: &quot;goblin wizard&quot;,
      &quot;prototype&quot;: &quot;goblin grunt&quot;,
      &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]
    }

    {
      &quot;name&quot;: &quot;goblin archer&quot;,
      &quot;prototype&quot;: &quot;goblin grunt&quot;,
      &quot;attacks&quot;: [&quot;short bow&quot;]
    }
</code></pre>
<p>由于弓箭手和术士都将 grunt 作为原型，我们就不需要在它们中重复血量，防御和弱点。
我们为数据模型增加的逻辑超级简单——基本的单一委托——但已经成功摆脱了一堆冗余。</p>
<p>有趣的事情是，我们没有更进一步，把哥布林委托的<strong>抽象</strong>原型设置成“基本哥布林”。
相反，我们选择了最简单的哥布林，然后委托给它。</p>
<p>在基于原型的系统中，对象可以克隆产生新对象是很自然的，
我认为在这里也一样自然。这特别适合记录那些只有一处不同的实体的数据。</p>
<p>想想 Boss 和其他独特的事物，它们通常是更加常见事物的重新定义，
原型委托是定义它们的好方法。
断头魔剑，就是一把拥有加成的长剑，可以像下面这样表示：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Sword of Head-Detaching&quot;,
  &quot;prototype&quot;: &quot;longsword&quot;,
  &quot;damageBonus&quot;: &quot;20&quot;
}
</code></pre>
<p>只需在游戏引擎上多花点时间，你就能让设计者更加方便地添加不同的武器和怪物，而增加的这些丰富度能够取悦玩家。</p>
<h1><a class="header" href="#单例模式" id="单例模式">单例模式</a></h1>
<h1><a class="header" href="#状态模式" id="状态模式">状态模式</a></h1>
<h1><a class="header" href="#双缓冲模式" id="双缓冲模式">双缓冲模式</a></h1>
<h1><a class="header" href="#游戏循环" id="游戏循环">游戏循环</a></h1>
<h1><a class="header" href="#更新方法" id="更新方法">更新方法</a></h1>
<h1><a class="header" href="#字节码" id="字节码">字节码</a></h1>
<h1><a class="header" href="#子类沙箱" id="子类沙箱">子类沙箱</a></h1>
<h1><a class="header" href="#类型对象" id="类型对象">类型对象</a></h1>
<h1><a class="header" href="#组件模式" id="组件模式">组件模式</a></h1>
<h1><a class="header" href="#服务定位器" id="服务定位器">服务定位器</a></h1>
<h1><a class="header" href="#数据局部性" id="数据局部性">数据局部性</a></h1>
<h2><a class="header" href="#连续数组" id="连续数组">连续数组</a></h2>
<h1><a class="header" href="#脏标识模式" id="脏标识模式">脏标识模式</a></h1>
<h1><a class="header" href="#对象池模式" id="对象池模式">对象池模式</a></h1>
<h1><a class="header" href="#空间分区" id="空间分区">空间分区</a></h1>
<h1><a class="header" href="#附录一" id="附录一">附录一</a></h1>
<p>正则</p>
<pre><code class="language-reg">(\*+?)(?!\*)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
