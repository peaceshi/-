<!DOCTYPE HTML>
<html lang="cmn-Hans" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>双缓冲模式 - 游戏编程模式</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="游戏编程模式">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#e1e1db" />

	<!-- preconnect -->
	<link href=https://cdn.jsdelivr.net/ rel="preconnect">
	<link href=https://cdn.staticfile.org/ rel="preconnect">
	<link href=https://peaceshi.github.io/ rel="preconnect">
	<link href=https://play.rust-lang.org rel="preconnect">
	<link href=https://storage.googleapis.com/ rel="preconnect">

	<!-- preload -->
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/css/variables.css" as="style">
	<link rel="preload"	href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/css/general.css" as="style">
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/css/chrome.css" as="style">
	<link rel="preload" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" as="style">
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/highlight.css" as="style">
	<link rel="preload" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css" as="style">
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/theme/theme.css" as="style">
	<!-- DO NOT preload ayu-highlight and tomorrow-night -->


        
		<!-- favicon -->
		<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/favicon.png">
		<!-- manifest -->
		<link rel="manifest" href="manifest.json">

        
	<!-- stylesheet -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/css/variables.css">

        
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/css/general.css">

        
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/css/chrome.css">

        
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/css/print.css" media="print">


        <!-- Fonts -->
        
	<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" type="text/css">

        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/highlight.css">
	<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css">

        
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/tomorrow-night.css">

        
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/ayu-highlight.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/theme/theme.css">


        <!-- Custom theme stylesheets -->
        
        
	

        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="0说明.html">说明</a></li><li class="expanded affix "><a href="00致谢.html">致谢</a></li><li class="expanded affix "><a href="01序.html">作者序</a></li><li class="expanded affix "><a href="02架构，性能和游戏.html">架构，性能和游戏</a></li><li class="expanded "><a href="03重返设计模式.html"><strong aria-hidden="true">1.</strong> 重返设计模式</a></li><li><ol class="section"><li class="expanded "><a href="03-1命令模式.html"><strong aria-hidden="true">1.1.</strong> 命令模式</a></li><li class="expanded "><a href="03-2享元模式.html"><strong aria-hidden="true">1.2.</strong> 享元模式</a></li><li class="expanded "><a href="03-3观察者模式.html"><strong aria-hidden="true">1.3.</strong> 观察者模式</a></li><li class="expanded "><a href="03-4原型模式.html"><strong aria-hidden="true">1.4.</strong> 原型模式</a></li><li class="expanded "><a href="03-5单例模式.html"><strong aria-hidden="true">1.5.</strong> 单例模式</a></li><li class="expanded "><a href="03-6状态模式.html"><strong aria-hidden="true">1.6.</strong> 状态模式</a></li></ol></li><li class="expanded "><a href="04序列模式.html"><strong aria-hidden="true">2.</strong> 序列模式</a></li><li><ol class="section"><li class="expanded "><a href="04-1双缓冲模式.html" class="active"><strong aria-hidden="true">2.1.</strong> 双缓冲模式</a></li><li class="expanded "><a href="04-2游戏循环.html"><strong aria-hidden="true">2.2.</strong> 游戏循环</a></li><li class="expanded "><a href="04-3更新方法.html"><strong aria-hidden="true">2.3.</strong> 更新方法</a></li></ol></li><li class="expanded "><a href="05行为模式.html"><strong aria-hidden="true">3.</strong> 行为模式</a></li><li><ol class="section"><li class="expanded "><a href="05-1字节码.html"><strong aria-hidden="true">3.1.</strong> 字节码</a></li><li class="expanded "><a href="05-2子类沙箱.html"><strong aria-hidden="true">3.2.</strong> 子类沙箱</a></li><li class="expanded "><a href="05-3类型对象.html"><strong aria-hidden="true">3.3.</strong> 类型对象</a></li></ol></li><li class="expanded "><a href="06解耦模式.html"><strong aria-hidden="true">4.</strong> 解耦模式</a></li><li><ol class="section"><li class="expanded "><a href="06-1组件模式.html"><strong aria-hidden="true">4.1.</strong> 组件模式</a></li><li class="expanded "><a href="06-2事件队列.html"><strong aria-hidden="true">4.2.</strong> 事件队列</a></li><li class="expanded "><a href="06-3服务定位器.html"><strong aria-hidden="true">4.3.</strong> 服务定位器</a></li></ol></li><li class="expanded "><a href="07优化模式.html"><strong aria-hidden="true">5.</strong> 优化模式</a></li><li><ol class="section"><li class="expanded "><a href="07-1数据局部性.html"><strong aria-hidden="true">5.1.</strong> 数据局部性</a></li><li class="expanded "><a href="07-2脏标识模式.html"><strong aria-hidden="true">5.2.</strong> 脏标识模式</a></li><li class="expanded "><a href="07-3对象池模式.html"><strong aria-hidden="true">5.3.</strong> 对象池模式</a></li><li class="expanded "><a href="07-3空间分区.html"><strong aria-hidden="true">5.4.</strong> 空间分区</a></li></ol></li><li class="expanded "><a href="附录一.html">附录一</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">游戏编程模式</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
	<a href="https://github.com/peaceshi/GameProgrammingPatterns" title="Git repository" aria-label="Git repository" target="_blank" rel="noopener noreferrer nofollow">

                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#双缓冲模式" id="双缓冲模式">双缓冲模式</a></h1>
<h2><a class="header" href="#意图" id="意图">意图</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p><em>用序列的操作模拟瞬间或者同时发生的事情。</em></p>
</blockquote>
</blockquote>
</blockquote>
<h2><a class="header" href="#动机" id="动机">动机</a></h2>
<p>电脑具有强大的序列化处理能力。
它的力量来自于将大的任务分解为小的步骤，这样可以一步接一步的完成。
但是，通常用户需要看到事情发生在瞬间或者让多个任务同时进行。</p>
<blockquote>
<p>使用线程和多核架构让这种说法不那么正确了，但哪怕使用多核，也只有一些操作可以同步运行。</p>
</blockquote>
<p>一个典型的例子，也是每个游戏引擎都得掌控的问题，渲染。
当游戏渲染玩家所见的世界时，它同时需要处理一堆东西——远处的山，起伏的丘陵，树木，每个都在各自的循环中处理。
如果在用户<strong>观察</strong>时增量做这些，连续世界的幻觉就会被打破。
场景必须快速流畅地更新，显示一系列完整的帧，每帧都是立即出现的。</p>
<p>双缓冲解决了这个问题，但是为了理解其原理，让我们首先的复习下计算机是如何显示图形的。</p>
<h3><a class="header" href="#计算机图形系统是如何工作的概述" id="计算机图形系统是如何工作的概述">计算机图形系统是如何工作的（概述）</a></h3>
<p>在电脑屏幕上显示图像是一次绘制一个像素点。
它从左到右扫描每行像素点，然后移动至下一行。
当抵达了右下角，它退回左上角重新开始。
它做得飞快——每秒六十次——因此我们的眼睛无法察觉。
对我们来说，这是一整张静态的彩色像素——一张图像。</p>
<blockquote>
<p>这个解释是“简化过的”。
如果你是底层软件开发人员，跳过下一节吧。
你对这章的其余部分已经了解得够多了。
如果你不是，这部分的目标是给你足够的背景知识，理解等下要讨论的设计模式。</p>
</blockquote>
<p>你可以将整个过程想象为软管向屏幕喷洒像素。
独特的像素从软管的后面流入，然后在屏幕上喷洒，每次对一个像素涂一点颜色。
所以软管怎么知道哪种颜色要喷到哪里？</p>
<p>在大多数电脑上，答案是从<strong>帧缓冲</strong>中获知这些信息。
帧缓冲是内存中的色素数组，RAM 中每两个字节代表表示一个像素点的颜色。
当软管向屏幕喷洒时，它从这个数组中读取颜色值，每次一个字节。</p>
<blockquote>
<p>在字节值和颜色之间的映射通常由系统的<strong>像素格式</strong>和<strong>色深</strong>来指定。
在今日多数游戏主机上，每个像素都有 32 位，红绿蓝三个各占八位，剩下的八位保留作其他用途。</p>
</blockquote>
<p>最终，为了让游戏显示在屏幕中，我们需要做的就是写入这个数组。
我们疯狂摆弄的图形算法最终都到了这里：设置帧缓冲中的字节值。
但这里有个小问题。</p>
<p>早先，我说过计算机是顺序处理的。
如果机器在运行一块渲染代码，我们不指望它同时还能做些别的什么事。
这通常是没啥问题，但是有些事<strong>确实</strong>在程序运行时发生。
其中一件是，当游戏运行时，视频输出正在<strong>不断</strong>从帧缓冲中读取数据。
这可能会为我们带来问题。</p>
<p>假设我们要在屏幕上显示一张笑脸。
程序在帧缓冲上开始循环，为像素点涂色。
我们没有意识到的是，在写入的同时，视频驱动正在读取它。
当它扫描过已写的像素时，笑脸开始浮现，但是之后它进入了未写的部分，就将没有写的像素绘制到了屏幕上。结果就是<strong>撕裂</strong>，你在屏幕上看到了绘制到一半的图像，这是可怕的视觉漏洞。</p>
<p><img src="https://gpp.tkchu.me/images/double-buffer-tearing.png" alt="描述了正在渲染的帧的一系列图片。一个指针在像素上写入，与此同时，另一个指针正在读取。读取的指针越过了写入的指针，然后开始读取未曾渲染的像素点。" /></p>
<blockquote>
<p>显卡设备读取的缓冲帧正是我们绘制像素的那块(Fig. 1)。
显卡最终追上了渲染器，然后越过它，读取了还没有写入的像素(Fig. 2)。
我们完成了绘制，但驱动没有收到那些新像素。</p>
<p>结果(Fig. 4)是用户只看到了一半的绘制结果。
我称它为“哭脸”，笑脸看上去下半部是撕裂的。</p>
</blockquote>
<p>这就是我们需要这个设计模式的原因。
程序一次渲染一个像素，但是显示需要一次全部看到——在这帧中啥也没有，下一帧笑脸全部出现。
双缓冲解决了这个问题。我会用类比来解释。</p>
<h3><a class="header" href="#表演-1场景-1" id="表演-1场景-1">表演 1，场景 1</a></h3>
<p>想象玩家正在观看我们的表演。
在场景一结束而场景二开始时，我们需要改变舞台设置。
如果让场务在场景结束后进去拖动东西，场景的连贯性就被打破了。
我们可以减弱灯光（这是剧院实际上的做法），但是观众还是知道<strong>有什么</strong>在进行，而我们想在场景间毫无跳跃地转换。</p>
<p>通过消耗一些地皮，我们想到了一个聪明的解决方案：建<strong>两个</strong>舞台，观众两个都能看到。
每个有它自己的一组灯光。我们称这些舞台为舞台 A 和舞台 B。
场景一在舞台 A 上。同时场务在处于黑暗之中的舞台 B 布置场景二。
当场景一完成后，将切断场景 A 的灯光，打开场景 B 的灯光。观众看向新舞台，场景二立即开始。</p>
<p>同时，场务到了黑咕隆咚的舞台<strong>A</strong>，收拾了场景一然后布置场景<strong>三</strong>。
一旦场景二结束，将灯光转回舞台 A。
我们在整场表演中进行这样的活动，使用黑暗的舞台作为布置下一场景的工作区域。
每一次场景转换，只是在两个舞台间切换灯光。
观众获得了连续的体验，场景转换时没有感到任何中断。他们从来没有见到场务。</p>
<blockquote>
<p>使用单面镜以及其他的巧妙布置，你可以真正地在同一<strong>位置</strong>布置两个舞台。
随着灯光切换，观众看到了不同的舞台，无需看向不同的地方。
如何这样布置舞台就留给读者做练习吧。</p>
</blockquote>
<h3><a class="header" href="#重新回到图形" id="重新回到图形">重新回到图形</a></h3>
<p>这就是双缓冲的工作原理，
这就是你看到的几乎每个游戏背后的渲染系统。
不只用一个帧缓冲，我们用<strong>两个</strong>。其中一个代表现在的帧，即类比中的舞台 A，也就是说是显卡读取的那一个。
GPU 可以想什么时候扫就什么时候扫。</p>
<blockquote>
<p>但不是<strong>所有</strong>的游戏主机都是这么做的。
更老的简单主机中，内存有限，需要小心地同步绘制和渲染。那很需要技巧。</p>
</blockquote>
<p>同时，我们的渲染代码正在写入<strong>另一个</strong>帧缓冲。
即黑暗中的舞台 B。当渲染代码完成了场景的绘制，它将通过<strong>交换</strong>缓存来切换灯光。
这告诉图形硬件开始从第二块缓存中读取而不是第一块。
只要在刷新之前交换，就不会有任何撕裂出现，整个场景都会一下子出现。</p>
<p>这时可以使用以前的帧缓冲了。我们可以将下一帧渲染在它上面了。超棒！</p>
<h2><a class="header" href="#模式" id="模式">模式</a></h2>
<p>定义<strong>缓冲类</strong>封装了<strong>缓冲</strong>：一段可改变的状态。
这个缓冲被增量地修改，但我们想要外部的代码将修改视为单一的原子操作。
为了实现这点，类保存了<strong>两个</strong>缓冲的实例：<strong>下一缓冲</strong>和<strong>当前缓冲</strong>。</p>
<p>当信息<strong>从</strong>缓冲区中读取，它总是读取<strong>当前的</strong>缓冲区。
当信息需要写<strong>到</strong>缓存，它总是在<strong>下一</strong>缓冲区上操作。
当改变完成后，一个<strong>交换</strong>操作会立刻将当前缓冲区和下一缓冲区交换，
这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。</p>
<h2><a class="header" href="#何时使用" id="何时使用">何时使用</a></h2>
<p>这是那种你需要它时自然会想起的模式。
如果你有一个系统需要双缓冲，它可能有可见的错误（撕裂之类的）或者行为不正确。
但是，“当你需要时自然会想起”没提提供太多有效信息。
更加特殊地，以下情况都满足时，使用这个模式就很恰当：</p>
<ul>
<li>我们需要维护一些被增量修改的状态。</li>
<li>在修改到一半的时候，状态可能会被外部请求。</li>
<li>我们想要防止请求状态的外部代码知道内部的工作方式。</li>
<li>我们想要读取状态，而且不想等着修改完成。</li>
</ul>
<h2><a class="header" href="#记住" id="记住">记住</a></h2>
<p>不像其他较大的架构模式，双缓冲模式位于底层。
正因如此，它对代码库的其他部分影响较小——大多数游戏甚至不会感到有区别。
尽管这里还是有几个警告。</p>
<h3><a class="header" href="#交换本身需要时间" id="交换本身需要时间">交换本身需要时间</a></h3>
<p>在状态被修改后，双缓冲需要一个<strong>swap</strong>步骤。
这个操作必须是原子的——在交换时，没有代码可以接触到<strong>任何一个</strong>状态。
通常，这就是修改一个指针那么快，但是如果交换消耗的时间长于修改状态的时间，那可是毫无助益。</p>
<h3><a class="header" href="#我们得保存两个缓冲区" id="我们得保存两个缓冲区">我们得保存两个缓冲区</a></h3>
<p>这个模式的另一个结果是增加了内存的使用。
正如其名，这个模式需要你在内存中一直保留<strong>两个</strong>状态的拷贝。
在内存受限的设备上，你可能要付出惨痛的代价。
如果你不能接受使用两份内存，你需要使用别的方法保证状态在修改时不会被请求。</p>
<h2><a class="header" href="#示例代码" id="示例代码">示例代码</a></h2>
<p>我们知道了理论，现在看看它在实践中如何应用。
我们编写了一个非常基础的图形系统，允许我们在缓冲帧上描绘像素。
在大多数主机和电脑上，显卡驱动提供了这种底层的图形系统，
但是在这里手动实现有助于理解发生了什么。首先是缓冲区本身：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Framebuffer
{
public:
  Framebuffer() { clear(); }

  void clear()
  {
    for (int i = 0; i &lt; WIDTH * HEIGHT; i++)
    {
      pixels_[i] = WHITE;
    }
  }

  void draw(int x, int y)
  {
    pixels_[(WIDTH * y) + x] = BLACK;
  }

  const char* getPixels()
  {
    return pixels_;
  }

private:
  static const int WIDTH = 160;
  static const int HEIGHT = 120;

  char pixels_[WIDTH * HEIGHT];
};
<span class="boring">}
</span></code></pre></pre>
<p>它有将整个缓存设置成默认的颜色的操作，也将其中一个像素设置为特定颜色的操作。
它也有函数<code>getPixels()</code>，读取保存像素数据的数组。
虽然在这个例子中没有出现，但在实际中，显卡驱动会频繁调用这个函数，将缓存中的数据输送到屏幕上。</p>
<p>我们将整个缓冲区封装在<code>Scene</code>类中。渲染某物需要做的是在这块缓冲区上调用一系列<code>draw()</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Scene
{
public:
  void draw()
  {
    buffer_.clear();

    buffer_.draw(1, 1);
    buffer_.draw(4, 1);
    buffer_.draw(1, 3);
    buffer_.draw(2, 4);
    buffer_.draw(3, 4);
    buffer_.draw(4, 3);
  }

  Framebuffer&amp; getBuffer() { return buffer_; }

private:
  Framebuffer buffer_;
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>特别地，它画出来这幅旷世杰作：</p>
</blockquote>
<p><img src="https://gpp.tkchu.me/images/double-buffer-face.png" alt="一个像素风的笑脸" /></p>
<p>每一帧，游戏告诉场景去绘制。场景清空缓冲区然后一个接一个绘制一大堆像素。
它也提供了<code>getBuffer()</code>获得缓冲区，这样显卡可以接触到它。</p>
<p>这看起来直截了当，但是如果就这样做，我们会遇到麻烦。
显卡驱动可以在<strong>任何</strong>时间调用<code>getBuffer()</code>，甚至在这个时候：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>buffer_.draw(1, 1);
buffer_.draw(4, 1);
// &lt;- 图形驱动从这里读取像素！
buffer_.draw(1, 3);
buffer_.draw(2, 4);
buffer_.draw(3, 4);
buffer_.draw(4, 3);
<span class="boring">}
</span></code></pre></pre>
<p>当上面的情况发生时，用户就会看到脸的眼睛，但是这一帧中嘴却消失了。
下一帧，又可能在某些别的地方发生冲突。最终结果是糟糕的闪烁图形。我们会用双缓冲修复这点：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Scene
{
public:
  Scene()
  : current_(&amp;buffers_[0]),
    next_(&amp;buffers_[1])
  {}

  void draw()
  {
    next_-&gt;clear();

    next_-&gt;draw(1, 1);
    // ...
    next_-&gt;draw(4, 3);

    swap();
  }

  Framebuffer&amp; getBuffer() { return *current_; }

private:
  void swap()
  {
    // 只需交换指针
    Framebuffer* temp = current_;
    current_ = next_;
    next_ = temp;
  }

  Framebuffer  buffers_[2];
  Framebuffer* current_;
  Framebuffer* next_;
};
<span class="boring">}
</span></code></pre></pre>
<p>现在<code>Scene</code>有存储在<code>buffers_</code>数组中的两个缓冲区，。
我们并不从数组中直接引用它们。而是通过两个成员，<code>next_</code>和<code>current_</code>，指向这个数组。
当绘制时，我们绘制在<code>next_</code>指向的缓冲区上。
当显卡驱动需要获得像素信息时，它总是通过<code>current_</code>获取<strong>另一个</strong>缓冲区。</p>
<p>通过这种方式，显卡驱动永远看不到我们正在施工的缓冲区。
解决方案的的最后一部分就是在场景完成绘制一帧的时候调用<code>swap()</code>。
它通过交换<code>next_</code>和<code>current_</code>的引用完成这一点。
下一次显卡驱动调用<code>getBuffer()</code>，它会获得我们刚刚完成渲染的新缓冲区，
然后将刚刚描绘好的缓冲区放在屏幕上。没有撕裂，也没有不美观的问题。</p>
<h3><a class="header" href="#不仅是图形" id="不仅是图形">不仅是图形</a></h3>
<p>双缓冲解决的核心问题是状态有可能在被修改的同时被请求。
这通常有两种原因。图形的例子覆盖了第一种原因——另一线程的代码或者另一个中断的代码直接访问了状态。</p>
<p>但是，还有一个同样常见的原因：<em>负责修改的</em> 代码试图访问同样正在修改状态。
这可能发生在很多地方，特别是实体的物理部分和 AI 部分，实体在相互交互。
双缓冲在那里也十分有用。</p>
<h3><a class="header" href="#人工不智能" id="人工不智能">人工不智能</a></h3>
<p>假设我们正在构建一个关于趣味喜剧的游戏的行为系统。
这个游戏包括一堆跑来跑去寻欢作乐的角色。这里是我们的基础角色：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Actor
{
public:
  Actor() : slapped_(false) {}

  virtual ~Actor() {}
  virtual void update() = 0;

  void reset()      { slapped_ = false; }
  void slap()       { slapped_ = true; }
  bool wasSlapped() { return slapped_; }

private:
  bool slapped_;
};
<span class="boring">}
</span></code></pre></pre>
<p>每一帧，游戏要在角色身上调用<code>update()</code>，让角色做些事情。
特别地，从玩家的角度，<em>所有的角色都应该看上去同时更新</em>。</p>
<blockquote>
<p><a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a>模式的例子。</p>
</blockquote>
<p>角色也可以相互交互，这里的“交互”，我指“可以互相扇对方巴掌”。
当更新时，角色可以在另一个角色身上调用<code>slap()</code>来扇它一巴掌，然后调用<code>wasSlapped()</code>看看自己是不是被扇了。</p>
<p>角色需要一个可以交互的舞台，让我们来布置一下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Stage
{
public:
  void add(Actor* actor, int index)
  {
    actors_[index] = actor;
  }

  void update()
  {
    for (int i = 0; i &lt; NUM_ACTORS; i++)
    {
      actors_[i]-&gt;update();
      actors_[i]-&gt;reset();
    }
  }

private:
  static const int NUM_ACTORS = 3;

  Actor* actors_[NUM_ACTORS];
};
<span class="boring">}
</span></code></pre></pre>
<p><code>Stage</code>允许我们向其中增加角色，
然后使用简单的<code>update()</code>调用来更新每个角色。
在用户看来，角色是同时移动的，但是实际上，它们是依次更新的。</p>
<p>这里需要注意的另一点是，每个角色的“被扇”状态在更新后就立刻被清除。
这样才能保证一个角色对一巴掌只反应一次。</p>
<p>作为一切的开始，让我们定义一个具体的角色子类。
这里的喜剧演员很简单。
他只面向一个角色。当他被扇时——无论是谁扇的他——他的反应是扇他面前的人一巴掌。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Comedian : public Actor
{
public:
  void face(Actor* actor) { facing_ = actor; }

  virtual void update()
  {
    if (wasSlapped()) facing_-&gt;slap();
  }

private:
  Actor* facing_;
};
<span class="boring">}
</span></code></pre></pre>
<p>现在我们把一些喜剧演员丢到舞台上看看发生了什么。
我们设置三个演员，第一个面朝第二个，第二个面朝第三个，第三个面对第一个，形成一个环：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Stage stage;

Comedian* harry = new Comedian();
Comedian* baldy = new Comedian();
Comedian* chump = new Comedian();

harry-&gt;face(baldy);
baldy-&gt;face(chump);
chump-&gt;face(harry);

stage.add(harry, 0);
stage.add(baldy, 1);
stage.add(chump, 2);
<span class="boring">}
</span></code></pre></pre>
<p>最终舞台布置如下图。箭头代表角色的朝向，然后数字代表角色在舞台数组中的索引。</p>
<p><img src="https://gpp.tkchu.me/images/double-buffer-slaps-1.png" alt="代表Harry，Baldy和Chump的三个盒子。Harry有一个指向 Baldy的箭头，Baldy有个指向Chump的箭头，Chump有个指向Harry的箭头。" /></p>
<p>我们扇哈利一巴掌，为表演拉开序幕，看看之后会发生什么：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>harry-&gt;slap();

stage.update();
<span class="boring">}
</span></code></pre></pre>
<p>记住<code>Stage</code>中的<code>update()</code>函数轮流更新每个角色，
因此如果检视整个代码，我们会发现事件这样发生：</p>
<pre><code class="language-log">Stage updates actor 0 (Harry)
  Harry was slapped, so he slaps Baldy
Stage updates actor 1 (Baldy)
  Baldy was slapped, so he slaps Chump
Stage updates actor 2 (Chump)
  Chump was slapped, so he slaps Harry
Stage update ends
</code></pre>
<p>在单独的一帧中，初始给哈利的一巴掌传给了所有的喜剧演员。
现在，让事物复杂起来，让我们重新排列舞台数组中角色的排序，
但是继续保持面向对方的方式。</p>
<p><img src="https://gpp.tkchu.me/images/double-buffer-slaps-2.png" alt="还是相同的盒子和箭头，只是顺序变成了Chump, Baldy, Harry。" /></p>
<p>我们不动舞台的其余部分，只是将添加角色到舞台的代码块改为如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>stage.add(harry, 2);
stage.add(baldy, 1);
stage.add(chump, 0);
<span class="boring">}
</span></code></pre></pre>
<p>让我们看看再次运行时会发生什么：</p>
<pre><code class="language-log">Stage updates actor 0 (Chump)
  Chump was not slapped, so he does nothing
Stage updates actor 1 (Baldy)
  Baldy was not slapped, so he does nothing
Stage updates actor 2 (Harry)
  Harry was slapped, so he slaps Baldy
Stage update ends
</code></pre>
<p>哦不。完全不一样了。问题很明显。
更新角色时，我们修改了他们的“被扇”状态，这也是我们在更新时<strong>读取</strong>的状态。
因此，在更新中早先的状态修改会影响之后<strong>同一</strong>状态的修改的步骤。</p>
<blockquote>
<p>如果你继续更新舞台，你会看到巴掌在角色间逐渐传递，每帧传递一个。
在第一帧 Harry 扇了 Baldy。下一帧，Baldy 扇了 Chump，如此类推。</p>
</blockquote>
<p>而最终的结果是，一个角色对被扇作出反应可能是在被扇的<strong>同一</strong>帧或者<strong>下一</strong>帧，
这完全取决于两个角色在舞台上是如何排序的。
这没能满足我让角色同时反应的需求——它们在同一帧中更新的顺序不该对结果有影响。</p>
<h3><a class="header" href="#缓存巴掌" id="缓存巴掌">缓存巴掌</a></h3>
<p>幸运的是，双缓冲模式可以帮忙。
这次，不是保存两大块“缓冲”，我们缓冲更小粒度的事物：每个角色的“被扇”状态。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Actor
{
public:
  Actor() : currentSlapped_(false) {}

  virtual ~Actor() {}
  virtual void update() = 0;

  void swap()
  {
    // 交换缓冲区
    currentSlapped_ = nextSlapped_;

    // 清空新的“下一个”缓冲区。.
    nextSlapped_ = false;
  }

  void slap()       { nextSlapped_ = true; }
  bool wasSlapped() { return currentSlapped_; }

private:
  bool currentSlapped_;
  bool nextSlapped_;
};
<span class="boring">}
</span></code></pre></pre>
<p>不再使用一个<code>slapped_</code>状态，每个演员现在使用两个。
就像我们之前图形的例子一样，当前状态为读准备，下一状态为写准备。</p>
<p><code>reset()</code>函数被替换为<code>swap()</code>。
现在，就在清除交换状态前，它将下一状态拷贝到当前状态上，
使其成为新的当前状态，这还需要在<code>Stage</code>中进行小小的改变：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>void Stage::update()
{
  for (int i = 0; i &lt; NUM_ACTORS; i++)
  {
    actors_[i]-&gt;update();
  }

  for (int i = 0; i &lt; NUM_ACTORS; i++)
  {
    actors_[i]-&gt;swap();
  }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>update()</code>函数现在更新所有的角色，<em>然后</em> 交换它们的状态。
最终结果是，角色在实际被扇<strong>之后</strong>的那帧才能看到巴掌。
这样一来，角色无论在舞台数组中如何排列，都会保持相同的行为。
无论外部的代码如何调用，所有的角色在一帧内同时更新。</p>
<h2><a class="header" href="#设计决策" id="设计决策">设计决策</a></h2>
<p>双缓冲很直观，我们上面看到的例子也覆盖了大多数你需要的场景。
使用这个模式之前，还需要做两个主要的设计决策。</p>
<h3><a class="header" href="#缓冲区是如何被交换的" id="缓冲区是如何被交换的">缓冲区是如何被交换的</a></h3>
<p>交换操作是整个过程的最重要的一步，
因为在其发生时，我们必须锁住两个缓冲区上的读取和修改。
为了让性能最优，我们需要它进行得越快越好。</p>
<ul>
<li>
<p><strong>交换缓冲区的指针或者引用：</strong>
这是我们图形例子中的做法，这也是大多数双缓冲图形通用的解决方法。</p>
<ul>
<li>
<p><em>速度快。</em> 不管缓冲区有多大，交换都只需赋值一对指针。很难在速度和简易性上超越它。</p>
</li>
<li>
<p><em>外部代码不能存储对缓存的永久指针。</em> 这是主要限制。
由于我们没有真正地移动<strong>数据</strong>，本质上做的是周期性地通知代码库的其他部分到别处去寻找缓存，
就像前面的舞台类比一样。这就意味着代码库的其他部分不能存储指向缓冲区中数据的指针——
它一段时间后可能就指向了错误的部分。</p>
<p>这会严重误导那些期待缓冲帧永远在内存中的固定地址的显卡驱动。在这种情况下，我们不能这么做。</p>
</li>
<li>
<p><em>缓冲区中的数据是两帧之前的数据，而不是上一帧的数据。</em>
接下来的那帧绘制在帧缓冲区上，而不是在它们之间拷贝数据，就像这样：</p>
<pre><code class="language-text">Frame 1 drawn on buffer A
Frame 2 drawn on buffer B
Frame 3 drawn on buffer A
...
</code></pre>
<p>你会注意到，当我们绘制第三帧时，缓冲区上的数据是<strong>第一帧</strong>的，而不是第二帧的。大多数情况下，这不是什么问题——我们通常在绘制之前清空整个帧。但如果想沿用某些缓存中已有的数据，就需要考虑数据其实比期望的更旧。</p>
<blockquote>
<p>旧帧中缓存数据的经典用法是模拟动态模糊。
当前的帧混合一点之前的帧，看起来更像真实的相机捕获的图景。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>在缓冲区之间拷贝数据：</strong>
如果我们不能重定向到其他缓存，唯一的选项就是将下帧的数据实实在在的拷贝到现在这帧上。
这是我们的扇巴掌喜剧的工作方法。
这种情况下，使用这种方法是因为拷贝状态——一个简单的布尔标识——不比修改指向缓存的指针开销大。</p>
<ul>
<li>
<p><em>下一帧的数据和之前的数据相差一帧。</em>
拷贝数据与在两块缓冲区间跳来跳去正相反。
如果我们需要前一帧的数据，这样我们可以处理更新的数据。</p>
</li>
<li>
<p><em>交换也许更花时间。</em>
这个当然是最大的缺点。交换操作现在意味着在内存中拷贝整个缓冲区。
如果缓冲区很大，比如一整个缓冲帧，这需要花费可观的时间。
由于交换时没有东西可以读取或者写入<strong>任何一个</strong>缓冲区，这是一个巨大的限制。</p>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#缓冲的粒度如何" id="缓冲的粒度如何">缓冲的粒度如何</a></h3>
<p>这里的另一个问题是缓冲区本身是如何组织的——是单个数据块还是散布在对象集合中？
图形例子是前一种，而角色例子是后一种。</p>
<p>大多数情况下，你缓存的方式自然而然会引导你找到答案，但是这里也有些灵活度。
比如，角色总能将消息存在独立的消息块中，使用索引来引用。</p>
<ul>
<li>
<p><strong>如果缓存是一整块：</strong></p>
<ul>
<li><em>交换操作更简单。</em>
由于只有一对缓存，一个简单的交换就完成了。
如果可以改变指针来交换，那么不必在意缓冲区大小，只需几部操作就可以交换整个缓冲区。</p></li>
</ul>
</li>
<li>
<p><strong>如果很多对象都持有一块数据：</strong></p>
<ul>
<li>
<p><em>交换操作更慢。</em>
为了交换，需要遍历整个对象集合，通知每个对象交换。</p>
<p>在喜剧的例子中，这没问题，因为反正需要清除被扇状态
——每块缓存的数据每帧都需要接触。
如果不需要接触较旧的帧，可以用通过在多个对象间分散状态来优化，获得使用整块缓存一样的性能。</p>
<p>思路是将“当前”和“下一”指针概念，将它们改为对象相关的<strong>偏移量</strong>。就像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>class Actor
    {
    public:
      static void init() { current_ = 0; }
      static void swap() { current_ = next(); }

      void slap()        { slapped_[next()] = true; }
      bool wasSlapped()  { return slapped_[current_]; }

    private:
      static int current_;
      static int next()  { return 1 - current_; }

      bool slapped_[2];
    };
<span class="boring">}
</span></code></pre></pre>
<p>角色使用<code>current_</code>在状态数组中查询，获得当前的被扇状态，
下一状态总是数组中的另一索引，这样可以用<code>next()</code>来计算。
交换状态只需改动<code>current_</code>索引。
聪明之处在于<code>swap()</code>现在是<strong>静态</strong>函数，它只需被调用一次，<em>每个</em> 角色的状态都会被交换。</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#参见" id="参见">参见</a></h2>
<ul>
<li>你可以在几乎每个图形 API 中找到双缓冲模式。举个例子，OpenGL 有<code>swapBuffers()</code>，Direct3D 有&quot;swap chains&quot;, Microsoft 的 XNA 框架有<code>endDraw()</code>方法。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="04序列模式.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="04-2游戏循环.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="04序列模式.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="04-2游戏循环.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        
	<script defer src="https://cdn.staticfile.org/clipboard.js/2.0.4/clipboard.min.js"></script>

        
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/languages/basic.min.js"></script>

        
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/src/theme/book.js"></script>
	<script defer src="https://cdn.staticfile.org/lazysizes/5.2.0/lazysizes.min.js"></script>
	<script defer src="https://cdn.staticfile.org/mermaid/8.4.6/mermaid.min.js"></script>
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@849eff4/plugin/init.js"></script>


        <!-- Custom JS scripts -->
        
        
	

        

        

    </body>
</html>
