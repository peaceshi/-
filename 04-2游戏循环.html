<!DOCTYPE HTML>
<html lang="cmn-Hans" class="sidebar-visible no-js rust">

<head>
	<!-- Book generated using mdBook -->
	<meta charset="UTF-8">
	<title>游戏循环 - 游戏编程模式</title>
	

	<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
	<meta name="description" content="游戏编程模式">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#ffffff" />

	<link rel="manifest" href="manifest.json">
	<link href='https://storage.googleapis.com/' rel='preconnect' crossorigin>
	<link href='https://cdn.jsdelivr.net/' rel='preconnect' crossorigin>
	<link href='https://play.rust-lang.org' rel='preconnect' crossorigin>
	<link href='https://cdn.staticfile.org/' rel='preconnect' crossorigin>
	<link href='https://peaceshi.github.io/' rel='preconnect' crossorigin>
	<link rel="shortcut icon"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/favicon.png">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/css/variables.css" as="style">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/css/variables.css">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/css/general.css" as="style">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/css/general.css">
	<link rel="preload"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/css/chrome.css" as="style">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/css/chrome.css">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/css/print.css" media="print">
	<!-- Fonts -->
	<link rel="preload" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" as="style"
		crossorigin>
	<link rel='stylesheet' href='https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css' type='text/css'
		crossorigin>
	<!-- Highlight.js Stylesheets -->
	<link rel="preload" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css" as="style"
		crossorigin>
	<link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/default.min.css" type='text/css'
		crossorigin>
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/ayu-highlight.css" crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/ayu-highlight.css"
		as="style" crossorigin>
		<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/highlight.css" crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/highlight.css"
		as="style" crossorigin>
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/tomorrow-night.css" crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/tomorrow-night.css"
		as="style" crossorigin>

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/theme.css"
		crossorigin>
	<link rel="preload" href="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/theme/theme.css"
		as="style" crossorigin>
	<!-- Custom theme stylesheets -->
	
	
	
	
</head>

<body>
	<!-- Provide site root to javascript -->
	<script type="text/javascript">
		var path_to_root = "";
		var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
	</script>

	<!-- Work around some values being stored in localStorage wrapped in quotes -->
	<script type="text/javascript">
		try {
			var theme = localStorage.getItem('mdbook-theme');
			var sidebar = localStorage.getItem('mdbook-sidebar');

			if (theme.startsWith('"') && theme.endsWith('"')) {
				localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
			}

			if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
				localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
			}
		} catch (e) { }
	</script>

	<!-- Set the theme before any content is loaded, prevents flash -->
	<script type="text/javascript">
		var theme;
		try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
		if (theme === null || theme === undefined) { theme = default_theme; }
		var html = document.querySelector('html');
		html.classList.remove('no-js')
		html.classList.remove('rust')
		html.classList.add(theme);
		html.classList.add('js');
	</script>

	<!-- Hide / unhide sidebar before it is displayed -->
	<script type="text/javascript">
		var html = document.querySelector('html');
		var sidebar = 'hidden';
		if (document.body.clientWidth >= 1080) {
			try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
			sidebar = sidebar || 'visible';
		}
		html.classList.remove('sidebar-visible');
		html.classList.add("sidebar-" + sidebar);
	</script>
	<nav id="sidebar" class="sidebar" aria-label="Table of contents">
		<div id="sidebar-scrollbox" class="sidebar-scrollbox">
			<ol class="chapter"><li class="expanded affix "><a href="0说明.html">说明</a></li><li class="expanded affix "><a href="00致谢.html">致谢</a></li><li class="expanded affix "><a href="01序.html">作者序</a></li><li class="expanded affix "><a href="02架构，性能和游戏.html">架构，性能和游戏</a></li><li class="expanded "><a href="03重返设计模式.html"><strong aria-hidden="true">1.</strong> 重返设计模式</a></li><li><ol class="section"><li class="expanded "><a href="03-1命令模式.html"><strong aria-hidden="true">1.1.</strong> 命令模式</a></li><li class="expanded "><a href="03-2享元模式.html"><strong aria-hidden="true">1.2.</strong> 享元模式</a></li><li class="expanded "><a href="03-3观察者模式.html"><strong aria-hidden="true">1.3.</strong> 观察者模式</a></li><li class="expanded "><a href="03-4原型模式.html"><strong aria-hidden="true">1.4.</strong> 原型模式</a></li><li class="expanded "><a href="03-5单例模式.html"><strong aria-hidden="true">1.5.</strong> 单例模式</a></li><li class="expanded "><a href="03-6状态模式.html"><strong aria-hidden="true">1.6.</strong> 状态模式</a></li></ol></li><li class="expanded "><a href="04序列模式.html"><strong aria-hidden="true">2.</strong> 序列模式</a></li><li><ol class="section"><li class="expanded "><a href="04-1双缓冲模式.html"><strong aria-hidden="true">2.1.</strong> 双缓冲模式</a></li><li class="expanded "><a href="04-2游戏循环.html" class="active"><strong aria-hidden="true">2.2.</strong> 游戏循环</a></li><li class="expanded "><a href="04-3更新方法.html"><strong aria-hidden="true">2.3.</strong> 更新方法</a></li></ol></li><li class="expanded "><a href="05行为模式.html"><strong aria-hidden="true">3.</strong> 行为模式</a></li><li><ol class="section"><li class="expanded "><a href="05-1字节码.html"><strong aria-hidden="true">3.1.</strong> 字节码</a></li><li class="expanded "><a href="05-2子类沙箱.html"><strong aria-hidden="true">3.2.</strong> 子类沙箱</a></li><li class="expanded "><a href="05-3类型对象.html"><strong aria-hidden="true">3.3.</strong> 类型对象</a></li></ol></li><li class="expanded "><a href="06解耦模式.html"><strong aria-hidden="true">4.</strong> 解耦模式</a></li><li><ol class="section"><li class="expanded "><a href="06-1组件模式.html"><strong aria-hidden="true">4.1.</strong> 组件模式</a></li><li class="expanded "><a href="06-2事件队列.html"><strong aria-hidden="true">4.2.</strong> 事件队列</a></li><li class="expanded "><a href="06-3服务定位器.html"><strong aria-hidden="true">4.3.</strong> 服务定位器</a></li></ol></li><li class="expanded "><a href="07优化模式.html"><strong aria-hidden="true">5.</strong> 优化模式</a></li><li><ol class="section"><li class="expanded "><a href="07-1数据局部性.html"><strong aria-hidden="true">5.1.</strong> 数据局部性</a></li><li class="expanded "><a href="07-2脏标识模式.html"><strong aria-hidden="true">5.2.</strong> 脏标识模式</a></li><li class="expanded "><a href="07-3对象池模式.html"><strong aria-hidden="true">5.3.</strong> 对象池模式</a></li><li class="expanded "><a href="07-3空间分区.html"><strong aria-hidden="true">5.4.</strong> 空间分区</a></li></ol></li><li class="expanded "><a href="附录一.html">附录一</a></li></ol>
		</div>
		<div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
	</nav>

	<div id="page-wrapper" class="page-wrapper">

		<div class="page">
			
			<div id="menu-bar" class="menu-bar">
				<div id="menu-bar-sticky-container">
					<div class="left-buttons">
						<button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
							aria-label="Toggle Table of Contents" aria-controls="sidebar">
							<i class="fa fa-bars"></i>
						</button>
						<button id="theme-toggle" class="icon-button" type="button" title="Change theme"
							aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
							aria-controls="theme-list">
							<i class="fa fa-paint-brush"></i>
						</button>
						<ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
							<li role="none"><button role="menuitem" class="theme"
									id="light">Light</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="rust">Rust (default)</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="coal">Coal</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="navy">Navy</button></li>
							<li role="none"><button role="menuitem" class="theme"
									id="ayu">Ayu</button></li>
						</ul>
						
					</div>

					<h1 class="menu-title">游戏编程模式</h1>

					<div class="right-buttons">
						<a href="print.html" title="Print this book" aria-label="Print this book">
							<i id="print-button" class="fa fa-print"></i>
						</a>
						
						<a href="https://github.com/peaceshi/GameProgrammingPatterns" title="Git repository" aria-label="Git repository">
							<i id="git-repository-button" class="fa fa-github"></i>
						</a>
						
					</div>
				</div>
			</div>

			

			<!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
			<script type="text/javascript">
				document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
				document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
				Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
					link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
				});
			</script>

			<div id="content" class="content">
				<main>
					<h1><a class="header" href="#游戏循环" id="游戏循环">游戏循环</a></h1>
<h2><a class="header" href="#意图" id="意图">意图</a></h2>
<blockquote>
<p><em>将游戏的进行和玩家的输入解耦，和处理器速度解耦。</em></p>
</blockquote>
<h2><a class="header" href="#动机" id="动机">动机</a></h2>
<p>如果本书中有一个模式不可或缺，那非这个模式莫属了。
游戏循环是“游戏编程模式”的精髓。
几乎每个游戏都有，两两不同，而在非游戏的程序几乎没有使用。</p>
<p>为了看看它多有用，让我们快速缅怀一遍往事。
在每个编写计算机程序的人都留着胡子的时代，程序像洗碗机一样工作。
你输入一堆代码，按个按钮，等待，然后获得结果，完成。
程序全都是<strong>批处理模式</strong>的——一旦工作完成，程序就停止了。</p>
<blockquote>
<p>Ada Lovelace 和 Rear Admiral Grace Hopper 是女程序员，并没有胡子。</p>
</blockquote>
<p>你在今日仍然能看到这些程序，虽然感谢上天，我们不必在打孔纸上面编写它们了。
终端脚本，命令行程序，甚至将 Markdown 翻译成这本书的 Python 脚本都是批处理程序。</p>
<h3><a class="header" href="#采访-cpu" id="采访-cpu">采访 CPU</a></h3>
<p>最终，程序员意识到将批处理代码留在计算办公室，等几个小时后拿到结果才能开始找程序漏洞的方式实在低效。
他们想要立即的反馈。<em>交互式</em> 程序诞生了。
第一批交互式程序中就有游戏：</p>
<pre><code class="language-text">YOU ARE STANDING AT THE END OF A ROAD BEFORE A SMALL BRICK
BUILDING . AROUND YOU IS A FOREST. A SMALL
STREAM FLOWS OUT OF THE BUILDING AND DOWN A GULLY.

&gt; GO IN
YOU ARE INSIDE A BUILDING, A WELL HOUSE FOR A LARGE SPRING.
</code></pre>
<blockquote>
<p>这是<a href="http://en.wikipedia.org/wiki/Colossal_Cave_Adventure">Colossal Cave Adventure</a>，史上首个冒险游戏。</p>
</blockquote>
<p>你可以和这个程序进行实时交互。
它等待你的输入，然后进行响应。
你再输入，这样一唱一和，就像相声一样。
当轮到你时，它停在那里啥也不做。像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  char* command = readCommand();
  handleCommand(command);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这程序会永久循环，所以没法退出游戏。
真实的游戏会做些<code>while (!done)</code>进行检查，然后通过设置<code>done</code>为真来退出游戏。
我省去了那些内容，保持简明。</p>
</blockquote>
<h3><a class="header" href="#事件循环" id="事件循环">事件循环</a></h3>
<p>如果你剥开现代的图形 UI 的外皮，会惊讶地发现它们与老旧的冒险游戏差不多。
文本处理器通常呆在那里什么也不做，直到你按了个键或者点了什么东西：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  Event* event = waitForEvent();
  dispatchEvent(event);
}
<span class="boring">}
</span></code></pre></pre>
<p>这与冒险游戏主要的不同是，程序不是等待<strong>文本指令</strong>，而是等待<strong>用户输入事件</strong>——鼠标点击、按键按下之类的。
其他部分还是和以前的老式文本冒险游戏一样，程序<strong>阻塞</strong>等待用户的输入，这是个问题。</p>
<p>不像其他大多数软件，游戏即使在没有玩家输入时也继续运行。
如果你站在那里看着屏幕，游戏不会冻结。动画继续动着。视觉效果继续闪烁。
如果运气不好的话，怪物会继续吞噬英雄。</p>
<blockquote>
<p>事件循环有“空转”事件，这样你可以无需用户输入间歇地做些事情。
这对于闪烁的光标或者进度条已经足够了，但对于游戏就太原始了。</p>
</blockquote>
<p>这是真实游戏循环的第一个关键部分：<em>它处理用户输入，但是不等待它</em>。循环总是继续旋转：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  processInput();
  update();
  render();
}
<span class="boring">}
</span></code></pre></pre>
<p>我们之后会改善它，但是基本的部分都在这里了。
<code>processInput()</code>处理上次调用到现在的任何输入。
然后<code>update()</code>让游戏模拟一步。
运行 AI 和物理（通常是这种顺序）。
最终，<code>render()</code>绘制游戏，这样玩家可以看到发生了什么。</p>
<blockquote>
<p>就像你可以从名字中猜到的，<code>update()</code>是使用<a href="04-3%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95.html">更新方法</a>模式的好地方。</p>
</blockquote>
<h3><a class="header" href="#时间之外的世界" id="时间之外的世界">时间之外的世界</a></h3>
<p>如果这个循环没有因为输入而阻塞，这就带来了明显的问题，要运转<strong>多快</strong>呢？
每次进行游戏循环都会推动一定的游戏状态的发展。
在游戏世界的居民看来，他们手上的表就会滴答一下。</p>
<blockquote>
<p>运行游戏循环一次的常用术语就是“滴答”(tick)和“帧”(frame)。</p>
</blockquote>
<p>同时，<strong>玩家的</strong>真实手表也在滴答着。
如果我们用实际时间来测算游戏循环运行的速度，就得到了游戏的“帧率”(FPS)。
如果游戏循环的更快，FPS 就更高，游戏运行得更流畅、更快。
如果循环得过慢，游戏看上去就像是慢动作电影。</p>
<p>我们现在写的这个循环是能转多快转多快，两个因素决定了帧率。
一个是<strong>每帧要做多少工作</strong>。复杂的物理，众多游戏对象，图形细节都让 CPU 和 GPU 繁忙，这决定了需要多久能完成一帧。</p>
<p>另一个是<strong>底层平台的速度。</strong> 更快的芯片可以在同样的时间里执行更多的代码。
多核，GPU 组，独立声卡，以及系统的调度都影响了在一次滴答中能够做多少东西。</p>
<h3><a class="header" href="#每秒的帧数" id="每秒的帧数">每秒的帧数</a></h3>
<p>在早期的视频游戏中，第二个因素是固定的。
如果你为 NES 或者 Apple IIe 写游戏，你<strong>明确</strong>知道游戏运行在什么 CPU 上。
你可以（也必须）为它特制代码。
你只需担忧第一个因素：每次滴答要做多少工作。</p>
<p>早期的游戏被仔细地编码，一帧只做一定的工作，开发者可以让游戏以想要的速率运行。
但是如果你想要在快些或者慢些的机器上运行同一游戏，游戏本身就会加速或减速。</p>
<blockquote>
<p>这就是为什么老式计算机通常有“<a href="http://en.wikipedia.org/wiki/Turbo_button">turbo</a>”按钮。
新的计算机运行得太快了，无法玩老游戏，因为游戏也会运行得过快。
<em>关闭</em> turbo 按钮，会减慢计算机的运行速度，就可以运行老游戏了。</p>
</blockquote>
<p>现在，很少有开发者可以奢侈地知道游戏运行的硬件条件。游戏必须自动适应多种设备。</p>
<p>这就是游戏循环的另一个关键任务：<em>不管潜在的硬件条件，以固定速度运行游戏。</em></p>
<h2><a class="header" href="#模式" id="模式">模式</a></h2>
<p>一个<strong>游戏循环</strong>在游玩中不断运行。
每一次循环，它无阻塞地<strong>处理玩家输入</strong>，<strong>更新游戏状态</strong>，<strong>渲染游戏</strong>。
它追踪时间的消耗并<strong>控制游戏的速度。</strong></p>
<h2><a class="header" href="#何时使用" id="何时使用">何时使用</a></h2>
<p>使用错误的模式比不使用模式更糟，所以这节通常告诫你不要过于热衷设计模式。
设计模式的目标不是往代码库里尽可能的塞东西。</p>
<p>但是这个模式有所不同。我可以很自信的说你<strong>会</strong>使用这个模式。
如果你使用游戏引擎，你不需要自己编写，但是它还在那里。</p>
<blockquote>
<p>对于我而言，这是“引擎”与“库”的不同之处。
使用库时，你拥有游戏循环，调用库代码。
使用引擎时，引擎拥有游戏循环，调用<strong>你的</strong>代码。</p>
</blockquote>
<p>你可能认为在做回合制游戏时不需要它。
但是哪怕是那里，就算<strong>游戏状态</strong>到玩家回合才改变，<strong>视觉</strong>和<strong>听觉</strong> 状态仍会改变。
哪怕游戏在“等待”你进行你的回合，动画和音乐也会继续运行。</p>
<h2><a class="header" href="#记住" id="记住">记住</a></h2>
<p>我们这里谈到的循环是游戏代码中最重要的部分。
有人说程序会花费 90%的时间在 10%的代码上。
游戏循环代码肯定在这 10%中。
你必须小心谨慎，时时注意效率。</p>
<blockquote>
<p>“真正的”工程师，比如机械或电子工程师，不把我们当回事，大概就是因为我们像这样使用统计学。</p>
</blockquote>
<h3><a class="header" href="#你也许需要与平台的事件循环相协调" id="你也许需要与平台的事件循环相协调">你也许需要与平台的事件循环相协调</a></h3>
<p>如果你在操作系统的顶层或者有图形 UI 和内建事件循环的平台上构建游戏，
那你就有了两个应用循环在同时运作。
它们需要很好地协调。</p>
<p>有时候，你可以进行控制，只运行你的游戏循环。
举个例子，如果舍弃了 Windows 的珍贵 API，<code>main()</code>可以只用游戏循环。
其中你可以调用<code>PeekMessage()</code>来处理和分发系统的事件。
不像<code>GetMessage()</code>，<code>PeekMessage()</code>不会阻塞等待用户输入，
因此你的游戏循环会保持运作。</p>
<p>其他的平台不会让你这么轻松地摆脱事件循环。
如果你使用网页浏览器作为平台，事件循环已被内建在浏览器的执行模型深处。
这样，你得用事件循环作为游戏循环。
你会调用<code>requestAnimationFrame()</code>之类的函数，它会回调你的代码，保持游戏继续运行。</p>
<h2><a class="header" href="#示例代码" id="示例代码">示例代码</a></h2>
<p>在如此长的介绍之后，游戏循环的代码实际上很直观。
我们会浏览一堆变种，比较它们的好处和坏处。</p>
<p>游戏循环驱动了 AI，渲染和其他游戏系统，但这些不是模式的要点，
所以我们会调用虚构的方法。在实现了<code>render()</code>，<code>update()</code>之后，
剩下的作为给读者的练习（挑战！）。</p>
<h3><a class="header" href="#跑能跑多快跑多快" id="跑能跑多快跑多快">跑，能跑多快跑多快</a></h3>
<p>我们已经见过了可能是最简单的游戏循环：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  processInput();
  update();
  render();
}
<span class="boring">}
</span></code></pre></pre>
<p>它的问题是你不能控制游戏运行得有多快。
在快速机器上，循环会运行得太快，玩家看不清发生了什么。
在慢速机器上，游戏慢的跟在爬一样。
如果游戏的一部分有大量内容或者做了很多 AI 或物理运算，游戏就会慢一些。</p>
<h3><a class="header" href="#休息一下" id="休息一下">休息一下</a></h3>
<p>我们看看增加一个简单的小修正如何。
假设你想要你的游戏以 60FPS 运行。这样每帧大约 16 毫秒。
只要你用少于这个的时长进行游戏所有的处理和渲染，就可以以稳定的帧率运行。
你需要做的就是处理这一帧然后<strong>等待</strong>，直到处理下一帧的时候，就像这样：</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-simple.png" alt="一个简单的游戏循环流程图。处理输入 → 更新游戏 → 渲染 → 等待，然后从头开始。" /></p>
<p>代码看上去像这样：</p>
<blockquote>
<p><em>1000 毫秒 / 帧率 = 毫秒每帧</em>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while (true)
{
  double start = getCurrentTime();
  processInput();
  update();
  render();

  sleep(start + MS_PER_FRAME - getCurrentTime());
}
<span class="boring">}
</span></code></pre></pre>
<p>如果它很快地处理完一帧，这里的<code>sleep()</code>保证了游戏不会运行太<strong>快</strong>。
如果你的游戏运行太<strong>慢</strong>，这无济于事。
如果需要超过 16ms 来更新并渲染一帧，休眠的时间就变成了<strong>负的</strong>。
如果计算机能回退时间，很多事情就很容易了，但是它不能。</p>
<p>相反，游戏变慢了。
可以通过每帧少做些工作来解决这个问题——减少物理效果和绚丽光影，或者把 AI 变笨。
但是这影响了那些有快速机器的玩家的游玩体验。</p>
<h3><a class="header" href="#一小步一大步" id="一小步一大步">一小步，一大步</a></h3>
<p>让我们尝试一些更加复杂的东西。我们拥有的问题基本上是：</p>
<ol>
<li>每次更新将游戏时间推动一个固定量。</li>
<li>这消耗一定量的<strong>真实</strong>时间来处理它。</li>
</ol>
<p>如果第二步消耗的时间超过第一步，游戏就变慢了。
如果它需要超过 16ms 来推动游戏时间 16ms，那它永远也跟不上。
但是如果一步中推动游戏时间<strong>超过</strong>16ms，那我们可以减少更新频率，就可以跟得上了。</p>
<p>接着的思路是基于上帧到现在有多少<strong>真实</strong>时间流逝来选择前进的时间。
这一帧花费的时间越长，游戏的间隔越大。
它总能跟上真实时间，因为它走的步子越来越大。
有人称之为<strong>变化的</strong>或者<strong>流动的</strong>时间间隔。它看上去像是：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>double lastTime = getCurrentTime();
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - lastTime;
  processInput();
  update(elapsed);
  render();
  lastTime = current;
}
<span class="boring">}
</span></code></pre></pre>
<p>每一帧，我们计算上次游戏更新到现在有多少<strong>真实</strong>时间过去了（即变量<code>elapsed</code>）。
当我们更新游戏状态时将其传入。
然后游戏引擎让游戏世界推进一定的时间量。</p>
<p>假设有一颗子弹跨过屏幕。
使用固定的时间间隔，在每一帧中，你根据它的速度移动它。
使用变化的时间间隔，你<strong>根据过去的时间拉伸速度</strong>。
随着时间间隔增加，子弹在每帧间移动得更远。
无论是二十个快的小间隔还是四个慢的大间隔，子弹在<strong>真实</strong>时间里移动<strong>同样</strong>多的距离。
这看上去成功了：</p>
<ul>
<li>游戏在不同的硬件上以固定的速度运行。</li>
<li>使用高端机器的玩家获得了更流畅的游戏体验。</li>
</ul>
<p>但悲剧的是，这里有一个严重的问题：
游戏不再是确定的了，也不再稳定。
这是我们给自己挖的一个坑：</p>
<blockquote>
<p>“确定的”代表每次你运行程序，如果给了它同样的输入，就获得同样的输出。
可以想得到，在确定的程序中追踪漏洞更容易——一旦找到造成漏洞的输入，每次你都能重现之。</p>
<p>计算机本身是确定的；它们机械地执行程序。
在纷乱的真实世界搀合进来，非确定性就出现了。
例如，网络，系统时钟，线程调度都依赖于超出程序控制的外部世界。</p>
</blockquote>
<p>假设我们有个双人联网游戏，Fred 的游戏机是台性能猛兽，而 George 正在使用他祖母的老爷机。
前面提到的子弹在他们的屏幕上飞行。
在 Fred 的机器上，游戏跑得超级快，每个时间间隔都很小。
比如，我们塞了 50 帧在子弹穿过屏幕的那一秒。
可怜的 George 的机器只能塞进大约 5 帧。</p>
<p>这就意味着在 Fred 的机器上，物理引擎每秒更新 50 次位置，但是 George 的只更新 5 次。
大多数游戏使用浮点数，它们有<strong>舍入误差</strong>。
每次你将两个浮点数加在一起，获得的结果就会有点偏差。
Fred 的机器做了 10 倍的操作，所以他的误差要比 George 的更大。
<em>同样</em> 的子弹最终在他们的机器上到了<strong>不同的位置</strong>。</p>
<p>这是使用变化时间可引起的问题之一，还有更多问题呢。
为了实时运行，游戏物理引擎做的是实际机制法则的近似。
为了避免飞天遁地，物理引擎添加了阻尼。
这个阻尼运算被小心地安排成以固定的时间间隔运行。
改变了它，物理就不再稳定。</p>
<blockquote>
<p>“飞天遁地”在这里使用的是它的字面意思。当物理引擎卡住，对象获得了完全错误的速度，就会飞到天上或者掉入地底。</p>
</blockquote>
<p>这种不稳定性太糟了，这个例子在这里的唯一原因是作为警示寓言，引领我们到更好的东西……</p>
<h3><a class="header" href="#追逐时间" id="追逐时间">追逐时间</a></h3>
<p>游戏中渲染通常<strong>不会</strong>被动态时间间隔影响到。
由于渲染引擎表现的是时间上的一瞬间，它不会计算上次到现在过了多久。
它只是将当前事物渲染在所在的地方。</p>
<blockquote>
<p>这或多或少是成立的。像动态模糊的东西会被时间间隔影响，但如果有一点延迟，玩家通常也不会注意到。</p>
</blockquote>
<p>我们可以利用这点。
以固定的时间间隔<strong>更新</strong>游戏，因为这让所有事情变得简单，物理和 AI 也更加稳定。
但是我们允许灵活调整<strong>渲染</strong>的时刻，释放一些处理器时间。</p>
<p>它像这样运作：自上一次游戏循环过去了一定量的真实时间。
需要为游戏的“当前时间”模拟推进相同长度的时间，以追上玩家的时间。
我们使用一<strong>系列</strong>的<strong>固定</strong>时间步长。
代码大致如下：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>double previous = getCurrentTime();
double lag = 0.0;
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - previous;
  previous = current;
  lag += elapsed;

  processInput();

  while (lag &gt;= MS_PER_UPDATE)
  {
    update();
    lag -= MS_PER_UPDATE;
  }

  render();
}
<span class="boring">}
</span></code></pre></pre>
<p>这里有几个部分。
在每帧的开始，根据过去了多少真实的时间，更新<code>lag</code>。
这个变量表明了游戏世界时钟比真实世界落后了多少，然后我们使用一个固定时间步长的内部循环进行追赶。
一旦我们追上真实时间，我们就渲染然后开始新一轮循环。
你可以将其画成这样：</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-fixed.png" alt="修改后的流程图。处理输入 → 更新游戏 → 等待，然重回更新这步 → 渲染 → 回到开始。" /></p>
<p>注意这里的时间步长不是<strong>视觉上的</strong>帧率了。
<code>MS_PER_UPDATE</code>只是我们更新游戏的<strong>间隔</strong>。
这个间隔越短，就需要越多的处理次数来追上真实时间。
它越长，游戏抖动得越厉害。
理想上，你想要它足够短，通常快过 60FPS，这样游戏在高速机器上会有高效的表现。</p>
<p>但是小心不要把它整得<strong>太</strong>短了。
你需要保证即使在最慢的机器上，这个时间步长也超过处理一次<code>update()</code>的时间。
否则，你的游戏就跟不上现实时间了。</p>
<blockquote>
<p>我不会详谈这个，但你可以通过限定内层循环的最大次数来保证这一点。
游戏会变慢，但是比完全卡死要好。</p>
</blockquote>
<p>幸运的是，我们给自己了一些喘息的空间。
技巧在于我们将<strong>渲染拉出了更新循环</strong>。
这释放了一大块 CPU 时间。
最终结果是游戏以固定时间步长<strong>模拟</strong>，该时间步长与硬件不相关。
只是使用低端硬件的玩家<strong>看到的</strong>内容会有抖动。</p>
<h3><a class="header" href="#卡在中间" id="卡在中间">卡在中间</a></h3>
<p>我们还剩一个问题，就是剩下的延迟。
以固定的时间步长更新游戏，在任意时刻渲染。
这就意味着从玩家的角度看，游戏经常在两次更新之间时显示。</p>
<p>这是时间线：</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-timeline.png" alt="一条时间线，上面是均匀分布的更新时刻和不均匀的渲染时刻。" /></p>
<p>就像你看到的那样，我们以紧凑固定的时间步长进行更新。
同时，我们在任何可能的时候渲染。
它比更新发生得要少，而且也不稳定。
两者都没问题。糟糕的是，我们不总能在正确的时间点渲染。
看看第三次渲染时间。它发生在两次更新之间。</p>
<p><img src="https://gpp.tkchu.me/images/game-loop-timeline-close.png" alt="时间线的一部分，渲染发生在两次更新之间。&quot;" /></p>
<p>想象一颗子弹飞过屏幕。第一次更新时，它在左边。
第二次更新将它移到了右边。
这个游戏在两次更新之间的时间点渲染，所以玩家期望看到子弹在屏幕的中间。
而现在的实现中，它还在左边。这意味着看上去移动发生了卡顿。</p>
<p>方便的是，我们<strong>实际</strong>知道渲染时距离两次更新的时间：它被存储在<code>lag</code>中。
我们在<code>lag</code>比更新时间间隔小时，而不是<code>lag</code>是<strong>零</strong>时，跳出循环进行渲染。
<code>lag</code>的剩余量？那就是到下一帧的时间。</p>
<p>当我们要渲染时，我们将它传入：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>render(lag / MS_PER_UPDATE);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>我们在这里除以<code>MS_PER_UPDATE</code>来<strong>归一化</strong>值。
不管更新的时间步长是多少，传给<code>render()</code>的值总在 0（恰巧在前一帧）到 1.0（恰巧在下一帧）之间。
这样，渲染引擎不必担心帧率。它只需处理 0 到 1 的值。</p>
</blockquote>
<p>渲染器知道每个游戏对象<strong>以及它当前的速度</strong>。
假设子弹在屏幕左边 20 像素的地方，正在以 400 像素每帧的速度向右移动。
如果在两帧正中渲染，我们会给<code>render()</code>传 0.5。
它绘制了半帧之前的图形，在 220 像素，啊哈，平滑的移动。</p>
<p>当然，也许这种推断是错误的。
在我们计算下一帧时，也许会发现子弹碰撞到另一障碍，或者减速，又或者别的什么。
我们只是在上一帧位置和我们<strong>认为的</strong>下一帧位置之间插值。
但只有在完成物理和 AI 更新后，我们才能知道真正的位置。</p>
<p>所以推断有猜测的成分，有时候结果是错误的。
但是，幸运地，这种修正通常不可感知。
最起码，比你不使用推断导致的卡顿更不明显。</p>
<h2><a class="header" href="#设计决策" id="设计决策">设计决策</a></h2>
<p>虽然这章我讲了很多，但是有更多的东西我没讲。
一旦你考虑显示刷新频率的同步，多线程，多 GPU，真正的游戏循环会变得更加复杂。
即使在高层，这里还有一些问题需要你回答：</p>
<h3><a class="header" href="#拥有游戏循环的是你还是平台" id="拥有游戏循环的是你还是平台">拥有游戏循环的是你，还是平台</a></h3>
<p>这个选择通常是已经由平台决定的。
如果你在做浏览器中的游戏，很可能你<strong>不能</strong>编写自己的经典游戏循环。
浏览器本身的事件驱动机制阻碍了这一点。
类似地，如果你使用现存的游戏引擎，你很可能依赖于它的游戏循环而不是自己写一个。</p>
<ul>
<li>
<p><strong>使用平台的事件循环：</strong></p>
<ul>
<li>
<p><em>简单</em>。你不必担心编写和优化自己的游戏核心循环。</p>
</li>
<li>
<p><em>平台友好。</em>
你不必明确地给平台一段时间让它处理它自己的事件，不必缓存事件，不必管理任何平台输入模型和你的不匹配之处。</p>
</li>
<li>
<p><em>你失去了对时间的控制。</em>
平台会在它方便时调用代码。
如果这不如你想要的那样平滑或者频繁，太糟了。
更糟的是，大多数应用的事件循环并未为游戏设计，通常<strong>是</strong>又慢又卡顿。</p>
</li>
</ul>
</li>
<li>
<p><strong>使用游戏引擎的循环：</strong></p>
<ul>
<li>
<p><em>不必自己编写。</em>
编写游戏循环非常需要技巧。
由于是每帧都要执行的核心代码，小小的漏洞或者性能问题就对游戏有巨大的影响。
稳固的游戏循环是使用现有引擎的原因之一。</p>
</li>
<li>
<p><em>不必自己编写。</em>
当然，硬币的另一面是，如果引擎无法满足你<strong>真正的</strong>需求，你也没法获得控制权。</p>
</li>
</ul>
</li>
<li>
<p><strong>自己写：</strong></p>
<ul>
<li>
<p><em>完全的控制。</em>
你可以做任何想做的事情。你可以为游戏的需求订制开发。</p>
</li>
<li>
<p><em>你需要与平台交互。</em>
应用框架和操作系统通常需要时间片去处理自己的事件和其他工作。
如果你拥有应用的核心循环，平台就没有这些时间片了。
你得显式定期检查，保证框架没有挂起或者混乱。</p>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#如何管理能量消耗" id="如何管理能量消耗">如何管理能量消耗</a></h3>
<p>在五年前这还不是问题。
游戏运行在插到插座上的机器上或者专用的手持设备上。
但是随着智能手机，笔记本以及移动游戏的发展，现在需要关注这个问题了。
画面绚丽，但会耗干三十分钟前充的电，并将手机变成空间加热器的游戏，可不能让人开心。</p>
<p>现在，你需要考虑的不仅仅是让游戏看上去很棒，同时也要尽可能少地使用 CPU。
你需要设置一个性能的<strong>上限</strong>：完成一帧之内所需的工作后，让 CPU 休眠。</p>
<ul>
<li>
<p><strong>尽可能快地运行：</strong></p>
<p>这是 PC 游戏的常态（即使越来越多的人在笔记本上运行游戏）。
游戏循环永远不会显式告诉系统休眠。相反，空闲的循环被划在提升 FPS 或者图像显示效果上了。</p>
<p>这会给你最好的游戏体验。
但是，也会尽可能多地使用电量。如果玩家在笔记本电脑上游玩，他们就得到了一个很好的加热器。</p>
</li>
<li>
<p><strong>固定帧率</strong></p>
<p>移动游戏更加注意游戏的体验质量，而不是最大化图像画质。
很多这种游戏都会设置最大帧率（通常是 30 或 60FPS）。
如果游戏循环在分配的时间片消耗完之前完成，剩余的时间它会休眠。</p>
<p>这给了玩家“足够好的”游戏体验，也让电池轻松了一点。</p>
</li>
</ul>
<h3><a class="header" href="#你如何控制游戏速度" id="你如何控制游戏速度">你如何控制游戏速度</a></h3>
<p>游戏循环有两个关键部分：不阻塞用户输入和自适应的帧时间步长。
输入部分很直观。关键在于你如何处理时间。
这里有数不尽的游戏可运行的平台，
每个游戏都需要在其中一些平台上运行。
如何适应平台的变化就是关键。</p>
<blockquote>
<p>创作游戏看来是人类的天性，因为每当我们建构可以计算的机器，首先做的就是在上面编游戏。
PDP-1 是一个仅有 4096 字内存的 2kHz 机器，但是 Steve Russell 和他的朋友还是在上面创建了 Spacewar!。</p>
</blockquote>
<ul>
<li>
<p><strong>固定时间步长，没有同步：</strong></p>
<p>见我们第一个样例中的代码。你只需尽可能快地运行游戏。</p>
<ul>
<li>
<p><em>简单</em>。这是主要的（好吧，唯一的）好处。</p>
</li>
<li>
<p><em>游戏速度直接受到硬件和游戏复杂度影响。</em>
主要的缺点是，如果有所变化，会直接影响游戏速度。游戏速度与游戏循环紧密相关。</p>
</li>
</ul>
</li>
<li>
<p><strong>固定时间步长，有同步：</strong></p>
<p>对复杂度控制的下一步是使用固定的时间间隔，但在循环的末尾增加同步点，保证游戏不会运行得过快。</p>
<ul>
<li>
<p><em>还是很简单。</em>
这比过于简单以至于不可行的例子只多了一行代码。
在多数游戏循环中，你可能<strong>总</strong>需要做一些同步。
你可能需要<a href="04-1%E5%8F%8C%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F.html">双缓冲</a>图形并将缓冲块与更新显示的频率同步。</p>
</li>
<li>
<p><em>电量友好。</em>
这对移动游戏至关重要。你不想消耗不必要的电量。
通过简单地休眠几个毫秒而不是试图每帧塞入更多的处理，你就节约了电量。</p>
</li>
<li>
<p><em>游戏不会运行得太快。</em>
这解决了固定循环速度的一半问题。</p>
</li>
<li>
<p><em>游戏可能运行的太慢。</em>
如果花了太多时间更新和渲染一帧，播放也会减缓。
因为这种方案没有分离更新和渲染，它比更高级的方案更容易遇到这点。
没法扔掉<strong>渲染</strong>帧来追上真实时间，游戏本身会变慢。</p>
</li>
</ul>
</li>
<li>
<p><strong>动态时间步长：</strong></p>
<p>我把这个方案放在这里作为问题的解决办法之一，附加警告：大多数我认识的游戏开发者反对它。
不过记住<strong>为什么</strong>反对它是很有价值的。</p>
<ul>
<li>
<p><em>能适应并调整，避免运行得太快或者太慢。</em>
如果游戏不能追上真实时间，它用越来越长的时间步长更新，直到追上。</p>
</li>
<li>
<p><em>让游戏不确定而且不稳定。</em>
这是真正的问题，当然。在物理和网络部分使用动态时间步长会遇见更多的困难。</p>
</li>
</ul>
</li>
<li>
<p><strong>固定更新时间步长，动态渲染：</strong></p>
<p>在示例代码中提到的最后一个选项是最复杂的，但是也是最有适应性的。
它以固定时间步长更新，但是如果需要赶上玩家的时间，可以扔掉一些<strong>渲染</strong>帧。</p>
<ul>
<li>
<p><em>能适应并调整，避免运行得太快或者太慢。</em>
只要能实时<strong>更新</strong>，游戏状态就不会落后于真实时间。如果玩家用高端的机器，它会回以更平滑的游戏体验。</p>
</li>
<li>
<p><em>更复杂。</em>
主要负面问题是需要在实现中写更多东西。
你需要将更新的时间步长调整得尽可能小来适应高端机，同时不至于在低端机上太慢。</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#参见" id="参见">参见</a></h2>
<ul>
<li>
<p>关于游戏循环的经典文章是 Glenn Fiedler 的&quot;<a href="http://gafferongames.com/game-physics/fix-your-timestep/">Fix Your Timestep</a>&quot;。如果没有这篇文章，这章就不会是这个样子。</p>
</li>
<li>
<p>Witters 关于<a href="http://www.koonsolo.com/news/dewitters-gameloop/">game loops</a>的文章也值得阅读。</p>
</li>
<li>
<p><a href="http://unity3d.com/">Unity</a>框架有一个复杂的游戏循环，细节在<a href="http://docs.unity3d.com/Manual/ExecutionOrder.html">这里</a>有详尽的解释。</p>
</li>
</ul>

				</main>

				<nav class="nav-wrapper" aria-label="Page navigation">
					<!-- Mobile navigation buttons -->
					
					<a rel="prev" href="04-1双缓冲模式.html" class="mobile-nav-chapters previous"
						title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
						<i class="fa fa-angle-left"></i>
					</a>
					

					
					<a rel="next" href="04-3更新方法.html" class="mobile-nav-chapters next"
						title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
						<i class="fa fa-angle-right"></i>
					</a>
					

					<div style="clear: both"></div>
				</nav>
			</div>
		</div>

		<nav class="nav-wide-wrapper" aria-label="Page navigation">
			
			<a href="04-1双缓冲模式.html" class="nav-chapters previous" title="Previous chapter"
				aria-label="Previous chapter" aria-keyshortcuts="Left">
				<i class="fa fa-angle-left"></i>
			</a>
			

			
			<a href="04-3更新方法.html" class="nav-chapters next" title="Next chapter"
				aria-label="Next chapter" aria-keyshortcuts="Right">
				<i class="fa fa-angle-right"></i>
			</a>
			
		</nav>

	</div>

	

	

	

	
	<script type="text/javascript">
		window.playpen_copyable = true;
	</script>
	

	

	
	<script defer src="https://cdn.staticfile.org/clipboard.js/2.0.4/clipboard.min.js"></script>
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>
	<script defer src="https://cdn.staticfile.org/highlight.js/9.18.1/languages/basic.min.js"></script>
	<script defer src="https://cdn.staticfile.org/lazysizes/5.2.0/lazysizes.min.js"></script>
	<script defer src="https://cdn.staticfile.org/mermaid/8.4.6/mermaid.min.js"></script>
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/book.js"></script>
	<!-- Custom JS scripts -->
	
	<script defer src="https://cdn.jsdelivr.net/gh/peaceshi/GameProgrammingPatterns@gh-pages/plugin/init.js"></script>
	
	
	

</body>

</html>
